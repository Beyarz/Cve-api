# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

module AST
end

class AST::Node
  def +(array); end

  def <<(element); end

  def ==(other); end

  def append(element); end

  def assign_properties(properties); end

  def children(); end

  def clone(); end

  def concat(array); end

  def eql?(other); end

  def fancy_type(); end

  def initialize(type, children=T.unsafe(nil), properties=T.unsafe(nil)); end

  def inspect(indent=T.unsafe(nil)); end

  def to_a(); end

  def to_ast(); end

  def to_s(indent=T.unsafe(nil)); end

  def to_sexp(indent=T.unsafe(nil)); end

  def to_sexp_array(); end

  def type(); end

  def updated(type=T.unsafe(nil), children=T.unsafe(nil), properties=T.unsafe(nil)); end
end

class AST::Node
end

class AST::Processor
  include ::AST::Processor::Mixin
end

module AST::Processor::Mixin
  def handler_missing(node); end

  def process(node); end

  def process_all(nodes); end
end

module AST::Processor::Mixin
end

class AST::Processor
end

module AST::Sexp
  def s(type, *children); end
end

module AST::Sexp
end

module AST
end

class Addrinfo
  def connect_internal(local_addrinfo, timeout=T.unsafe(nil)); end
end

class Array
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  def bsearch(); end

  def bsearch_index(); end

  def collect!(); end

  def deconstruct(); end

  def dig(*_); end

  def flatten!(*_); end

  def intersection(*_); end

  def pack(fmt, buffer: T.unsafe(nil)); end

  def replace(_); end

  def shelljoin(); end

  def to_csv(**options); end

  def to_h(); end
end

class Array
  def self.try_convert(_); end
end

BasicObject::BasicObject = BasicObject

class BigDecimal
  def clone(); end
  EXCEPTION_NaN = ::T.let(nil, ::T.untyped)
  SIGN_NaN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class BigDecimal
  def self.interpret_loosely(_); end
end

class Binding
  def clone(); end

  def irb(); end
end

class Bundler::Dependency
  def branch(); end

  def expanded_platforms(); end

  def git(); end
end

Bundler::Deprecate = Gem::Deprecate

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::Fetcher
  def fetch_spec(spec); end

  def fetchers(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def use_api(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  FETCHERS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def initialize(downloader, remote, display_uri); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def fetch_spec(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::Index
  def fetch_spec(spec); end

  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

module Bundler::FileUtils
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::FileUtils::Entry_
  def link(dest); end
end

module Bundler::FileUtils
  def self.cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end

  def self.link_entry(src, dest, dereference_root=T.unsafe(nil), remove_destination=T.unsafe(nil)); end
end

class Bundler::GemHelper
  def allowed_push_host(); end

  def already_tagged?(); end

  def base(); end

  def build_gem(); end

  def built_gem_path(); end

  def clean?(); end

  def committed?(); end

  def gem_command(); end

  def gem_key(); end

  def gem_push?(); end

  def gem_push_host(); end

  def gemspec(); end

  def git_push(remote=T.unsafe(nil)); end

  def guard_clean(); end

  def initialize(base=T.unsafe(nil), name=T.unsafe(nil)); end

  def install(); end

  def install_gem(built_gem_path=T.unsafe(nil), local=T.unsafe(nil)); end

  def name(); end

  def perform_git_push(options=T.unsafe(nil)); end

  def rubygem_push(path); end

  def sh(cmd, &block); end

  def sh_with_input(cmd); end

  def sh_with_status(cmd, &block); end

  def spec_path(); end

  def tag_version(); end

  def version(); end

  def version_tag(); end
end

class Bundler::GemHelper
  def self.gemspec(&block); end

  def self.install_tasks(opts=T.unsafe(nil)); end

  def self.instance(); end

  def self.instance=(instance); end
end

class Bundler::GemVersionPromoter
  def initialize(locked_specs=T.unsafe(nil), unlock_gems=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def locked_specs(); end

  def major?(); end

  def minor?(); end

  def prerelease_specified(); end

  def prerelease_specified=(prerelease_specified); end

  def sort_versions(dep, spec_groups); end

  def strict(); end

  def strict=(strict); end

  def unlock_gems(); end
  DEBUG = ::T.let(nil, ::T.untyped)
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Index
  include ::Enumerable
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::Installer
  def generate_bundler_executable_stubs(spec, options=T.unsafe(nil)); end

  def generate_standalone_bundler_executable_stubs(spec); end

  def initialize(root, definition); end

  def post_install_messages(); end

  def run(options); end
end

class Bundler::Installer
  def self.ambiguous_gems(); end

  def self.ambiguous_gems=(ambiguous_gems); end

  def self.install(root, definition, options=T.unsafe(nil)); end
end

class Bundler::Molinillo::DependencyGraph
  include ::Enumerable
end

class Bundler::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Bundler::Molinillo::DependencyGraph::Vertex
  def _recursive_predecessors(vertices=T.unsafe(nil)); end

  def _recursive_successors(vertices=T.unsafe(nil)); end
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def bundler_plugin_api_source?(); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*_); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

class Bundler::Plugin::Index
  def installed_plugins(); end

  def plugin_commands(plugin); end
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

module Bundler::Plugin
  def self.list(); end
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::RubygemsIntegration
  def add_to_load_path(paths); end

  def all_specs(); end

  def backport_ext_builder_monitor(); end

  def correct_for_windows_path(path); end

  def default_stubs(); end

  def find_name(name); end

  def gem_remote_fetcher(); end

  def plain_specs(); end

  def plain_specs=(specs); end

  def stub_rubygems(specs); end

  def use_gemdeps(gemfile); end
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(&blk); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

class Bundler::Source::Git
  def glob(); end
end

class Bundler::SpecSet
  include ::Enumerable
end

class Bundler::Thor
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def help(command=T.unsafe(nil), subcommand=T.unsafe(nil)); end
  HELP_MAPPINGS = ::T.let(nil, ::T.untyped)
  TEMPLATE_EXTNAME = ::T.let(nil, ::T.untyped)
  THOR_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module Bundler::Thor::Actions
  def _cleanup_options_and_set(options, key); end

  def _shared_configuration(); end

  def action(instance); end

  def add_file(destination, *args, &block); end

  def add_link(destination, *args); end

  def append_file(path, *args, &block); end

  def append_to_file(path, *args, &block); end

  def apply(path, config=T.unsafe(nil)); end

  def behavior(); end

  def behavior=(behavior); end

  def chmod(path, mode, config=T.unsafe(nil)); end

  def comment_lines(path, flag, *args); end

  def copy_file(source, *args, &block); end

  def create_file(destination, *args, &block); end

  def create_link(destination, *args); end

  def destination_root(); end

  def destination_root=(root); end

  def directory(source, *args, &block); end

  def empty_directory(destination, config=T.unsafe(nil)); end

  def find_in_source_paths(file); end

  def get(source, *args, &block); end

  def gsub_file(path, flag, *args, &block); end

  def in_root(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def inject_into_class(path, klass, *args, &block); end

  def inject_into_file(destination, *args, &block); end

  def inject_into_module(path, module_name, *args, &block); end

  def insert_into_file(destination, *args, &block); end

  def inside(dir=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def link_file(source, *args); end

  def prepend_file(path, *args, &block); end

  def prepend_to_file(path, *args, &block); end

  def relative_to_original_destination_root(path, remove_dot=T.unsafe(nil)); end

  def remove_dir(path, config=T.unsafe(nil)); end

  def remove_file(path, config=T.unsafe(nil)); end

  def run(command, config=T.unsafe(nil)); end

  def run_ruby_script(command, config=T.unsafe(nil)); end

  def source_paths(); end

  def template(source, *args, &block); end

  def thor(command, *args); end

  def uncomment_lines(path, flag, *args); end
  WARNINGS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Actions::CapturableERB
end

class Bundler::Thor::Actions::CapturableERB
end

module Bundler::Thor::Actions::ClassMethods
  def add_runtime_options!(); end

  def source_paths(); end

  def source_paths_for_search(); end

  def source_root(path=T.unsafe(nil)); end
end

module Bundler::Thor::Actions::ClassMethods
end

class Bundler::Thor::Actions::CreateFile
  def data(); end

  def force_on_collision?(); end

  def force_or_skip_or_conflict(force, skip, &block); end

  def identical?(); end

  def initialize(base, destination, data, config=T.unsafe(nil)); end

  def on_conflict_behavior(&block); end

  def render(); end
end

class Bundler::Thor::Actions::CreateFile
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::Directory
  def execute!(); end

  def file_level_lookup(previous_lookup); end

  def files(lookup); end

  def initialize(base, source, destination=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def source(); end
end

class Bundler::Thor::Actions::Directory
end

class Bundler::Thor::Actions::EmptyDirectory
  def base(); end

  def config(); end

  def convert_encoded_instructions(filename); end

  def destination(); end

  def destination=(destination); end

  def exists?(); end

  def given_destination(); end

  def initialize(base, destination, config=T.unsafe(nil)); end

  def invoke!(); end

  def invoke_with_conflict_check(&block); end

  def on_conflict_behavior(); end

  def on_file_clash_behavior(); end

  def pretend?(); end

  def relative_destination(); end

  def revoke!(); end

  def say_status(status, color); end
end

class Bundler::Thor::Actions::EmptyDirectory
end

class Bundler::Thor::Actions::InjectIntoFile
  def behavior(); end

  def flag(); end

  def initialize(base, destination, data, config); end

  def replace!(regexp, string, force); end

  def replacement(); end

  def say_status(behavior, warning: T.unsafe(nil), color: T.unsafe(nil)); end
end

class Bundler::Thor::Actions::InjectIntoFile
end

module Bundler::Thor::Actions
  def self.included(base); end
end

class Bundler::Thor::AmbiguousCommandError
end

class Bundler::Thor::AmbiguousCommandError
end

Bundler::Thor::AmbiguousTaskError = Bundler::Thor::AmbiguousCommandError

class Bundler::Thor::Argument
  def banner(); end

  def default(); end

  def default_banner(); end

  def description(); end

  def enum(); end

  def human_name(); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def required(); end

  def required?(); end

  def show_default?(); end

  def type(); end

  def usage(); end

  def valid_type?(type); end

  def validate!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Argument
end

class Bundler::Thor::Arguments
  def initialize(arguments=T.unsafe(nil)); end

  def parse(args); end

  def remaining(); end
  NUMERIC = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Arguments
  def self.parse(*args); end

  def self.split(args); end
end

module Bundler::Thor::Base
  def args(); end

  def args=(args); end

  def initialize(args=T.unsafe(nil), local_options=T.unsafe(nil), config=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def parent_options(); end

  def parent_options=(parent_options); end
end

module Bundler::Thor::Base::ClassMethods
  def all_commands(); end

  def all_tasks(); end

  def allow_incompatible_default_type!(); end

  def argument(name, options=T.unsafe(nil)); end

  def arguments(); end

  def attr_accessor(*_); end

  def attr_reader(*_); end

  def attr_writer(*_); end

  def baseclass(); end

  def basename(); end

  def build_option(name, options, scope); end

  def build_options(options, scope); end

  def check_default_type(); end

  def check_default_type!(); end

  def check_unknown_options(); end

  def check_unknown_options!(); end

  def check_unknown_options?(config); end

  def class_option(name, options=T.unsafe(nil)); end

  def class_options(options=T.unsafe(nil)); end

  def class_options_help(shell, groups=T.unsafe(nil)); end

  def commands(); end

  def create_command(meth); end

  def create_task(meth); end

  def disable_required_check?(command_name); end

  def dispatch(command, given_args, given_opts, config); end

  def exit_on_failure?(); end

  def find_and_refresh_command(name); end

  def find_and_refresh_task(name); end

  def from_superclass(method, default=T.unsafe(nil)); end

  def group(name=T.unsafe(nil)); end

  def handle_argument_error(command, error, args, arity); end

  def handle_no_command_error(command, has_namespace=T.unsafe(nil)); end

  def handle_no_task_error(command, has_namespace=T.unsafe(nil)); end

  def inherited(klass); end

  def initialize_added(); end

  def is_thor_reserved_word?(word, type); end

  def method_added(meth); end

  def namespace(name=T.unsafe(nil)); end

  def no_commands(&block); end

  def no_commands?(); end

  def no_commands_context(); end

  def no_tasks(&block); end

  def print_options(shell, options, group_name=T.unsafe(nil)); end

  def public_command(*names); end

  def public_task(*names); end

  def remove_argument(*names); end

  def remove_class_option(*names); end

  def remove_command(*names); end

  def remove_task(*names); end

  def start(given_args=T.unsafe(nil), config=T.unsafe(nil)); end

  def stop_on_unknown_option?(command_name); end

  def strict_args_position(); end

  def strict_args_position!(); end

  def strict_args_position?(config); end

  def tasks(); end
end

module Bundler::Thor::Base::ClassMethods
end

module Bundler::Thor::Base
  def self.included(base); end

  def self.register_klass_file(klass); end

  def self.shell(); end

  def self.shell=(shell); end

  def self.subclass_files(); end

  def self.subclasses(); end
end

class Bundler::Thor::Command
  def formatted_usage(klass, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def handle_argument_error?(instance, error, caller); end

  def handle_no_method_error?(instance, error, caller); end

  def hidden?(); end

  def initialize(name, description, long_description, usage, options=T.unsafe(nil)); end

  def local_method?(instance, name); end

  def not_debugging?(instance); end

  def private_method?(instance); end

  def public_method?(instance); end

  def required_arguments_for(klass, usage); end

  def required_options(); end

  def run(instance, args=T.unsafe(nil)); end

  def sans_backtrace(backtrace, caller); end
  FILE_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Command
end

module Bundler::Thor::CoreExt
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
  def [](key); end

  def []=(key, value); end

  def convert_key(key); end

  def delete(key); end

  def fetch(key, *args); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(key); end

  def merge(other); end

  def merge!(other); end

  def method_missing(method, *args); end

  def replace(other_hash); end

  def reverse_merge(other); end

  def reverse_merge!(other_hash); end

  def values_at(*indices); end
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
end

module Bundler::Thor::CoreExt
end

Bundler::Thor::Correctable = DidYouMean::Correctable

class Bundler::Thor::DynamicCommand
  def initialize(name, options=T.unsafe(nil)); end
end

class Bundler::Thor::DynamicCommand
end

Bundler::Thor::DynamicTask = Bundler::Thor::DynamicCommand

class Bundler::Thor::Error
end

class Bundler::Thor::Error
end

class Bundler::Thor::Group
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def _invoke_for_class_method(klass, command=T.unsafe(nil), *args, &block); end
end

class Bundler::Thor::Group
  extend ::Bundler::Thor::Base::ClassMethods
  extend ::Bundler::Thor::Invocation::ClassMethods
  def self.banner(); end

  def self.desc(description=T.unsafe(nil)); end

  def self.get_options_from_invocations(group_options, base_options); end

  def self.handle_argument_error(command, error, _args, arity); end

  def self.help(shell); end

  def self.invocation_blocks(); end

  def self.invocations(); end

  def self.invoke(*names, &block); end

  def self.invoke_from_option(*names, &block); end

  def self.printable_commands(*_); end

  def self.printable_tasks(*_); end

  def self.remove_invocation(*names); end

  def self.self_command(); end

  def self.self_task(); end
end

class Bundler::Thor::HiddenCommand
end

class Bundler::Thor::HiddenCommand
end

Bundler::Thor::HiddenTask = Bundler::Thor::HiddenCommand

module Bundler::Thor::Invocation
  def _parse_initialization_options(args, opts, config); end

  def _retrieve_class_and_command(name, sent_command=T.unsafe(nil)); end

  def _retrieve_class_and_task(name, sent_command=T.unsafe(nil)); end

  def _shared_configuration(); end

  def current_command_chain(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def invoke(name=T.unsafe(nil), *args); end

  def invoke_all(); end

  def invoke_command(command, *args); end

  def invoke_task(command, *args); end

  def invoke_with_padding(*args); end
end

module Bundler::Thor::Invocation::ClassMethods
  def prepare_for_invocation(key, name); end
end

module Bundler::Thor::Invocation::ClassMethods
end

module Bundler::Thor::Invocation
  def self.included(base); end
end

class Bundler::Thor::InvocationError
end

class Bundler::Thor::InvocationError
end

module Bundler::Thor::LineEditor
end

class Bundler::Thor::LineEditor::Basic
  def initialize(prompt, options); end

  def options(); end

  def prompt(); end

  def readline(); end
end

class Bundler::Thor::LineEditor::Basic
  def self.available?(); end
end

class Bundler::Thor::LineEditor::Readline
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
  def initialize(text); end

  def matches(); end
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
end

class Bundler::Thor::LineEditor::Readline
end

module Bundler::Thor::LineEditor
  def self.best_available(); end

  def self.readline(prompt, options=T.unsafe(nil)); end
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::NestedContext
  def enter(); end

  def entered?(); end
end

class Bundler::Thor::NestedContext
end

class Bundler::Thor::NoKwargSpellChecker
  def initialize(dictionary); end
end

class Bundler::Thor::NoKwargSpellChecker
end

class Bundler::Thor::Option
  def aliases(); end

  def array?(); end

  def boolean?(); end

  def dasherize(str); end

  def dasherized?(); end

  def group(); end

  def hash?(); end

  def hide(); end

  def lazy_default(); end

  def numeric?(); end

  def repeatable(); end

  def string?(); end

  def switch_name(); end

  def undasherize(str); end

  def usage(padding=T.unsafe(nil)); end

  def validate_default_type!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Option
  def self.parse(key, value); end
end

class Bundler::Thor::Options
  def assign_result!(option, result); end

  def check_unknown!(); end

  def current_is_switch?(); end

  def current_is_switch_formatted?(); end

  def initialize(hash_options=T.unsafe(nil), defaults=T.unsafe(nil), stop_on_unknown=T.unsafe(nil), disable_required_check=T.unsafe(nil)); end

  def normalize_switch(arg); end

  def parse_boolean(switch); end

  def parse_peek(switch, option); end

  def parsing_options?(); end

  def switch?(arg); end

  def switch_option(arg); end
  EQ_RE = ::T.let(nil, ::T.untyped)
  LONG_RE = ::T.let(nil, ::T.untyped)
  OPTS_END = ::T.let(nil, ::T.untyped)
  SHORT_NUM = ::T.let(nil, ::T.untyped)
  SHORT_RE = ::T.let(nil, ::T.untyped)
  SHORT_SQ_RE = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Options
  def self.to_switches(options); end
end

class Bundler::Thor::RequiredArgumentMissingError
end

class Bundler::Thor::RequiredArgumentMissingError
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Shell
  def _shared_configuration(); end

  def ask(*args, &block); end

  def error(*args, &block); end

  def file_collision(*args, &block); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def no?(*args, &block); end

  def print_in_columns(*args, &block); end

  def print_table(*args, &block); end

  def print_wrapped(*args, &block); end

  def say(*args, &block); end

  def say_status(*args, &block); end

  def set_color(*args, &block); end

  def shell(); end

  def shell=(shell); end

  def terminal_width(*args, &block); end

  def with_padding(); end

  def yes?(*args, &block); end
  SHELL_DELEGATED_METHODS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Basic
  def answer_match(possibilities, answer, case_insensitive); end

  def as_unicode(); end

  def ask(statement, *args); end

  def ask_filtered(statement, color, options); end

  def ask_simply(statement, color, options); end

  def base(); end

  def base=(base); end

  def can_display_colors?(); end

  def dynamic_width(); end

  def dynamic_width_stty(); end

  def dynamic_width_tput(); end

  def error(statement); end

  def file_collision(destination); end

  def file_collision_help(); end

  def git_merge_tool(); end

  def indent(count=T.unsafe(nil)); end

  def is?(value); end

  def lookup_color(color); end

  def merge(destination, content); end

  def merge_tool(); end

  def mute(); end

  def mute?(); end

  def no?(statement, color=T.unsafe(nil)); end

  def padding(); end

  def padding=(value); end

  def prepare_message(message, *color); end

  def print_in_columns(array); end

  def print_table(array, options=T.unsafe(nil)); end

  def print_wrapped(message, options=T.unsafe(nil)); end

  def quiet?(); end

  def say(message=T.unsafe(nil), color=T.unsafe(nil), force_new_line=T.unsafe(nil)); end

  def say_status(status, message, log_status=T.unsafe(nil)); end

  def set_color(string, *_); end

  def show_diff(destination, content); end

  def stderr(); end

  def stdout(); end

  def terminal_width(); end

  def truncate(string, width); end

  def unix?(); end

  def yes?(statement, color=T.unsafe(nil)); end
  DEFAULT_TERMINAL_WIDTH = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Basic
end

class Bundler::Thor::Shell::Color
  def are_colors_disabled?(); end

  def diff_lcs_loaded?(); end

  def output_diff_line(diff); end

  def set_color(string, *colors); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Color
end

class Bundler::Thor::Shell::HTML
  def ask(statement, color=T.unsafe(nil)); end

  def diff_lcs_loaded?(); end

  def output_diff_line(diff); end

  def set_color(string, *colors); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::HTML
end

module Bundler::Thor::Shell
end

Bundler::Thor::Task = Bundler::Thor::Command

class Bundler::Thor::UndefinedCommandError
  include ::DidYouMean::Correctable
  def all_commands(); end

  def command(); end

  def initialize(command, all_commands, namespace); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
end

class Bundler::Thor::UndefinedCommandError
end

Bundler::Thor::UndefinedTaskError = Bundler::Thor::UndefinedCommandError

class Bundler::Thor::UnknownArgumentError
  include ::DidYouMean::Correctable
  def initialize(switches, unknown); end

  def switches(); end

  def unknown(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
end

class Bundler::Thor::UnknownArgumentError
end

module Bundler::Thor::Util
end

module Bundler::Thor::Util
  def self.camel_case(str); end

  def self.escape_globs(path); end

  def self.escape_html(string); end

  def self.find_by_namespace(namespace); end

  def self.find_class_and_command_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.find_class_and_task_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.globs_for(path); end

  def self.load_thorfile(path, content=T.unsafe(nil), debug=T.unsafe(nil)); end

  def self.namespace_from_thor_class(constant); end

  def self.namespaces_in_content(contents, file=T.unsafe(nil)); end

  def self.ruby_command(); end

  def self.snake_case(str); end

  def self.thor_classes_in(klass); end

  def self.thor_root(); end

  def self.thor_root_glob(); end

  def self.user_home(); end
end

class Bundler::Thor
  extend ::Bundler::Thor::Base::ClassMethods
  extend ::Bundler::Thor::Invocation::ClassMethods
  def self.banner(command, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.check_unknown_options!(options=T.unsafe(nil)); end

  def self.command_help(shell, command_name); end

  def self.default_command(meth=T.unsafe(nil)); end

  def self.default_task(meth=T.unsafe(nil)); end

  def self.deprecation_warning(message); end

  def self.desc(usage, description, options=T.unsafe(nil)); end

  def self.disable_required_check(); end

  def self.disable_required_check!(*command_names); end

  def self.disable_required_check?(command); end

  def self.dispatch(meth, given_args, given_opts, config); end

  def self.dynamic_command_class(); end

  def self.find_command_possibilities(meth); end

  def self.find_task_possibilities(meth); end

  def self.help(shell, subcommand=T.unsafe(nil)); end

  def self.long_desc(long_description, options=T.unsafe(nil)); end

  def self.map(mappings=T.unsafe(nil), **kw); end

  def self.method_option(name, options=T.unsafe(nil)); end

  def self.method_options(options=T.unsafe(nil)); end

  def self.normalize_command_name(meth); end

  def self.normalize_task_name(meth); end

  def self.option(name, options=T.unsafe(nil)); end

  def self.options(options=T.unsafe(nil)); end

  def self.package_name(name, _=T.unsafe(nil)); end

  def self.printable_commands(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.printable_tasks(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.register(klass, subcommand_name, usage, description, options=T.unsafe(nil)); end

  def self.retrieve_command_name(args); end

  def self.retrieve_task_name(args); end

  def self.stop_on_unknown_option(); end

  def self.stop_on_unknown_option!(*command_names); end

  def self.stop_on_unknown_option?(command); end

  def self.subcommand(subcommand, subcommand_class); end

  def self.subcommand_classes(); end

  def self.subcommand_help(cmd); end

  def self.subcommands(); end

  def self.subtask(subcommand, subcommand_class); end

  def self.subtask_help(cmd); end

  def self.subtasks(); end

  def self.task_help(shell, command_name); end
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg, newline=T.unsafe(nil)); end

  def debug(msg, newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg, newline=T.unsafe(nil)); end

  def info(msg, newline=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg, newline=T.unsafe(nil)); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

module Bundler::URI
  include ::Bundler::URI::RFC2396_REGEXP
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ABS_URI_REF = ::T.let(nil, ::T.untyped)
  DEFAULT_PARSER = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  OPAQUE = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REGISTRY = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  REL_URI_REF = ::T.let(nil, ::T.untyped)
  RFC3986_PARSER = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TBLDECWWWCOMP_ = ::T.let(nil, ::T.untyped)
  TBLENCWWWCOMP_ = ::T.let(nil, ::T.untyped)
  UNSAFE = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_CODE = ::T.let(nil, ::T.untyped)
  WEB_ENCODINGS_ = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::BadURIError
end

class Bundler::URI::BadURIError
end

class Bundler::URI::Error
end

class Bundler::URI::Error
end

module Bundler::URI::Escape
  def decode(*arg); end

  def encode(*arg); end

  def escape(*arg); end

  def unescape(*arg); end
end

module Bundler::URI::Escape
end

class Bundler::URI::FTP
  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  TYPECODE = ::T.let(nil, ::T.untyped)
  TYPECODE_PREFIX = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class Bundler::URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::File
end

class Bundler::URI::Generic
  include ::Bundler::URI
  include ::Bundler::URI::RFC2396_REGEXP
  def +(oth); end

  def -(oth); end

  def ==(oth); end

  def absolute(); end

  def absolute?(); end

  def coerce(oth); end

  def component(); end

  def component_ary(); end

  def default_port(); end

  def eql?(oth); end

  def find_proxy(env=T.unsafe(nil)); end

  def fragment(); end

  def fragment=(v); end

  def hierarchical?(); end

  def host(); end

  def host=(v); end

  def hostname(); end

  def hostname=(v); end

  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser=T.unsafe(nil), arg_check=T.unsafe(nil)); end

  def merge(oth); end

  def merge!(oth); end

  def normalize(); end

  def normalize!(); end

  def opaque(); end

  def opaque=(v); end

  def parser(); end

  def password(); end

  def password=(password); end

  def path(); end

  def path=(v); end

  def port(); end

  def port=(v); end

  def query(); end

  def query=(v); end

  def registry(); end

  def registry=(v); end

  def relative?(); end

  def route_from(oth); end

  def route_to(oth); end

  def scheme(); end

  def scheme=(v); end

  def select(*components); end

  def set_host(v); end

  def set_opaque(v); end

  def set_password(v); end

  def set_path(v); end

  def set_port(v); end

  def set_registry(v); end

  def set_scheme(v); end

  def set_user(v); end

  def set_userinfo(user, password=T.unsafe(nil)); end

  def user(); end

  def user=(user); end

  def userinfo(); end

  def userinfo=(userinfo); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  USE_REGISTRY = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::Generic
  def self.build(args); end

  def self.build2(args); end

  def self.component(); end

  def self.default_port(); end

  def self.use_proxy?(hostname, addr, port, no_proxy); end

  def self.use_registry(); end
end

class Bundler::URI::HTTP
  def request_uri(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::HTTP
end

class Bundler::URI::HTTPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::HTTPS
end

class Bundler::URI::InvalidComponentError
end

class Bundler::URI::InvalidComponentError
end

class Bundler::URI::InvalidURIError
end

class Bundler::URI::InvalidURIError
end

class Bundler::URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  SCOPE = ::T.let(nil, ::T.untyped)
  SCOPE_BASE = ::T.let(nil, ::T.untyped)
  SCOPE_ONE = ::T.let(nil, ::T.untyped)
  SCOPE_SUB = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::LDAP
end

class Bundler::URI::LDAPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::LDAPS
end

class Bundler::URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  EMAIL_REGEXP = ::T.let(nil, ::T.untyped)
  HEADER_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::MailTo
end

Bundler::URI::Parser = Bundler::URI::RFC2396_Parser

Bundler::URI::REGEXP = Bundler::URI::RFC2396_REGEXP

class Bundler::URI::RFC2396_Parser
  include ::Bundler::URI::RFC2396_REGEXP
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class Bundler::URI::RFC2396_Parser
end

module Bundler::URI::RFC2396_REGEXP
end

module Bundler::URI::RFC2396_REGEXP::PATTERN
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ALNUM = ::T.let(nil, ::T.untyped)
  ALPHA = ::T.let(nil, ::T.untyped)
  DOMLABEL = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HEX = ::T.let(nil, ::T.untyped)
  HIER_PART = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  HOSTNAME = ::T.let(nil, ::T.untyped)
  HOSTPORT = ::T.let(nil, ::T.untyped)
  IPV4ADDR = ::T.let(nil, ::T.untyped)
  IPV6ADDR = ::T.let(nil, ::T.untyped)
  IPV6REF = ::T.let(nil, ::T.untyped)
  NET_PATH = ::T.let(nil, ::T.untyped)
  OPAQUE_PART = ::T.let(nil, ::T.untyped)
  PATH_SEGMENTS = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REG_NAME = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_SEGMENT = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TOPLABEL = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  URIC = ::T.let(nil, ::T.untyped)
  URIC_NO_SLASH = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  X_ABS_URI = ::T.let(nil, ::T.untyped)
  X_REL_URI = ::T.let(nil, ::T.untyped)
end

module Bundler::URI::RFC2396_REGEXP::PATTERN
end

module Bundler::URI::RFC2396_REGEXP
end

class Bundler::URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_URI = ::T.let(nil, ::T.untyped)
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::RFC3986_Parser
end

module Bundler::URI::Util
end

module Bundler::URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module Bundler::URI
  extend ::Bundler::URI::Escape
  def self.decode_www_form(str, enc=T.unsafe(nil), separator: T.unsafe(nil), use__charset_: T.unsafe(nil), isindex: T.unsafe(nil)); end

  def self.decode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.encode_www_form(enum, enc=T.unsafe(nil)); end

  def self.encode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.extract(str, schemes=T.unsafe(nil), &block); end

  def self.get_encoding(label); end

  def self.join(*str); end

  def self.parse(uri); end

  def self.regexp(schemes=T.unsafe(nil)); end

  def self.scheme_list(); end

  def self.split(uri); end
end

module Bundler::VersionRanges
end

class Bundler::VersionRanges::NEq
  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::NEq
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def cover?(v); end

  def empty?(); end

  def left(); end

  def left=(_); end

  def right(); end

  def right=(_); end

  def single?(); end
  INFINITY = ::T.let(nil, ::T.untyped)
  UNIVERSAL = ::T.let(nil, ::T.untyped)
  ZERO = ::T.let(nil, ::T.untyped)
end

class Bundler::VersionRanges::ReqR::Endpoint
  def inclusive(); end

  def inclusive=(_); end

  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::ReqR::Endpoint
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def self.[](*_); end

  def self.members(); end
end

module Bundler::VersionRanges
  def self.empty?(ranges, neqs); end

  def self.for(requirement); end

  def self.for_many(requirements); end
end

module Bundler
  def self.original_exec(*args); end

  def self.original_system(*args); end

  def self.unbundled_env(); end

  def self.unbundled_exec(*args); end

  def self.unbundled_system(*args); end

  def self.with_unbundled_env(); end
end

module CGI::HtmlExtension
  def a(href=T.unsafe(nil)); end

  def base(href=T.unsafe(nil)); end

  def blockquote(cite=T.unsafe(nil)); end

  def caption(align=T.unsafe(nil)); end

  def checkbox(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def checkbox_group(name=T.unsafe(nil), *values); end

  def file_field(name=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def form(method=T.unsafe(nil), action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def hidden(name=T.unsafe(nil), value=T.unsafe(nil)); end

  def html(attributes=T.unsafe(nil)); end

  def image_button(src=T.unsafe(nil), name=T.unsafe(nil), alt=T.unsafe(nil)); end

  def img(src=T.unsafe(nil), alt=T.unsafe(nil), width=T.unsafe(nil), height=T.unsafe(nil)); end

  def multipart_form(action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def password_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def popup_menu(name=T.unsafe(nil), *values); end

  def radio_button(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def radio_group(name=T.unsafe(nil), *values); end

  def reset(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def scrolling_list(name=T.unsafe(nil), *values); end

  def submit(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def text_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def textarea(name=T.unsafe(nil), cols=T.unsafe(nil), rows=T.unsafe(nil)); end
end

module CGI::HtmlExtension
end

class Class
  def json_creatable?(); end
end

class Complex
  def self.polar(*_); end

  def self.rect(*_); end

  def self.rectangular(*_); end
end

module Crass
end

class Crass::Parser
  def consume_at_rule(input=T.unsafe(nil)); end

  def consume_component_value(input=T.unsafe(nil)); end

  def consume_declaration(input=T.unsafe(nil)); end

  def consume_declarations(input=T.unsafe(nil), options=T.unsafe(nil)); end

  def consume_function(input=T.unsafe(nil)); end

  def consume_qualified_rule(input=T.unsafe(nil)); end

  def consume_rules(flags=T.unsafe(nil)); end

  def consume_simple_block(input=T.unsafe(nil)); end

  def create_node(type, properties=T.unsafe(nil)); end

  def create_selector(input); end

  def create_style_rule(rule); end

  def initialize(input, options=T.unsafe(nil)); end

  def parse_component_value(input=T.unsafe(nil)); end

  def parse_component_values(input=T.unsafe(nil)); end

  def parse_declaration(input=T.unsafe(nil)); end

  def parse_declarations(input=T.unsafe(nil), options=T.unsafe(nil)); end

  def parse_properties(input=T.unsafe(nil)); end

  def parse_rule(input=T.unsafe(nil)); end

  def parse_value(nodes); end

  def tokens(); end
  BLOCK_END_TOKENS = ::T.let(nil, ::T.untyped)
end

class Crass::Parser
  def self.parse_properties(input, options=T.unsafe(nil)); end

  def self.parse_rules(input, options=T.unsafe(nil)); end

  def self.parse_stylesheet(input, options=T.unsafe(nil)); end

  def self.stringify(nodes, options=T.unsafe(nil)); end
end

class Crass::Scanner
  def consume(); end

  def consume_rest(); end

  def current(); end

  def eos?(); end

  def initialize(input); end

  def mark(); end

  def marked(); end

  def marker(); end

  def marker=(marker); end

  def peek(length=T.unsafe(nil)); end

  def pos(); end

  def pos=(pos); end

  def reconsume(); end

  def reset(); end

  def scan(pattern); end

  def scan_until(pattern); end

  def string(); end
end

class Crass::Scanner
end

class Crass::TokenScanner
  def collect(); end

  def consume(); end

  def current(); end

  def initialize(tokens); end

  def peek(); end

  def pos(); end

  def reconsume(); end

  def reset(); end

  def tokens(); end
end

class Crass::TokenScanner
end

class Crass::Tokenizer
  def consume(); end

  def consume_bad_url(); end

  def consume_comments(); end

  def consume_escaped(); end

  def consume_ident(); end

  def consume_name(); end

  def consume_number(); end

  def consume_numeric(); end

  def consume_string(ending=T.unsafe(nil)); end

  def consume_unicode_range(); end

  def consume_url(); end

  def convert_string_to_number(str); end

  def create_token(type, properties=T.unsafe(nil)); end

  def initialize(input, options=T.unsafe(nil)); end

  def preprocess(input); end

  def start_identifier?(text=T.unsafe(nil)); end

  def start_number?(text=T.unsafe(nil)); end

  def tokenize(); end

  def valid_escape?(text=T.unsafe(nil)); end
  RE_COMMENT_CLOSE = ::T.let(nil, ::T.untyped)
  RE_DIGIT = ::T.let(nil, ::T.untyped)
  RE_ESCAPE = ::T.let(nil, ::T.untyped)
  RE_HEX = ::T.let(nil, ::T.untyped)
  RE_NAME = ::T.let(nil, ::T.untyped)
  RE_NAME_START = ::T.let(nil, ::T.untyped)
  RE_NON_PRINTABLE = ::T.let(nil, ::T.untyped)
  RE_NUMBER_DECIMAL = ::T.let(nil, ::T.untyped)
  RE_NUMBER_EXPONENT = ::T.let(nil, ::T.untyped)
  RE_NUMBER_SIGN = ::T.let(nil, ::T.untyped)
  RE_NUMBER_STR = ::T.let(nil, ::T.untyped)
  RE_QUOTED_URL_START = ::T.let(nil, ::T.untyped)
  RE_UNICODE_RANGE_END = ::T.let(nil, ::T.untyped)
  RE_UNICODE_RANGE_START = ::T.let(nil, ::T.untyped)
  RE_WHITESPACE = ::T.let(nil, ::T.untyped)
  RE_WHITESPACE_ANCHORED = ::T.let(nil, ::T.untyped)
end

class Crass::Tokenizer
  def self.tokenize(input, options=T.unsafe(nil)); end
end

module Crass
  def self.parse(input, options=T.unsafe(nil)); end

  def self.parse_properties(input, options=T.unsafe(nil)); end
end

class Date
  def infinite?(); end
end

class Date::Error
end

class Date::Error
end

class Date::Infinity
  def initialize(d=T.unsafe(nil)); end
end

class Delegator
  def !=(obj); end

  def ==(obj); end

  def __getobj__(); end

  def __setobj__(obj); end

  def eql?(obj); end

  def initialize(obj); end

  def marshal_dump(); end

  def marshal_load(data); end

  def method_missing(m, *args, &block); end

  def methods(all=T.unsafe(nil)); end

  def protected_methods(all=T.unsafe(nil)); end

  def public_methods(all=T.unsafe(nil)); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Delegator
  def self.const_missing(n); end

  def self.delegating_block(mid); end

  def self.public_api(); end
end

class DidYouMean::ClassNameChecker
  def class_name(); end

  def class_names(); end

  def corrections(); end

  def initialize(exception); end

  def scopes(); end
end

class DidYouMean::CorrectElement
  def call(names, element); end
end

class DidYouMean::CorrectElement
end

module DidYouMean::Correctable
  def corrections(); end

  def original_message(); end

  def spell_checker(); end

  def to_s(); end
end

module DidYouMean::Jaro
  def self.distance(str1, str2); end
end

module DidYouMean::JaroWinkler
  def self.distance(str1, str2); end
end

class DidYouMean::KeyErrorChecker
  def corrections(); end

  def initialize(key_error); end
end

class DidYouMean::KeyErrorChecker
end

module DidYouMean::Levenshtein
  def self.distance(str1, str2); end

  def self.min3(a, b, c); end
end

class DidYouMean::MethodNameChecker
  def corrections(); end

  def initialize(exception); end

  def method_name(); end

  def method_names(); end

  def names_to_exclude(); end

  def receiver(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

class DidYouMean::NullChecker
  def corrections(); end

  def initialize(*_); end
end

class DidYouMean::ParseDimensions
  def call(); end

  def initialize(dictionary, separator); end
end

class DidYouMean::ParseDimensions
end

class DidYouMean::PlainFormatter
  def message_for(corrections); end
end

class DidYouMean::PlainFormatter
end

class DidYouMean::TreeSpellChecker
  def augment(); end

  def correct(input); end

  def dictionary(); end

  def dimensions(); end

  def initialize(dictionary:, separator: T.unsafe(nil), augment: T.unsafe(nil)); end

  def separator(); end
end

class DidYouMean::TreeSpellChecker
end

class DidYouMean::VariableNameChecker
  def corrections(); end

  def cvar_names(); end

  def initialize(exception); end

  def ivar_names(); end

  def lvar_names(); end

  def method_names(); end

  def name(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module DidYouMean
  def self.correct_error(error_class, spell_checker); end

  def self.formatter(); end

  def self.formatter=(formatter); end
end

class Dir
  def children(); end

  def each_child(); end
end

module Dir::Tmpname
  UNUSABLE_CHARS = ::T.let(nil, ::T.untyped)
end

class Dir
  def self.children(*_); end

  def self.each_child(*_); end

  def self.empty?(_); end

  def self.exists?(_); end

  def self.tmpdir(); end
end

module Dotenv
end

class Dotenv::Environment
  def apply(); end

  def apply!(); end

  def filename(); end

  def initialize(filename, is_load=T.unsafe(nil)); end

  def load(is_load=T.unsafe(nil)); end

  def read(); end
end

class Dotenv::Environment
end

class Dotenv::Error
end

class Dotenv::Error
end

class Dotenv::FormatError
end

class Dotenv::FormatError
end

class Dotenv::MissingKeys
  def initialize(keys); end
end

class Dotenv::MissingKeys
end

class Dotenv::Parser
  def call(); end

  def initialize(string, is_load=T.unsafe(nil)); end
  LINE = ::T.let(nil, ::T.untyped)
end

class Dotenv::Parser
  def self.call(string, is_load=T.unsafe(nil)); end

  def self.substitutions(); end
end

module Dotenv::Substitutions
end

module Dotenv::Substitutions::Command
end

module Dotenv::Substitutions::Command
  def self.call(value, _env, _is_load); end
end

module Dotenv::Substitutions::Variable
end

module Dotenv::Substitutions::Variable
  def self.call(value, env, is_load); end
end

module Dotenv::Substitutions
end

module Dotenv
  def self.ignoring_nonexistent_files(); end

  def self.instrument(name, payload=T.unsafe(nil), &block); end

  def self.instrumenter(); end

  def self.instrumenter=(instrumenter); end

  def self.load(*filenames); end

  def self.load!(*filenames); end

  def self.overload(*filenames); end

  def self.overload!(*filenames); end

  def self.parse(*filenames); end

  def self.require_keys(*keys); end

  def self.with(*filenames); end
end

class ERB
  def def_method(mod, methodname, fname=T.unsafe(nil)); end

  def def_module(methodname=T.unsafe(nil)); end

  def result_with_hash(hash); end
end

class ERB::Compiler::Scanner
  DEFAULT_ETAGS = ::T.let(nil, ::T.untyped)
  DEFAULT_STAGS = ::T.let(nil, ::T.untyped)
end

Emitter = Psych::Stream::Emitter

class Encoding
  def _dump(*_); end
  CESU_8 = ::T.let(nil, ::T.untyped)
end

class Encoding::Converter
  def convert(_); end

  def convpath(); end

  def destination_encoding(); end

  def finish(); end

  def initialize(*_); end

  def insert_output(_); end

  def last_error(); end

  def primitive_convert(*_); end

  def primitive_errinfo(); end

  def putback(*_); end

  def replacement(); end

  def replacement=(replacement); end

  def source_encoding(); end
end

class Encoding::Converter
  def self.asciicompat_encoding(_); end

  def self.search_convpath(*_); end
end

class Encoding::InvalidByteSequenceError
  def destination_encoding(); end

  def destination_encoding_name(); end

  def error_bytes(); end

  def incomplete_input?(); end

  def readagain_bytes(); end

  def source_encoding(); end

  def source_encoding_name(); end
end

class Encoding::UndefinedConversionError
  def destination_encoding(); end

  def destination_encoding_name(); end

  def error_char(); end

  def source_encoding(); end

  def source_encoding_name(); end
end

class Encoding
  def self._load(_); end

  def self.locale_charmap(); end
end

module Enumerable
  def chain(*_); end

  def chunk(); end

  def chunk_while(); end

  def each_entry(*_); end

  def filter_map(); end

  def grep_v(_); end

  def slice_after(*_); end

  def slice_before(*_); end

  def slice_when(); end

  def sum(*_); end

  def tally(); end

  def to_set(klass=T.unsafe(nil), *args, &block); end

  def uniq(); end
end

class Enumerator
  def +(_); end

  def each_with_index(); end
end

class Enumerator::ArithmeticSequence
  def begin(); end

  def each(&blk); end

  def end(); end

  def exclude_end?(); end

  def last(*_); end

  def step(); end
end

class Enumerator::ArithmeticSequence
end

class Enumerator::Chain
end

class Enumerator::Chain
end

class Enumerator::Generator
  def each(*_, &blk); end

  def initialize(*_); end
end

class Enumerator::Lazy
  def chunk(*_); end

  def chunk_while(*_); end

  def eager(); end

  def force(*_); end

  def slice_when(*_); end
end

class Enumerator::Producer
  def each(&blk); end
end

class Enumerator::Producer
end

class Enumerator::Yielder
  def to_proc(); end
end

class Enumerator
  def self.produce(*_); end
end

class Errno::EAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EAUTH
end

class Errno::EBADARCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADARCH
end

class Errno::EBADEXEC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADEXEC
end

class Errno::EBADMACHO
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADMACHO
end

class Errno::EBADRPC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADRPC
end

Errno::ECAPMODE = Errno::NOERROR

Errno::EDEADLOCK = Errno::NOERROR

class Errno::EDEVERR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EDEVERR
end

Errno::EDOOFUS = Errno::NOERROR

class Errno::EFTYPE
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EFTYPE
end

Errno::EIPSEC = Errno::NOERROR

class Errno::ELAST
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ELAST
end

class Errno::ENEEDAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENEEDAUTH
end

class Errno::ENOATTR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOATTR
end

class Errno::ENOPOLICY
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOPOLICY
end

Errno::ENOTCAPABLE = Errno::NOERROR

class Errno::ENOTSUP
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOTSUP
end

class Errno::EPROCLIM
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCLIM
end

class Errno::EPROCUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCUNAVAIL
end

class Errno::EPROGMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGMISMATCH
end

class Errno::EPROGUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGUNAVAIL
end

class Errno::EPWROFF
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPWROFF
end

Errno::EQFULL = Errno::ELAST

class Errno::ERPCMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ERPCMISMATCH
end

class Errno::ESHLIBVERS
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ESHLIBVERS
end

module Etc
  VERSION = ::T.let(nil, ::T.untyped)
end

class Etc::Group
  def gid(); end

  def gid=(_); end

  def mem(); end

  def mem=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end
end

class Etc::Group
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Etc::Passwd
  def change(); end

  def change=(_); end

  def dir=(_); end

  def expire(); end

  def expire=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid=(_); end

  def name=(_); end

  def passwd=(_); end

  def shell=(_); end

  def uclass(); end

  def uclass=(_); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Exception
  def full_message(*_); end
end

class Exception
  def self.exception(*_); end

  def self.to_tty?(); end
end

class ExitCalledError
end

class ExitCalledError
end

class FalseClass
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass
end

class Fiber
  def initialize(*_); end

  def resume(*_); end
end

class Fiber
  def self.yield(*_); end
end

class File
  Separator = ::T.let(nil, ::T.untyped)
end

class File::Stat
  def size?(); end
end

class File
  def self.absolute_path?(_); end

  def self.empty?(_); end

  def self.exists?(_); end

  def self.lutime(*_); end

  def self.mkfifo(*_); end
end

module FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::DryRun
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::DryRun
  extend ::FileUtils::DryRun
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  extend ::FileUtils::NoWrite
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::FileUtils::StreamUtils_
end

module Find
end

module Find
  def self.find(*paths, ignore_error: T.unsafe(nil)); end

  def self.prune(); end
end

class Float
  include ::JSON::Ext::Generator::GeneratorMethods::Float
end

module Forwardable
  def def_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_delegators(accessor, *methods); end

  def def_instance_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_instance_delegators(accessor, *methods); end

  def delegate(hash); end

  def instance_delegate(hash); end
  VERSION = ::T.let(nil, ::T.untyped)
end

module Forwardable
  def self._compile_method(src, file, line); end

  def self._delegator_method(obj, accessor, method, ali); end

  def self._valid_method?(method); end

  def self.debug(); end

  def self.debug=(debug); end
end

class FrozenError
  def receiver(); end
end

module GC
  def garbage_collect(full_mark: T.unsafe(nil), immediate_mark: T.unsafe(nil), immediate_sweep: T.unsafe(nil)); end
end

module GC
  def self.compact(); end

  def self.latest_gc_info(hash_or_key=T.unsafe(nil)); end

  def self.stress=(flag); end

  def self.verify_compaction_references(*_); end

  def self.verify_internal_consistency(); end

  def self.verify_transient_heap_internal_consistency(); end
end

module Gem
  UNTAINT = ::T.let(nil, ::T.untyped)
end

class Gem::BasicSpecification
  def self._deprecated_default_specifications_dir(); end
end

class Gem::Command
  def check_deprecated_options(options); end

  def deprecate_option(name, version: T.unsafe(nil), extra_msg: T.unsafe(nil)); end

end

class Gem::Dependency
  def identity(); end
end

class Gem::DependencyInstaller
  def _deprecated_available_set_for(dep_or_name, version); end

  def _deprecated_find_gems_with_sources(dep, best_only=T.unsafe(nil)); end

  def _deprecated_find_spec_by_name_and_version(gem_name, version=T.unsafe(nil), prerelease=T.unsafe(nil)); end
end

class Gem::Installer
  def _deprecated_unpack(directory); end

  def package(); end
end

class Gem::Package
  def gem(); end
end

class Gem::Package::TarHeader
  def self.oct_or_256based(str); end
end

class Gem::Package
  def self.raw_spec(path, security_policy=T.unsafe(nil)); end
end

class Gem::RemoteFetcher
  include ::Gem::UriParsing
  def _deprecated_fetch_size(uri); end

  def s3_uri_signer(uri); end
end

class Gem::RemoteFetcher::FetchError
  include ::Gem::UriParsing
  def initialize(message, uri); end

  def uri(); end

  def uri=(uri); end
end

class Gem::RemoteFetcher::FetchError
end

class Gem::RemoteFetcher::UnknownHostError
end

class Gem::RemoteFetcher::UnknownHostError
end

class Gem::RemoteFetcher
  extend ::Gem::Deprecate
end

class Gem::Requirement
  DefaultPrereleaseRequirement = ::T.let(nil, ::T.untyped)
end

class Gem::Requirement
  def self.default_prerelease(); end
end

class Gem::Resolver::ActivationRequest
  def platform(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Gem::S3URISigner
  def initialize(uri); end

  def sign(expiration=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end
  BASE64_URI_TRANSLATE = ::T.let(nil, ::T.untyped)
  EC2_IAM_INFO = ::T.let(nil, ::T.untyped)
  EC2_IAM_SECURITY_CREDENTIALS = ::T.let(nil, ::T.untyped)
end

class Gem::S3URISigner::ConfigurationError
  def initialize(message); end
end

class Gem::S3URISigner::ConfigurationError
end

class Gem::S3URISigner::InstanceProfileError
  def initialize(message); end
end

class Gem::S3URISigner::InstanceProfileError
end

class Gem::S3URISigner::S3Config
  def access_key_id(); end

  def access_key_id=(_); end

  def region(); end

  def region=(_); end

  def secret_access_key(); end

  def secret_access_key=(_); end

  def security_token(); end

  def security_token=(_); end
end

class Gem::S3URISigner::S3Config
  def self.[](*_); end

  def self.members(); end
end

class Gem::S3URISigner
end

class Gem::Source
  include ::Gem::Text
  def typo_squatting?(host, distance_threshold=T.unsafe(nil)); end
end

class Gem::Specification
  def _deprecated_rubyforge_project=(_deprecated_rubyforge_project); end
  LOAD_CACHE_MUTEX = ::T.let(nil, ::T.untyped)
end

class Gem::Specification
  extend ::Enumerable
  def self.default_stubs(pattern=T.unsafe(nil)); end
end

class Gem::SpecificationPolicy
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
end

class Gem::UriParser
  def parse(uri); end

  def parse!(uri); end
end

class Gem::UriParser
end

module Gem::UriParsing
end

module Gem::UriParsing
end

module Gem::Util
  def self.correct_for_windows_path(path); end
end

module Gem
  def self.add_to_load_path(*paths); end

  def self.default_specifications_dir(); end

  def self.java_platform?(); end

  def self.source_date_epoch(); end

  def self.suffix_regexp(); end
end

class Hash
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
  def <(_); end

  def <=(_); end

  def >(_); end

  def >=(_); end

  def compact(); end

  def compact!(); end

  def deconstruct_keys(_); end

  def default_proc(); end

  def default_proc=(default_proc); end

  def fetch_values(*_); end

  def flatten(*_); end

  def index(_); end

  def replace(_); end

  def slice(*_); end

  def to_h(); end

  def to_proc(); end

  def transform_keys(); end

  def transform_keys!(); end

  def transform_values(); end

  def transform_values!(); end

  def update(*_); end
end

class Hash
  def self.try_convert(_); end
end

class IO
  def beep(); end

  def check_winsize_changed(); end

  def clear_screen(); end

  def console_mode(); end

  def console_mode=(console_mode); end

  def cooked(); end

  def cooked!(); end

  def cursor(); end

  def cursor=(cursor); end

  def cursor_down(_); end

  def cursor_left(_); end

  def cursor_right(_); end

  def cursor_up(_); end

  def echo=(echo); end

  def echo?(); end

  def erase_line(_); end

  def erase_screen(_); end

  def external_encoding(); end

  def getch(*_); end

  def getpass(*_); end

  def goto(_, _1); end

  def goto_column(_); end

  def iflush(); end

  def ioflush(); end

  def noecho(); end

  def nonblock(*_); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def oflush(); end

  def pathconf(_); end

  def pread(*_); end

  def pressed?(); end

  def pwrite(_, _1); end

  def raw(*_); end

  def raw!(*_); end

  def ready?(); end

  def scroll_backward(_); end

  def scroll_forward(_); end

  def set_encoding_by_bom(); end

  def wait(*_); end

  def wait_readable(*_); end

  def wait_writable(*_); end

  def winsize(); end

  def winsize=(winsize); end

  def write_nonblock(buf, exception: T.unsafe(nil)); end
end

class IO::ConsoleMode
  def echo=(echo); end

  def raw(*_); end

  def raw!(*_); end
end

class IO::ConsoleMode
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

class IO
  def self.console(*_); end

  def self.foreach(*_); end
end

class IPAddr
  include ::Comparable
  def &(other); end

  def <<(num); end

  def ==(other); end

  def ===(other); end

  def >>(num); end

  def eql?(other); end

  def family(); end

  def hton(); end

  def include?(other); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end

  def ip6_arpa(); end

  def ip6_int(); end

  def ipv4?(); end

  def ipv4_compat(); end

  def ipv4_compat?(); end

  def ipv4_mapped(); end

  def ipv4_mapped?(); end

  def ipv6?(); end

  def link_local?(); end

  def loopback?(); end

  def mask(prefixlen); end

  def mask!(mask); end

  def native(); end

  def prefix(); end

  def prefix=(prefix); end

  def private?(); end

  def reverse(); end

  def set(addr, *family); end

  def succ(); end

  def to_i(); end

  def to_range(); end

  def to_string(); end

  def |(other); end

  def ~(); end
  IN4MASK = ::T.let(nil, ::T.untyped)
  IN6FORMAT = ::T.let(nil, ::T.untyped)
  IN6MASK = ::T.let(nil, ::T.untyped)
  RE_IPV4ADDRLIKE = ::T.let(nil, ::T.untyped)
  RE_IPV6ADDRLIKE_COMPRESSED = ::T.let(nil, ::T.untyped)
  RE_IPV6ADDRLIKE_FULL = ::T.let(nil, ::T.untyped)
end

class IPAddr::AddressFamilyError
end

class IPAddr::AddressFamilyError
end

class IPAddr::Error
end

class IPAddr::Error
end

class IPAddr::InvalidAddressError
end

class IPAddr::InvalidAddressError
end

class IPAddr::InvalidPrefixError
end

class IPAddr::InvalidPrefixError
end

class IPAddr
  def self.new_ntoh(addr); end

  def self.ntop(addr); end
end

class Integer
  include ::JSON::Ext::Generator::GeneratorMethods::Integer
  def allbits?(_); end

  def anybits?(_); end

  def digits(*_); end

  def nobits?(_); end

  def pow(*_); end

  def to_bn(); end
  GMP_VERSION = ::T.let(nil, ::T.untyped)
end

class Integer
  def self.sqrt(_); end
end

class JSON::Ext::Generator::State
  def self.from_state(_); end
end

class JSON::Ext::Parser
  def initialize(*_); end
end

JSON::Parser = JSON::Ext::Parser

JSON::State = JSON::Ext::Generator::State

JSON::UnparserError = JSON::GeneratorError

JSONTree = Psych::Visitors::JSONTree

module JaroWinkler
  VERSION = ::T.let(nil, ::T.untyped)
end

class JaroWinkler::Error
end

class JaroWinkler::Error
end

class JaroWinkler::InvalidWeightError
end

class JaroWinkler::InvalidWeightError
end

module JaroWinkler
  def self.distance(*_); end

  def self.jaro_distance(*_); end
end

module Kernel
  def gem(dep, *reqs); end

  def itself(); end

  def object_id(); end

  def respond_to?(*_); end

  def then(); end

  def yield_self(); end
end

module Kernel
  def self.at_exit(); end
end

class KeyError
  include ::DidYouMean::Correctable
  def key(); end

  def receiver(); end
end

class LoadError
  def path(); end
end

class LocalJumpError
  def exit_value(); end

  def reason(); end
end

module Marshal
  def self.restore(*_); end
end

Methods = T::Private::Methods

class Module
  def const_source_location(*_); end

  def deprecate_constant(*_); end

  def undef_method(*_); end
end

class Module
  def self.used_modules(); end
end

class Monitor
  def enter(); end

  def exit(); end

  def mon_check_owner(); end

  def mon_enter(); end

  def mon_exit(); end

  def mon_locked?(); end

  def mon_owned?(); end

  def mon_synchronize(); end

  def mon_try_enter(); end

  def new_cond(); end

  def synchronize(); end

  def try_enter(); end

  def try_mon_enter(); end

  def wait_for_cond(_, _1); end
end

module MonitorMixin
  def initialize(*args); end

  def mon_enter(); end

  def mon_exit(); end

  def mon_locked?(); end

  def mon_owned?(); end

  def mon_synchronize(&b); end

  def mon_try_enter(); end

  def new_cond(); end

  def synchronize(&b); end

  def try_mon_enter(); end
end

class MonitorMixin::ConditionVariable
  def broadcast(); end

  def initialize(monitor); end

  def signal(); end

  def wait(timeout=T.unsafe(nil)); end

  def wait_until(); end

  def wait_while(); end
end

module MonitorMixin
  def self.extend_object(obj); end
end

module Mustermann
  DEFAULT_TYPE = ::T.let(nil, ::T.untyped)
end

module Mustermann::AST
end

class Mustermann::AST::Boundaries
  def set_boundaries(node, start, stop); end
end

class Mustermann::AST::Boundaries::NodeTranslator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Mustermann::AST::Boundaries::NodeTranslator
  def self.translator(); end
end

class Mustermann::AST::Boundaries
  def self.set_boundaries(ast, string: T.unsafe(nil), start: T.unsafe(nil), stop: T.unsafe(nil)); end
end

class Mustermann::AST::Expander
  def add(ast); end

  def add_to(list, result); end

  def error_for(values); end

  def escape(string, *args); end

  def expand(values); end

  def expandable?(values); end

  def expandable_keys(keys); end

  def for_capture(node, **options); end

  def keys(); end

  def mappings(); end

  def pattern(string=T.unsafe(nil), *keys, **filters); end

  def pattern_for(node, **options); end
end

class Mustermann::AST::Expander::NodeTranslator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Mustermann::AST::Expander::NodeTranslator
  def self.translator(); end
end

class Mustermann::AST::Expander
end

class Mustermann::AST::Node
  def each_leaf(&block); end

  def initialize(payload=T.unsafe(nil), **options); end

  def is_a?(type); end

  def length(); end

  def min_size(); end

  def parse(); end

  def payload(); end

  def payload=(payload); end

  def start(); end

  def start=(start); end

  def stop(); end

  def stop=(stop); end

  def type(); end
end

class Mustermann::AST::Node::Capture
  def constraint(); end

  def constraint=(constraint); end

  def convert(); end

  def convert=(convert); end

  def name(); end

  def qualifier(); end

  def qualifier=(qualifier); end
end

class Mustermann::AST::Node::Capture
end

class Mustermann::AST::Node::Char
end

class Mustermann::AST::Node::Char
end

class Mustermann::AST::Node::Composition
end

class Mustermann::AST::Node::Composition
end

class Mustermann::AST::Node::Expression
  def operator(); end

  def operator=(operator); end
end

class Mustermann::AST::Node::Expression
end

class Mustermann::AST::Node::Group
end

class Mustermann::AST::Node::Group
end

class Mustermann::AST::Node::NamedSplat
end

class Mustermann::AST::Node::NamedSplat
end

class Mustermann::AST::Node::Optional
end

class Mustermann::AST::Node::Optional
end

class Mustermann::AST::Node::Or
end

class Mustermann::AST::Node::Or
end

class Mustermann::AST::Node::Root
  def pattern(); end

  def pattern=(pattern); end
end

class Mustermann::AST::Node::Root
  def self.parse(string, &block); end
end

class Mustermann::AST::Node::Separator
end

class Mustermann::AST::Node::Separator
end

class Mustermann::AST::Node::Splat
end

class Mustermann::AST::Node::Splat
end

class Mustermann::AST::Node::Union
end

class Mustermann::AST::Node::Union
end

class Mustermann::AST::Node::Variable
  def explode(); end

  def explode=(explode); end

  def prefix(); end

  def prefix=(prefix); end
end

class Mustermann::AST::Node::Variable
end

class Mustermann::AST::Node::WithLookAhead
  def at_end(); end

  def at_end=(at_end); end

  def head(); end

  def head=(head); end

  def initialize(payload, at_end, **options); end
end

class Mustermann::AST::Node::WithLookAhead
end

class Mustermann::AST::Node
  def self.[](name); end

  def self.constant_name(name); end

  def self.parse(*args, &block); end

  def self.type(); end
end

class Mustermann::AST::ParamScanner
end

class Mustermann::AST::ParamScanner::NodeTranslator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Mustermann::AST::ParamScanner::NodeTranslator
  def self.translator(); end
end

class Mustermann::AST::ParamScanner
  def self.scan_params(ast); end
end

class Mustermann::AST::Parser
  def buffer(); end

  def default_node(char); end

  def eos?(*args, &block); end

  def expect(regexp, char: T.unsafe(nil), **options); end

  def getch(*args, &block); end

  def initialize(pattern: T.unsafe(nil), **options); end

  def min_size(start, stop, node); end

  def node(type, *args, &block); end

  def parse(string); end

  def pattern(); end

  def pos(*args, &block); end

  def read(); end

  def read_args(key_separator, close, separator: T.unsafe(nil), symbol_keys: T.unsafe(nil), **options); end

  def read_brackets(open, close, char: T.unsafe(nil), escape: T.unsafe(nil), quote: T.unsafe(nil), **options); end

  def read_escaped(close, escape: T.unsafe(nil), **options); end

  def read_list(*close, separator: T.unsafe(nil), escape: T.unsafe(nil), quotes: T.unsafe(nil), ignore: T.unsafe(nil), **options); end

  def read_suffix(element); end

  def scan(regexp); end

  def string(); end

  def unexpected(char=T.unsafe(nil), exception: T.unsafe(nil)); end
end

class Mustermann::AST::Parser
  extend ::Forwardable
  def self.on(*chars, &block); end

  def self.parse(string, **options); end

  def self.suffix(pattern=T.unsafe(nil), after: T.unsafe(nil), &block); end
end

class Mustermann::AST::Pattern
  def boundaries(*args, &block); end

  def compiler(*args, &block); end

  def param_scanner(*args, &block); end

  def parser(*args, &block); end

  def template_generator(*args, &block); end

  def to_ast(); end

  def transformer(*args, &block); end

  def validation(*args, &block); end
end

class Mustermann::AST::Pattern
  extend ::SingleForwardable
  def self.boundaries(); end

  def self.compiler(); end

  def self.on(*args, &block); end

  def self.param_scanner(); end

  def self.parser(); end

  def self.suffix(*args, &block); end

  def self.template_generator(); end

  def self.transformer(); end

  def self.validation(); end
end

class Mustermann::AST::TemplateGenerator
end

class Mustermann::AST::TemplateGenerator::NodeTranslator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Mustermann::AST::TemplateGenerator::NodeTranslator
  def self.translator(); end
end

class Mustermann::AST::TemplateGenerator
  def self.generate_templates(ast); end
end

class Mustermann::AST::Transformer
end

class Mustermann::AST::Transformer::ArrayTransform
  def create_lookahead(elements, *args); end

  def expect_lookahead?(element); end

  def list_for(element); end

  def lookahead?(element, in_lookahead=T.unsafe(nil)); end

  def lookahead_buffer(); end

  def lookahead_payload?(payload, in_lookahead); end

  def payload(); end

  def track(element); end

  def translate(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Mustermann::AST::Transformer::ArrayTransform
end

class Mustermann::AST::Transformer::ExpressionTransform
  def translate(); end
  OPERATORS = ::T.let(nil, ::T.untyped)
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Mustermann::AST::Transformer::ExpressionTransform::Operator
  def allow_reserved(); end

  def allow_reserved=(_); end

  def parametric(); end

  def parametric=(_); end

  def prefix(); end

  def prefix=(_); end

  def separator(); end

  def separator=(_); end
end

class Mustermann::AST::Transformer::ExpressionTransform::Operator
  def self.[](*_); end

  def self.members(); end
end

class Mustermann::AST::Transformer::ExpressionTransform
end

class Mustermann::AST::Transformer::GroupTransformer
  def group(elements); end

  def split_payload(); end

  def translate(); end

  def union(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Mustermann::AST::Transformer::GroupTransformer
end

class Mustermann::AST::Transformer::NodeTranslator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Mustermann::AST::Transformer::NodeTranslator
  def self.translator(); end
end

class Mustermann::AST::Transformer::RootTransformer
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Mustermann::AST::Transformer::RootTransformer
end

class Mustermann::AST::Transformer
  def self.transform(tree); end
end

class Mustermann::AST::Translator
  def decorator_for(node); end

  def error_class(); end

  def escape(char, parser: T.unsafe(nil), escape: T.unsafe(nil), also_escape: T.unsafe(nil)); end

  def translate(node, *args, &block); end
end

class Mustermann::AST::Translator::NodeTranslator
  def initialize(node, translator); end

  def node(); end

  def t(*args, &block); end

  def translator(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Mustermann::AST::Translator::NodeTranslator
  def self.register(*types); end
end

class Mustermann::AST::Translator
  def self.create(&block); end

  def self.dispatch_table(); end

  def self.inherited(subclass); end

  def self.raises(error); end

  def self.translate(*types, &block); end
end

class Mustermann::AST::Validation
  def check_name(name, forbidden: T.unsafe(nil)); end

  def names(); end
end

class Mustermann::AST::Validation::NodeTranslator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Mustermann::AST::Validation::NodeTranslator
  def self.translator(); end
end

class Mustermann::AST::Validation
  def self.validate(ast); end
end

module Mustermann::AST
end

class Mustermann::Caster
  def cast(hash); end

  def caster_for(type, &block); end

  def initialize(*types, &block); end

  def register(*types, &block); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Mustermann::Caster::Any
  def cast(key, value); end

  def initialize(&block); end
end

class Mustermann::Caster::Any
end

class Mustermann::Caster::Key
  def initialize(type, &block); end
end

class Mustermann::Caster::Key
end

class Mustermann::Caster::Value
  def initialize(type, &block); end
end

class Mustermann::Caster::Value
end

class Mustermann::Caster
end

class Mustermann::CompileError
end

class Mustermann::CompileError
end

class Mustermann::Composite
  def ==(pattern); end

  def eql?(pattern); end

  def initialize(patterns, operator: T.unsafe(nil), **options); end

  def operator(); end

  def params(string); end

  def patterns(); end
end

class Mustermann::Composite
  def self.new(*patterns, **options); end

  def self.supported?(option, type: T.unsafe(nil), **options); end
end

class Mustermann::Concat
  def initialize(*_, **_1); end
end

module Mustermann::Concat::Native
  def +(other); end

  def look_ahead(other); end
end

module Mustermann::Concat::Native
end

class Mustermann::Concat
end

class Mustermann::EqualityMap
  def fetch(key); end

  def map(); end
end

class Mustermann::EqualityMap
  def self.new(); end
end

class Mustermann::Error
end

class Mustermann::Error
end

class Mustermann::ExpandError
end

class Mustermann::ExpandError
end

class Mustermann::Expander
  def <<(*patterns); end

  def ==(other); end

  def add(*patterns); end

  def additional_values(); end

  def cast(*types, &block); end

  def eql?(other); end

  def expand(behavior=T.unsafe(nil), values=T.unsafe(nil)); end

  def expandable?(values); end

  def initialize(*patterns, additional_values: T.unsafe(nil), **options, &block); end

  def patterns(); end
end

class Mustermann::Expander
end

class Mustermann::Identity
  include ::Mustermann::Concat::Native
  def to_ast(); end
end

class Mustermann::Identity
end

class Mustermann::ParseError
end

class Mustermann::ParseError
end

class Mustermann::Pattern
  include ::Mustermann
  def &(other); end

  def +(other); end

  def ==(other); end

  def ===(string); end

  def =~(string); end

  def ^(other); end

  def always_array?(key); end

  def eql?(other); end

  def expand(behavior=T.unsafe(nil), values=T.unsafe(nil)); end

  def initialize(string, uri_decode: T.unsafe(nil), **options); end

  def match(string); end

  def named_captures(); end

  def names(); end

  def options(); end

  def params(string=T.unsafe(nil), captures: T.unsafe(nil), offset: T.unsafe(nil)); end

  def peek(string); end

  def peek_match(string); end

  def peek_params(string); end

  def peek_size(string); end

  def respond_to?(method, *args); end

  def simple_inspect(); end

  def to_proc(); end

  def to_templates(); end

  def uri_decode(); end

  def |(other); end
end

class Mustermann::Pattern
  def self.new(string, ignore_unknown_options: T.unsafe(nil), **options); end

  def self.register(*names); end

  def self.supported?(option, **options); end

  def self.supported_options(*list); end
end

class Mustermann::RegexpBased
  def ===(*args, &block); end

  def =~(*args, &block); end

  def initialize(string, **options); end

  def match(*args, &block); end

  def named_captures(*args, &block); end

  def names(*args, &block); end

  def regexp(); end

  def to_regexp(); end
end

class Mustermann::RegexpBased
  extend ::Forwardable
end

class Mustermann::Regular
  include ::Mustermann::Concat::Native
  def initialize(string, check_anchors: T.unsafe(nil), **options); end
end

class Mustermann::Regular
end

class Mustermann::SimpleMatch
  def +(other); end

  def [](*args); end

  def captures(); end

  def initialize(string=T.unsafe(nil), names: T.unsafe(nil), captures: T.unsafe(nil)); end

  def names(); end
end

class Mustermann::SimpleMatch
end

class Mustermann::Sinatra
  include ::Mustermann::Concat::Native
  def safe_string(); end
end

class Mustermann::Sinatra
  def self.escape(string); end

  def self.try_convert(input, **options); end
end

module Mustermann
  def self.[](name); end

  def self.extend_object(object); end

  def self.new(*input, type: T.unsafe(nil), operator: T.unsafe(nil), **options); end

  def self.normalized_type(type); end

  def self.register(name, type); end

  def self.try_require(path); end
end

class NameError
  include ::DidYouMean::Correctable
  def name(); end

  def receiver(); end
end

class Net::BufferedIO
  def write_timeout(); end

  def write_timeout=(write_timeout); end
end

class Net::HTTP
  def ipaddr(); end

  def ipaddr=(addr); end

  def max_retries(); end

  def max_retries=(retries); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end

  def write_timeout(); end

  def write_timeout=(sec); end
  ENVIRONMENT_VARIABLE_IS_MULTIUSER_SAFE = ::T.let(nil, ::T.untyped)
end

Net::HTTP::ProxyMod = Net::HTTP::ProxyDelta

class Net::HTTPAlreadyReported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
end

class Net::HTTPClientError
end

Net::HTTPClientErrorCode::EXCEPTION_TYPE = Net::HTTPServerException

class Net::HTTPClientError
end

Net::HTTPClientException = Net::HTTPServerException

class Net::HTTPEarlyHints
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPEarlyHints
end

Net::HTTPFatalErrorCode = Net::HTTPClientError

class Net::HTTPGatewayTimeout
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPGatewayTimeout
end

Net::HTTPInformation::EXCEPTION_TYPE = Net::HTTPError

Net::HTTPInformationCode = Net::HTTPInformation

class Net::HTTPLoopDetected
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPLoopDetected
end

class Net::HTTPMisdirectedRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPMisdirectedRequest
end

Net::HTTPMovedTemporarily = Net::HTTPFound

Net::HTTPMultipleChoice = Net::HTTPMultipleChoices

class Net::HTTPNotExtended
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPNotExtended
end

class Net::HTTPPayloadTooLarge
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPPayloadTooLarge
end

class Net::HTTPProcessing
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPProcessing
end

class Net::HTTPRangeNotSatisfiable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRangeNotSatisfiable
end

class Net::HTTPRedirection
end

Net::HTTPRedirectionCode::EXCEPTION_TYPE = Net::HTTPRetriableError

class Net::HTTPRedirection
end

class Net::HTTPRequestTimeout
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRequestTimeout
end

Net::HTTPRequestURITooLarge = Net::HTTPURITooLong

Net::HTTPResponceReceiver = Net::HTTPResponse

Net::HTTPRetriableCode = Net::HTTPRedirection

class Net::HTTPServerError
end

Net::HTTPServerErrorCode::EXCEPTION_TYPE = Net::HTTPFatalError

class Net::HTTPServerError
end

Net::HTTPSession = Net::HTTP

Net::HTTPSuccessCode = Net::HTTPSuccess

class Net::HTTPURITooLong
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPURITooLong
end

Net::HTTPUnknownResponse::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPVariantAlsoNegotiates
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPVariantAlsoNegotiates
end

Net::NetPrivate::HTTPRequest = Net::HTTPRequest

Net::NetPrivate::Socket = Net::InternetMessageIO

Net::ProtocRetryError = Net::ProtoRetriableError

class Net::ReadTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class Net::WriteTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class Net::WriteTimeout
end

class NilClass
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass
  def to_i(); end
end

class NoMatchingPatternError
end

class NoMatchingPatternError
end

class NoMethodError
  def args(); end

  def private_call?(); end
end

module Nokogiri
  LIBXML_ICONV_ENABLED = ::T.let(nil, ::T.untyped)
  LIBXML_PARSER_VERSION = ::T.let(nil, ::T.untyped)
  LIBXML_VERSION = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXML2_PATCHES = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXML2_PATH = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXSLT_PATCHES = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXSLT_PATH = ::T.let(nil, ::T.untyped)
  NOKOGIRI_USE_PACKAGED_LIBRARIES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_INFO = ::T.let(nil, ::T.untyped)
end

module Nokogiri::CSS
end

class Nokogiri::CSS::Node
  def accept(visitor); end

  def find_by_type(types); end

  def initialize(type, value); end

  def to_a(); end

  def to_type(); end

  def to_xpath(prefix=T.unsafe(nil), visitor=T.unsafe(nil)); end

  def type(); end

  def type=(type); end

  def value(); end

  def value=(value); end
  ALLOW_COMBINATOR_ON_SELF = ::T.let(nil, ::T.untyped)
end

class Nokogiri::CSS::Node
end

class Nokogiri::CSS::Parser
  def _reduce_1(val, _values, result); end

  def _reduce_11(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_13(val, _values, result); end

  def _reduce_14(val, _values, result); end

  def _reduce_15(val, _values, result); end

  def _reduce_16(val, _values, result); end

  def _reduce_18(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_21(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_23(val, _values, result); end

  def _reduce_25(val, _values, result); end

  def _reduce_26(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_28(val, _values, result); end

  def _reduce_29(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_30(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_33(val, _values, result); end

  def _reduce_34(val, _values, result); end

  def _reduce_35(val, _values, result); end

  def _reduce_36(val, _values, result); end

  def _reduce_37(val, _values, result); end

  def _reduce_4(val, _values, result); end

  def _reduce_40(val, _values, result); end

  def _reduce_41(val, _values, result); end

  def _reduce_42(val, _values, result); end

  def _reduce_43(val, _values, result); end

  def _reduce_44(val, _values, result); end

  def _reduce_45(val, _values, result); end

  def _reduce_48(val, _values, result); end

  def _reduce_49(val, _values, result); end

  def _reduce_5(val, _values, result); end

  def _reduce_50(val, _values, result); end

  def _reduce_51(val, _values, result); end

  def _reduce_52(val, _values, result); end

  def _reduce_58(val, _values, result); end

  def _reduce_59(val, _values, result); end

  def _reduce_6(val, _values, result); end

  def _reduce_60(val, _values, result); end

  def _reduce_61(val, _values, result); end

  def _reduce_63(val, _values, result); end

  def _reduce_64(val, _values, result); end

  def _reduce_65(val, _values, result); end

  def _reduce_66(val, _values, result); end

  def _reduce_67(val, _values, result); end

  def _reduce_68(val, _values, result); end

  def _reduce_69(val, _values, result); end

  def _reduce_7(val, _values, result); end

  def _reduce_70(val, _values, result); end

  def _reduce_8(val, _values, result); end

  def _reduce_9(val, _values, result); end

  def _reduce_none(val, _values, result); end

  def initialize(namespaces=T.unsafe(nil)); end

  def on_error(error_token_id, error_value, value_stack); end

  def parse(string); end

  def unescape_css_identifier(identifier); end

  def unescape_css_string(str); end

  def xpath_for(string, options=T.unsafe(nil)); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Nokogiri::CSS::Parser
  def self.[](string); end

  def self.[]=(string, value); end

  def self.cache_on(); end

  def self.cache_on=(cache_on); end

  def self.cache_on?(); end

  def self.clear_cache(); end

  def self.parse(selector); end

  def self.set_cache(_); end

  def self.without_cache(&block); end
end

class Nokogiri::CSS::SyntaxError
end

class Nokogiri::CSS::SyntaxError
end

class Nokogiri::CSS::Tokenizer
  def _next_token(); end

  def action(); end

  def filename(); end

  def lineno(); end

  def load_file(filename); end

  def next_token(); end

  def scan(str); end

  def scan_file(filename); end

  def scan_setup(str); end

  def scan_str(str); end

  def state(); end

  def state=(state); end
end

class Nokogiri::CSS::Tokenizer::ScanError
end

class Nokogiri::CSS::Tokenizer::ScanError
end

class Nokogiri::CSS::Tokenizer
end

class Nokogiri::CSS::XPathVisitor
  def accept(node); end

  def visit_attribute_condition(node); end

  def visit_child_selector(node); end

  def visit_class_condition(node); end

  def visit_combinator(node); end

  def visit_conditional_selector(node); end

  def visit_descendant_selector(node); end

  def visit_direct_adjacent_selector(node); end

  def visit_element_name(node); end

  def visit_following_selector(node); end

  def visit_function(node); end

  def visit_id(node); end

  def visit_not(node); end

  def visit_pseudo_class(node); end
end

class Nokogiri::CSS::XPathVisitor
end

module Nokogiri::CSS
  def self.parse(selector); end

  def self.xpath_for(selector, options=T.unsafe(nil)); end
end

module Nokogiri::Decorators
end

module Nokogiri::Decorators::Slop
  def method_missing(name, *args, &block); end
  XPATH_PREFIX = ::T.let(nil, ::T.untyped)
end

module Nokogiri::Decorators::Slop
end

module Nokogiri::Decorators
end

class Nokogiri::EncodingHandler
  def name(); end
end

class Nokogiri::EncodingHandler
  def self.[](_); end

  def self.alias(_, _1); end

  def self.clear_aliases!(); end

  def self.delete(_); end
end

module Nokogiri::HTML
  NamedCharacters = ::T.let(nil, ::T.untyped)
end

class Nokogiri::HTML::Builder
  def to_html(); end
end

class Nokogiri::HTML::Builder
end

class Nokogiri::HTML::Document
  def meta_encoding(); end

  def meta_encoding=(encoding); end

  def serialize(options=T.unsafe(nil)); end

  def title(); end

  def title=(text); end
end

class Nokogiri::HTML::Document::EncodingFound
  def found_encoding(); end

  def initialize(encoding); end
end

class Nokogiri::HTML::Document::EncodingFound
end

class Nokogiri::HTML::Document::EncodingReader
  def encoding_found(); end

  def initialize(io); end

  def read(len); end
end

class Nokogiri::HTML::Document::EncodingReader::JumpSAXHandler
  def initialize(jumptag); end
end

class Nokogiri::HTML::Document::EncodingReader::JumpSAXHandler
end

class Nokogiri::HTML::Document::EncodingReader::SAXHandler
  def encoding(); end
end

class Nokogiri::HTML::Document::EncodingReader::SAXHandler
end

class Nokogiri::HTML::Document::EncodingReader
  def self.detect_encoding(chunk); end

  def self.detect_encoding_for_jruby_without_fix(chunk); end

  def self.is_jruby_without_fix?(); end
end

class Nokogiri::HTML::Document
end

class Nokogiri::HTML::DocumentFragment
end

class Nokogiri::HTML::DocumentFragment
  def self.parse(tags, encoding=T.unsafe(nil)); end
end

class Nokogiri::HTML::ElementDescription
  def block?(); end

  def default_sub_element(); end

  def deprecated?(); end

  def deprecated_attributes(); end

  def description(); end

  def empty?(); end

  def implied_end_tag?(); end

  def implied_start_tag?(); end

  def inline?(); end

  def name(); end

  def optional_attributes(); end

  def required_attributes(); end

  def save_end_tag?(); end

  def sub_elements(); end
  ACTION_ATTR = ::T.let(nil, ::T.untyped)
  ALIGN_ATTR = ::T.let(nil, ::T.untyped)
  ALT_ATTR = ::T.let(nil, ::T.untyped)
  APPLET_ATTRS = ::T.let(nil, ::T.untyped)
  AREA_ATTRS = ::T.let(nil, ::T.untyped)
  ATTRS = ::T.let(nil, ::T.untyped)
  A_ATTRS = ::T.let(nil, ::T.untyped)
  BASEFONT_ATTRS = ::T.let(nil, ::T.untyped)
  BGCOLOR_ATTR = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  BLOCKLI_ELT = ::T.let(nil, ::T.untyped)
  BODY_ATTRS = ::T.let(nil, ::T.untyped)
  BODY_CONTENTS = ::T.let(nil, ::T.untyped)
  BODY_DEPR = ::T.let(nil, ::T.untyped)
  BUTTON_ATTRS = ::T.let(nil, ::T.untyped)
  CELLHALIGN = ::T.let(nil, ::T.untyped)
  CELLVALIGN = ::T.let(nil, ::T.untyped)
  CLEAR_ATTRS = ::T.let(nil, ::T.untyped)
  COL_ATTRS = ::T.let(nil, ::T.untyped)
  COL_ELT = ::T.let(nil, ::T.untyped)
  COMPACT_ATTR = ::T.let(nil, ::T.untyped)
  COMPACT_ATTRS = ::T.let(nil, ::T.untyped)
  CONTENT_ATTR = ::T.let(nil, ::T.untyped)
  COREATTRS = ::T.let(nil, ::T.untyped)
  CORE_ATTRS = ::T.let(nil, ::T.untyped)
  CORE_I18N_ATTRS = ::T.let(nil, ::T.untyped)
  DIR_ATTR = ::T.let(nil, ::T.untyped)
  DL_CONTENTS = ::T.let(nil, ::T.untyped)
  DefaultDescriptions = ::T.let(nil, ::T.untyped)
  EDIT_ATTRS = ::T.let(nil, ::T.untyped)
  EMBED_ATTRS = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  EVENTS = ::T.let(nil, ::T.untyped)
  FIELDSET_CONTENTS = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
  FLOW_PARAM = ::T.let(nil, ::T.untyped)
  FONTSTYLE = ::T.let(nil, ::T.untyped)
  FONT_ATTRS = ::T.let(nil, ::T.untyped)
  FORMCTRL = ::T.let(nil, ::T.untyped)
  FORM_ATTRS = ::T.let(nil, ::T.untyped)
  FORM_CONTENTS = ::T.let(nil, ::T.untyped)
  FRAMESET_ATTRS = ::T.let(nil, ::T.untyped)
  FRAMESET_CONTENTS = ::T.let(nil, ::T.untyped)
  FRAME_ATTRS = ::T.let(nil, ::T.untyped)
  HEADING = ::T.let(nil, ::T.untyped)
  HEAD_ATTRS = ::T.let(nil, ::T.untyped)
  HEAD_CONTENTS = ::T.let(nil, ::T.untyped)
  HREF_ATTRS = ::T.let(nil, ::T.untyped)
  HR_DEPR = ::T.let(nil, ::T.untyped)
  HTML_ATTRS = ::T.let(nil, ::T.untyped)
  HTML_CDATA = ::T.let(nil, ::T.untyped)
  HTML_CONTENT = ::T.let(nil, ::T.untyped)
  HTML_FLOW = ::T.let(nil, ::T.untyped)
  HTML_INLINE = ::T.let(nil, ::T.untyped)
  HTML_PCDATA = ::T.let(nil, ::T.untyped)
  I18N = ::T.let(nil, ::T.untyped)
  I18N_ATTRS = ::T.let(nil, ::T.untyped)
  IFRAME_ATTRS = ::T.let(nil, ::T.untyped)
  IMG_ATTRS = ::T.let(nil, ::T.untyped)
  INLINE = ::T.let(nil, ::T.untyped)
  INLINE_P = ::T.let(nil, ::T.untyped)
  INPUT_ATTRS = ::T.let(nil, ::T.untyped)
  LABEL_ATTR = ::T.let(nil, ::T.untyped)
  LABEL_ATTRS = ::T.let(nil, ::T.untyped)
  LANGUAGE_ATTR = ::T.let(nil, ::T.untyped)
  LEGEND_ATTRS = ::T.let(nil, ::T.untyped)
  LINK_ATTRS = ::T.let(nil, ::T.untyped)
  LIST = ::T.let(nil, ::T.untyped)
  LI_ELT = ::T.let(nil, ::T.untyped)
  MAP_CONTENTS = ::T.let(nil, ::T.untyped)
  META_ATTRS = ::T.let(nil, ::T.untyped)
  MODIFIER = ::T.let(nil, ::T.untyped)
  NAME_ATTR = ::T.let(nil, ::T.untyped)
  NOFRAMES_CONTENT = ::T.let(nil, ::T.untyped)
  OBJECT_ATTRS = ::T.let(nil, ::T.untyped)
  OBJECT_CONTENTS = ::T.let(nil, ::T.untyped)
  OBJECT_DEPR = ::T.let(nil, ::T.untyped)
  OL_ATTRS = ::T.let(nil, ::T.untyped)
  OPTGROUP_ATTRS = ::T.let(nil, ::T.untyped)
  OPTION_ATTRS = ::T.let(nil, ::T.untyped)
  OPTION_ELT = ::T.let(nil, ::T.untyped)
  PARAM_ATTRS = ::T.let(nil, ::T.untyped)
  PCDATA = ::T.let(nil, ::T.untyped)
  PHRASE = ::T.let(nil, ::T.untyped)
  PRE_CONTENT = ::T.let(nil, ::T.untyped)
  PROMPT_ATTRS = ::T.let(nil, ::T.untyped)
  QUOTE_ATTRS = ::T.let(nil, ::T.untyped)
  ROWS_COLS_ATTR = ::T.let(nil, ::T.untyped)
  SCRIPT_ATTRS = ::T.let(nil, ::T.untyped)
  SELECT_ATTRS = ::T.let(nil, ::T.untyped)
  SELECT_CONTENT = ::T.let(nil, ::T.untyped)
  SPECIAL = ::T.let(nil, ::T.untyped)
  SRC_ALT_ATTRS = ::T.let(nil, ::T.untyped)
  STYLE_ATTRS = ::T.let(nil, ::T.untyped)
  TABLE_ATTRS = ::T.let(nil, ::T.untyped)
  TABLE_CONTENTS = ::T.let(nil, ::T.untyped)
  TABLE_DEPR = ::T.let(nil, ::T.untyped)
  TALIGN_ATTRS = ::T.let(nil, ::T.untyped)
  TARGET_ATTR = ::T.let(nil, ::T.untyped)
  TEXTAREA_ATTRS = ::T.let(nil, ::T.untyped)
  TH_TD_ATTR = ::T.let(nil, ::T.untyped)
  TH_TD_DEPR = ::T.let(nil, ::T.untyped)
  TR_CONTENTS = ::T.let(nil, ::T.untyped)
  TR_ELT = ::T.let(nil, ::T.untyped)
  TYPE_ATTR = ::T.let(nil, ::T.untyped)
  UL_DEPR = ::T.let(nil, ::T.untyped)
  VERSION_ATTR = ::T.let(nil, ::T.untyped)
  WIDTH_ATTR = ::T.let(nil, ::T.untyped)
end

Nokogiri::HTML::ElementDescription::Desc = Struct::HTMLElementDescription

class Nokogiri::HTML::ElementDescription
  def self.[](_); end
end

class Nokogiri::HTML::EntityDescription
end

class Nokogiri::HTML::EntityDescription
end

class Nokogiri::HTML::EntityLookup
  def [](name); end

  def get(_); end
end

class Nokogiri::HTML::EntityLookup
end

module Nokogiri::HTML::SAX
end

class Nokogiri::HTML::SAX::Parser
  def parse_file(filename, encoding=T.unsafe(nil)); end

  def parse_memory(data, encoding=T.unsafe(nil)); end
end

class Nokogiri::HTML::SAX::Parser
end

class Nokogiri::HTML::SAX::ParserContext
end

class Nokogiri::HTML::SAX::ParserContext
  def self.file(_, _1); end

  def self.memory(_, _1); end
end

class Nokogiri::HTML::SAX::PushParser
end

class Nokogiri::HTML::SAX::PushParser
end

module Nokogiri::HTML::SAX
end

module Nokogiri::HTML
  def self.fragment(string, encoding=T.unsafe(nil)); end

  def self.parse(thing, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil), &block); end
end

module Nokogiri::HTML5
  HTML_NAMESPACE = ::T.let(nil, ::T.untyped)
  MATHML_NAMESPACE = ::T.let(nil, ::T.untyped)
  SVG_NAMESPACE = ::T.let(nil, ::T.untyped)
  XLINK_NAMESPACE = ::T.let(nil, ::T.untyped)
  XMLNS_NAMESPACE = ::T.let(nil, ::T.untyped)
  XML_NAMESPACE = ::T.let(nil, ::T.untyped)
end

class Nokogiri::HTML5::Document
  def to_xml(options=T.unsafe(nil), &block); end
end

class Nokogiri::HTML5::Document
  def self.do_parse(string_or_io, url, encoding, options); end

  def self.parse(string_or_io, url=T.unsafe(nil), encoding=T.unsafe(nil), **options, &block); end

  def self.read_io(io, url=T.unsafe(nil), encoding=T.unsafe(nil), **options); end

  def self.read_memory(string, url=T.unsafe(nil), encoding=T.unsafe(nil), **options); end
end

class Nokogiri::HTML5::DocumentFragment
  def document=(document); end

  def errors=(errors); end

  def initialize(doc, tags=T.unsafe(nil), ctx=T.unsafe(nil), options=T.unsafe(nil)); end

  def serialize(options=T.unsafe(nil), &block); end
end

class Nokogiri::HTML5::DocumentFragment
  def self.parse(tags, encoding=T.unsafe(nil), options=T.unsafe(nil)); end
end

module Nokogiri::HTML5::Node
  def add_child_node_and_reparent_attrs(node); end

  def fragment(tags); end

  def inner_html(options=T.unsafe(nil)); end

  def write_to(io, *options); end
end

module Nokogiri::HTML5::Node
end

module Nokogiri::HTML5
  def self.escape_text(text, encoding, attribute_mode); end

  def self.fragment(string, encoding=T.unsafe(nil), **options); end

  def self.get(uri, options=T.unsafe(nil)); end

  def self.parse(string, url=T.unsafe(nil), encoding=T.unsafe(nil), **options, &block); end

  def self.prepend_newline?(node); end

  def self.read_and_encode(string, encoding); end

  def self.reencode(body, content_type=T.unsafe(nil)); end

  def self.serialize_node_internal(current_node, io, encoding, options); end
end

class Nokogiri::SyntaxError
end

class Nokogiri::SyntaxError
end

class Nokogiri::VersionInfo
  def compiled_parser_version(); end

  def engine(); end

  def jruby?(); end

  def libxml2?(); end

  def libxml2_using_packaged?(); end

  def libxml2_using_system?(); end

  def loaded_parser_version(); end

  def to_hash(); end

  def to_markdown(); end

  def warnings(); end
end

class Nokogiri::VersionInfo
  def self.instance(); end
end

module Nokogiri::XML
  XML_C14N_1_0 = ::T.let(nil, ::T.untyped)
  XML_C14N_1_1 = ::T.let(nil, ::T.untyped)
  XML_C14N_EXCLUSIVE_1_0 = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Attr
  def content=(content); end

  def value(); end

  def value=(value); end
end

class Nokogiri::XML::Attr
end

class Nokogiri::XML::AttributeDecl
  def attribute_type(); end

  def default(); end

  def enumeration(); end
end

class Nokogiri::XML::AttributeDecl
end

class Nokogiri::XML::Builder
  def <<(string); end

  def [](ns); end

  def arity(); end

  def arity=(arity); end

  def cdata(string); end

  def comment(string); end

  def context(); end

  def context=(context); end

  def doc(); end

  def doc=(doc); end

  def initialize(options=T.unsafe(nil), root=T.unsafe(nil), &block); end

  def method_missing(method, *args, &block); end

  def parent(); end

  def parent=(parent); end

  def text(string); end

  def to_xml(*args); end
end

class Nokogiri::XML::Builder
  def self.with(root, &block); end
end

class Nokogiri::XML::CDATA
end

class Nokogiri::XML::CDATA
end

class Nokogiri::XML::CharacterData
  include ::Nokogiri::XML::PP::CharacterData
end

class Nokogiri::XML::CharacterData
end

class Nokogiri::XML::Comment
end

class Nokogiri::XML::Comment
end

class Nokogiri::XML::DTD
  def entities(); end

  def external_id(); end

  def html5_dtd?(); end

  def html_dtd?(); end

  def notations(); end

  def system_id(); end

  def validate(_); end
end

class Nokogiri::XML::DTD
end

class Nokogiri::XML::Document
  def canonicalize(*_); end

  def collect_namespaces(); end

  def create_cdata(string, &block); end

  def create_comment(string, &block); end

  def create_element(name, *args, &block); end

  def create_entity(*_); end

  def create_text_node(string, &block); end

  def decorate(node); end

  def decorators(key); end

  def encoding(); end

  def encoding=(encoding); end

  def errors(); end

  def errors=(errors); end

  def fragment(tags=T.unsafe(nil)); end

  def initialize(*args); end

  def remove_namespaces!(); end

  def root(); end

  def root=(root); end

  def slop!(); end

  def to_java(); end

  def to_xml(*args, &block); end

  def url(); end

  def validate(); end

  def version(); end
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
  NCNAME_CHAR = ::T.let(nil, ::T.untyped)
  NCNAME_RE = ::T.let(nil, ::T.untyped)
  NCNAME_START_CHAR = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Document
  def self.empty_doc?(string_or_io); end

  def self.parse(string_or_io, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.read_io(_, _1, _2, _3); end

  def self.read_memory(_, _1, _2, _3); end

  def self.wrap(document); end
end

class Nokogiri::XML::DocumentFragment
  def dup(); end

  def errors(); end

  def errors=(things); end

  def initialize(document, tags=T.unsafe(nil), ctx=T.unsafe(nil)); end

  def search(*rules); end

  def serialize(); end

  def to_html(*args); end

  def to_xhtml(*args); end

  def to_xml(*args); end
end

class Nokogiri::XML::DocumentFragment
  def self.parse(tags); end
end

class Nokogiri::XML::Element
end

class Nokogiri::XML::Element
end

class Nokogiri::XML::ElementContent
  def children(); end

  def document(); end

  def name(); end

  def occur(); end

  def prefix(); end

  def type(); end
  ELEMENT = ::T.let(nil, ::T.untyped)
  MULT = ::T.let(nil, ::T.untyped)
  ONCE = ::T.let(nil, ::T.untyped)
  OPT = ::T.let(nil, ::T.untyped)
  OR = ::T.let(nil, ::T.untyped)
  PCDATA = ::T.let(nil, ::T.untyped)
  PLUS = ::T.let(nil, ::T.untyped)
  SEQ = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::ElementContent
end

class Nokogiri::XML::ElementDecl
  def element_type(); end

  def prefix(); end
end

class Nokogiri::XML::ElementDecl
end

class Nokogiri::XML::EntityDecl
  def entity_type(); end

  def external_id(); end

  def original_content(); end

  def system_id(); end
  EXTERNAL_GENERAL_PARSED = ::T.let(nil, ::T.untyped)
  EXTERNAL_GENERAL_UNPARSED = ::T.let(nil, ::T.untyped)
  EXTERNAL_PARAMETER = ::T.let(nil, ::T.untyped)
  INTERNAL_GENERAL = ::T.let(nil, ::T.untyped)
  INTERNAL_PARAMETER = ::T.let(nil, ::T.untyped)
  INTERNAL_PREDEFINED = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::EntityDecl
  def self.new(name, doc, *args); end
end

class Nokogiri::XML::EntityReference
end

class Nokogiri::XML::EntityReference
end

class Nokogiri::XML::Namespace
  include ::Nokogiri::XML::PP::Node
  def document(); end

  def href(); end

  def prefix(); end
end

class Nokogiri::XML::Namespace
end

class Nokogiri::XML::Node
  include ::Nokogiri::XML::PP::Node
  include ::Nokogiri::XML::Searchable
  include ::Enumerable
  include ::Nokogiri::HTML5::Node
  def <<(node_or_tags); end

  def ==(other); end

  def >(selector); end

  def [](name); end

  def []=(name, value); end

  def accept(visitor); end

  def add_child(node_or_tags); end

  def add_class(name); end

  def add_namespace(_, _1); end

  def add_namespace_definition(_, _1); end

  def add_next_sibling(node_or_tags); end

  def add_previous_sibling(node_or_tags); end

  def after(node_or_tags); end

  def ancestors(selector=T.unsafe(nil)); end

  def append_class(name); end

  def attr(name); end

  def attribute(_); end

  def attribute_nodes(); end

  def attribute_with_ns(_, _1); end

  def attributes(); end

  def before(node_or_tags); end

  def blank?(); end

  def canonicalize(mode=T.unsafe(nil), inclusive_namespaces=T.unsafe(nil), with_comments=T.unsafe(nil)); end

  def cdata?(); end

  def child(); end

  def children(); end

  def children=(node_or_tags); end

  def classes(); end

  def comment?(); end

  def content(); end

  def content=(string); end

  def create_external_subset(_, _1, _2); end

  def create_internal_subset(_, _1, _2); end

  def css_path(); end

  def decorate!(); end

  def default_namespace=(url); end

  def delete(name); end

  def description(); end

  def do_xinclude(options=T.unsafe(nil)); end

  def document(); end

  def document?(); end

  def dup(*_); end

  def each(&blk); end

  def elem?(); end

  def element?(); end

  def element_children(); end

  def elements(); end

  def encode_special_chars(_); end

  def external_subset(); end

  def first_element_child(); end

  def fragment?(); end

  def get_attribute(name); end

  def has_attribute?(_); end

  def html?(); end

  def initialize(name, document); end

  def inner_html=(node_or_tags); end

  def inner_text(); end

  def internal_subset(); end

  def key?(_); end

  def keys(); end

  def lang(); end

  def lang=(lang); end

  def last_element_child(); end

  def line(); end

  def matches?(selector); end

  def name(); end

  def name=(name); end

  def namespace(); end

  def namespace=(ns); end

  def namespace_definitions(); end

  def namespace_scopes(); end

  def namespaced_key?(_, _1); end

  def namespaces(); end

  def native_content=(native_content); end

  def next(); end

  def next=(node_or_tags); end

  def next_element(); end

  def next_sibling(); end

  def node_name(); end

  def node_name=(node_name); end

  def node_type(); end

  def parent(); end

  def parent=(parent_node); end

  def parse(string_or_io, options=T.unsafe(nil)); end

  def path(); end

  def pointer_id(); end

  def prepend_child(node_or_tags); end

  def previous(); end

  def previous=(node_or_tags); end

  def previous_element(); end

  def previous_sibling(); end

  def processing_instruction?(); end

  def read_only?(); end

  def remove(); end

  def remove_attribute(name); end

  def remove_class(name=T.unsafe(nil)); end

  def replace(node_or_tags); end

  def serialize(*args, &block); end

  def set_attribute(name, value); end

  def swap(node_or_tags); end

  def text(); end

  def text?(); end

  def to_html(options=T.unsafe(nil)); end

  def to_str(); end

  def to_xhtml(options=T.unsafe(nil)); end

  def to_xml(options=T.unsafe(nil)); end

  def traverse(&block); end

  def type(); end

  def unlink(); end

  def values(); end

  def wrap(html); end

  def write_html_to(io, options=T.unsafe(nil)); end

  def write_xhtml_to(io, options=T.unsafe(nil)); end

  def write_xml_to(io, options=T.unsafe(nil)); end

  def xml?(); end
  ATTRIBUTE_DECL = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_NODE = ::T.let(nil, ::T.untyped)
  CDATA_SECTION_NODE = ::T.let(nil, ::T.untyped)
  COMMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCB_DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_FRAG_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_TYPE_NODE = ::T.let(nil, ::T.untyped)
  DTD_NODE = ::T.let(nil, ::T.untyped)
  ELEMENT_DECL = ::T.let(nil, ::T.untyped)
  ELEMENT_NODE = ::T.let(nil, ::T.untyped)
  ENTITY_DECL = ::T.let(nil, ::T.untyped)
  ENTITY_NODE = ::T.let(nil, ::T.untyped)
  ENTITY_REF_NODE = ::T.let(nil, ::T.untyped)
  HTML_DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
  NAMESPACE_DECL = ::T.let(nil, ::T.untyped)
  NOTATION_NODE = ::T.let(nil, ::T.untyped)
  PI_NODE = ::T.let(nil, ::T.untyped)
  TEXT_NODE = ::T.let(nil, ::T.untyped)
  XINCLUDE_END = ::T.let(nil, ::T.untyped)
  XINCLUDE_START = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Node
end

class Nokogiri::XML::NodeSet
  include ::Nokogiri::XML::Searchable
  include ::Enumerable
  def &(_); end

  def +(_); end

  def -(_); end

  def <<(_); end

  def ==(other); end

  def >(selector); end

  def [](*_); end

  def add_class(name); end

  def after(datum); end

  def append_class(name); end

  def attr(key, value=T.unsafe(nil), &block); end

  def attribute(key, value=T.unsafe(nil), &block); end

  def before(datum); end

  def children(); end

  def clone(); end

  def delete(_); end

  def document(); end

  def document=(document); end

  def each(&blk); end

  def empty?(); end

  def filter(expr); end

  def first(n=T.unsafe(nil)); end

  def index(node=T.unsafe(nil)); end

  def initialize(document, list=T.unsafe(nil)); end

  def inner_html(*args); end

  def inner_text(); end

  def last(); end

  def length(); end

  def pop(); end

  def push(_); end

  def remove(); end

  def remove_attr(name); end

  def remove_attribute(name); end

  def remove_class(name=T.unsafe(nil)); end

  def reverse(); end

  def set(key, value=T.unsafe(nil), &block); end

  def shift(); end

  def size(); end

  def slice(*_); end

  def text(); end

  def to_a(); end

  def to_ary(); end

  def to_html(*args); end

  def to_xhtml(*args); end

  def to_xml(*args); end

  def unlink(); end

  def wrap(html); end

  def |(_); end
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::NodeSet
end

class Nokogiri::XML::Notation
end

class Nokogiri::XML::Notation
end

module Nokogiri::XML::PP
end

module Nokogiri::XML::PP::CharacterData
  def inspect(); end

  def pretty_print(pp); end
end

module Nokogiri::XML::PP::CharacterData
end

module Nokogiri::XML::PP::Node
  def inspect(); end

  def pretty_print(pp); end
end

module Nokogiri::XML::PP::Node
end

module Nokogiri::XML::PP
end

class Nokogiri::XML::ParseOptions
  def compact(); end

  def compact?(); end

  def default_html(); end

  def default_html?(); end

  def default_xml(); end

  def default_xml?(); end

  def dtdattr(); end

  def dtdattr?(); end

  def dtdload(); end

  def dtdload?(); end

  def dtdvalid(); end

  def dtdvalid?(); end

  def huge(); end

  def huge?(); end

  def initialize(options=T.unsafe(nil)); end

  def nobasefix(); end

  def nobasefix?(); end

  def noblanks(); end

  def noblanks?(); end

  def nocdata(); end

  def nocdata?(); end

  def nocompact(); end

  def nodefault_html(); end

  def nodefault_xml(); end

  def nodict(); end

  def nodict?(); end

  def nodtdattr(); end

  def nodtdload(); end

  def nodtdvalid(); end

  def noent(); end

  def noent?(); end

  def noerror(); end

  def noerror?(); end

  def nohuge(); end

  def nonet(); end

  def nonet?(); end

  def nonobasefix(); end

  def nonoblanks(); end

  def nonocdata(); end

  def nonodict(); end

  def nonoent(); end

  def nonoerror(); end

  def nononet(); end

  def nonowarning(); end

  def nonoxincnode(); end

  def nonsclean(); end

  def noold10(); end

  def nopedantic(); end

  def norecover(); end

  def nosax1(); end

  def nowarning(); end

  def nowarning?(); end

  def noxinclude(); end

  def noxincnode(); end

  def noxincnode?(); end

  def nsclean(); end

  def nsclean?(); end

  def old10(); end

  def old10?(); end

  def options(); end

  def options=(options); end

  def pedantic(); end

  def pedantic?(); end

  def recover(); end

  def recover?(); end

  def sax1(); end

  def sax1?(); end

  def strict(); end

  def strict?(); end

  def to_i(); end

  def xinclude(); end

  def xinclude?(); end
  COMPACT = ::T.let(nil, ::T.untyped)
  DEFAULT_HTML = ::T.let(nil, ::T.untyped)
  DEFAULT_XML = ::T.let(nil, ::T.untyped)
  DTDATTR = ::T.let(nil, ::T.untyped)
  DTDLOAD = ::T.let(nil, ::T.untyped)
  DTDVALID = ::T.let(nil, ::T.untyped)
  HUGE = ::T.let(nil, ::T.untyped)
  NOBASEFIX = ::T.let(nil, ::T.untyped)
  NOBLANKS = ::T.let(nil, ::T.untyped)
  NOCDATA = ::T.let(nil, ::T.untyped)
  NODICT = ::T.let(nil, ::T.untyped)
  NOENT = ::T.let(nil, ::T.untyped)
  NOERROR = ::T.let(nil, ::T.untyped)
  NONET = ::T.let(nil, ::T.untyped)
  NOWARNING = ::T.let(nil, ::T.untyped)
  NOXINCNODE = ::T.let(nil, ::T.untyped)
  NSCLEAN = ::T.let(nil, ::T.untyped)
  OLD10 = ::T.let(nil, ::T.untyped)
  PEDANTIC = ::T.let(nil, ::T.untyped)
  RECOVER = ::T.let(nil, ::T.untyped)
  SAX1 = ::T.let(nil, ::T.untyped)
  STRICT = ::T.let(nil, ::T.untyped)
  XINCLUDE = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::ParseOptions
end

class Nokogiri::XML::ProcessingInstruction
  def initialize(document, name, content); end
end

class Nokogiri::XML::ProcessingInstruction
end

class Nokogiri::XML::Reader
  include ::Enumerable
  def attribute(_); end

  def attribute_at(_); end

  def attribute_count(); end

  def attribute_nodes(); end

  def attributes(); end

  def attributes?(); end

  def base_uri(); end

  def default?(); end

  def depth(); end

  def each(&blk); end

  def empty_element?(); end

  def encoding(); end

  def errors(); end

  def errors=(errors); end

  def initialize(source, url=T.unsafe(nil), encoding=T.unsafe(nil)); end

  def inner_xml(); end

  def lang(); end

  def local_name(); end

  def name(); end

  def namespace_uri(); end

  def namespaces(); end

  def node_type(); end

  def outer_xml(); end

  def prefix(); end

  def read(); end

  def self_closing?(); end

  def source(); end

  def state(); end

  def value(); end

  def value?(); end

  def xml_version(); end
  TYPE_ATTRIBUTE = ::T.let(nil, ::T.untyped)
  TYPE_CDATA = ::T.let(nil, ::T.untyped)
  TYPE_COMMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT_FRAGMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT_TYPE = ::T.let(nil, ::T.untyped)
  TYPE_ELEMENT = ::T.let(nil, ::T.untyped)
  TYPE_END_ELEMENT = ::T.let(nil, ::T.untyped)
  TYPE_END_ENTITY = ::T.let(nil, ::T.untyped)
  TYPE_ENTITY = ::T.let(nil, ::T.untyped)
  TYPE_ENTITY_REFERENCE = ::T.let(nil, ::T.untyped)
  TYPE_NONE = ::T.let(nil, ::T.untyped)
  TYPE_NOTATION = ::T.let(nil, ::T.untyped)
  TYPE_PROCESSING_INSTRUCTION = ::T.let(nil, ::T.untyped)
  TYPE_SIGNIFICANT_WHITESPACE = ::T.let(nil, ::T.untyped)
  TYPE_TEXT = ::T.let(nil, ::T.untyped)
  TYPE_WHITESPACE = ::T.let(nil, ::T.untyped)
  TYPE_XML_DECLARATION = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Reader
  def self.from_io(*_); end

  def self.from_memory(*_); end
end

class Nokogiri::XML::RelaxNG
end

class Nokogiri::XML::RelaxNG
end

module Nokogiri::XML::SAX
end

class Nokogiri::XML::SAX::Document
  def cdata_block(string); end

  def characters(string); end

  def comment(string); end

  def end_document(); end

  def end_element(name); end

  def end_element_namespace(name, prefix=T.unsafe(nil), uri=T.unsafe(nil)); end

  def error(string); end

  def processing_instruction(name, content); end

  def start_document(); end

  def start_element(name, attrs=T.unsafe(nil)); end

  def start_element_namespace(name, attrs=T.unsafe(nil), prefix=T.unsafe(nil), uri=T.unsafe(nil), ns=T.unsafe(nil)); end

  def warning(string); end

  def xmldecl(version, encoding, standalone); end
end

class Nokogiri::XML::SAX::Document
end

class Nokogiri::XML::SAX::Parser
  def document(); end

  def document=(document); end

  def encoding(); end

  def encoding=(encoding); end

  def initialize(doc=T.unsafe(nil), encoding=T.unsafe(nil)); end

  def parse(thing, &block); end

  def parse_file(filename); end

  def parse_io(io, encoding=T.unsafe(nil)); end

  def parse_memory(data); end
  ENCODINGS = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::SAX::Parser
end

class Nokogiri::XML::SAX::ParserContext
  def column(); end

  def line(); end

  def parse_with(_); end

  def recovery(); end

  def recovery=(recovery); end

  def replace_entities(); end

  def replace_entities=(replace_entities); end
end

class Nokogiri::XML::SAX::ParserContext
  def self.file(_); end

  def self.io(_, _1); end

  def self.memory(_); end

  def self.new(thing, encoding=T.unsafe(nil)); end
end

class Nokogiri::XML::SAX::PushParser
  def <<(chunk, last_chunk=T.unsafe(nil)); end

  def document(); end

  def document=(document); end

  def finish(); end

  def initialize(doc=T.unsafe(nil), file_name=T.unsafe(nil), encoding=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def replace_entities(); end

  def replace_entities=(replace_entities); end

  def write(chunk, last_chunk=T.unsafe(nil)); end
end

class Nokogiri::XML::SAX::PushParser
end

module Nokogiri::XML::SAX
end

class Nokogiri::XML::Schema
  def errors(); end

  def errors=(errors); end

  def valid?(thing); end

  def validate(thing); end
end

class Nokogiri::XML::Schema
  def self.from_document(_); end

  def self.new(string_or_io); end

  def self.read_memory(_); end
end

module Nokogiri::XML::Searchable
  def %(*args); end

  def /(*args); end

  def at(*args); end

  def at_css(*args); end

  def at_xpath(*args); end

  def css(*args); end

  def search(*args); end

  def xpath(*args); end
  LOOKS_LIKE_XPATH = ::T.let(nil, ::T.untyped)
end

module Nokogiri::XML::Searchable
end

class Nokogiri::XML::SyntaxError
  def code(); end

  def column(); end

  def domain(); end

  def error?(); end

  def fatal?(); end

  def file(); end

  def int1(); end

  def level(); end

  def line(); end

  def none?(); end

  def str1(); end

  def str2(); end

  def str3(); end

  def warning?(); end
end

class Nokogiri::XML::SyntaxError
end

class Nokogiri::XML::Text
end

class Nokogiri::XML::Text
end

class Nokogiri::XML::XPath
  def document(); end

  def document=(document); end
end

class Nokogiri::XML::XPath::SyntaxError
end

class Nokogiri::XML::XPath::SyntaxError
end

class Nokogiri::XML::XPath
end

class Nokogiri::XML::XPathContext
  def evaluate(*_); end

  def register_namespaces(namespaces); end

  def register_ns(_, _1); end

  def register_variable(_, _1); end
end

class Nokogiri::XML::XPathContext
  def self.new(_); end
end

module Nokogiri::XML
  def self.Reader(string_or_io, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.RelaxNG(string_or_io); end

  def self.Schema(string_or_io); end

  def self.fragment(string); end

  def self.parse(thing, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil), &block); end
end

module Nokogiri::XSLT
end

class Nokogiri::XSLT::Stylesheet
  def apply_to(document, params=T.unsafe(nil)); end

  def serialize(_); end

  def transform(*_); end
end

class Nokogiri::XSLT::Stylesheet
  def self.parse_stylesheet_doc(_); end
end

module Nokogiri::XSLT
  def self.parse(string, modules=T.unsafe(nil)); end

  def self.quote_params(params); end

  def self.register(_, _1); end
end

module Nokogiri
  def self.HTML(thing, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def self.HTML5(string_or_io, url=T.unsafe(nil), encoding=T.unsafe(nil), **options, &block); end

  def self.Slop(*args, &block); end

  def self.XML(thing, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def self.XSLT(stylesheet, modules=T.unsafe(nil)); end

  def self.install_default_aliases(); end

  def self.jruby?(); end

  def self.make(input=T.unsafe(nil), opts=T.unsafe(nil), &blk); end

  def self.parse(string, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.uses_libxml?(); end
end

module Nokogumbo
  DEFAULT_MAX_ERRORS = ::T.let(nil, ::T.untyped)
  DEFAULT_MAX_TREE_DEPTH = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Nokogumbo
  def self.fragment(_, _1, _2, _3, _4); end

  def self.parse(_, _1, _2, _3); end
end

class Object
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  def to_yaml(options=T.unsafe(nil)); end
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  ENV_PATH = ::T.let(nil, ::T.untyped)
  FORBIDDEN = ::T.let(nil, ::T.untyped)
  FORBIDDEN_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
end

class Object
  def self.yaml_tag(url); end
end

class ObjectSpace::WeakMap
  def [](_); end

  def []=(_, _1); end

  def each(&blk); end

  def each_key(); end

  def each_pair(); end

  def each_value(); end

  def key?(_); end

  def keys(); end

  def length(); end

  def size(); end

  def values(); end
end

module ObjectSpace
  def self.count_objects(*_); end

  def self.define_finalizer(*_); end

  def self.garbage_collect(full_mark: T.unsafe(nil), immediate_mark: T.unsafe(nil), immediate_sweep: T.unsafe(nil)); end

  def self.undefine_finalizer(_); end
end

class OpenSSL::ASN1::ASN1Data
  def indefinite_length(); end

  def indefinite_length=(indefinite_length); end
end

class OpenSSL::BN
  def +@(); end

  def -@(); end

  def /(_); end

  def negative?(); end
end

module OpenSSL::KDF
end

class OpenSSL::KDF::KDFError
end

class OpenSSL::KDF::KDFError
end

module OpenSSL::KDF
  def self.hkdf(*_); end

  def self.pbkdf2_hmac(*_); end

  def self.scrypt(*_); end
end

class OpenSSL::OCSP::Request
  def signed?(); end
end

OpenSSL::PKCS7::Signer = OpenSSL::PKCS7::SignerInfo

class OpenSSL::PKey::EC
  EXPLICIT_CURVE = ::T.let(nil, ::T.untyped)
end

class OpenSSL::PKey::EC::Point
  def to_octet_string(_); end
end

class OpenSSL::PKey::RSA
  def sign_pss(*_); end

  def verify_pss(*_); end
end

module OpenSSL::SSL
  OP_ALLOW_NO_DHE_KEX = ::T.let(nil, ::T.untyped)
  OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_CRYPTOPRO_TLSEXT_BUG = ::T.let(nil, ::T.untyped)
  OP_LEGACY_SERVER_CONNECT = ::T.let(nil, ::T.untyped)
  OP_NO_ENCRYPT_THEN_MAC = ::T.let(nil, ::T.untyped)
  OP_NO_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_NO_TLSv1_3 = ::T.let(nil, ::T.untyped)
  OP_SAFARI_ECDHE_ECDSA_BUG = ::T.let(nil, ::T.untyped)
  OP_TLSEXT_PADDING = ::T.let(nil, ::T.untyped)
  SSL2_VERSION = ::T.let(nil, ::T.untyped)
  SSL3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_1_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_2_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_VERSION = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLContext
  def add_certificate(*_); end

  def alpn_protocols(); end

  def alpn_protocols=(alpn_protocols); end

  def alpn_select_cb(); end

  def alpn_select_cb=(alpn_select_cb); end

  def enable_fallback_scsv(); end

  def max_version=(version); end

  def min_version=(version); end
  DEFAULT_TMP_DH_CALLBACK = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLSocket
  def alpn_protocol(); end

  def tmp_key(); end
end

module OpenSSL::X509
  V_FLAG_NO_CHECK_TIME = ::T.let(nil, ::T.untyped)
  V_FLAG_TRUSTED_FIRST = ::T.let(nil, ::T.untyped)
end

class OpenSSL::X509::Attribute
  def ==(other); end
end

class OpenSSL::X509::CRL
  def ==(other); end
end

class OpenSSL::X509::Extension
  def ==(other); end
end

class OpenSSL::X509::Name
  def to_utf8(); end
end

class OpenSSL::X509::Request
  def ==(other); end
end

class OpenSSL::X509::Revoked
  def ==(other); end

  def to_der(); end
end

module OpenSSL
  def self.fips_mode(); end
end

class OpenStruct
  VERSION = ::T.let(nil, ::T.untyped)
end

class OptionParser
  def additional_message(typ, opt); end
end

class OptionParser::List
  def get_candidates(id); end
end

class OptionParser::ParseError
  def additional(); end

  def additional=(additional); end

end

module Parallel
  Stop = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Parallel::Break
end

class Parallel::Break
end

class Parallel::DeadWorker
end

class Parallel::DeadWorker
end

class Parallel::ExceptionWrapper
  def exception(); end

  def initialize(exception); end
end

class Parallel::ExceptionWrapper
end

class Parallel::JobFactory
  def initialize(source, mutex); end

  def next(); end

  def pack(item, index); end

  def size(); end

  def unpack(data); end
end

class Parallel::JobFactory
end

class Parallel::Kill
end

class Parallel::Kill
end

module Parallel::ProcessorCount
  def physical_processor_count(); end

  def processor_count(); end
end

module Parallel::ProcessorCount
end

class Parallel::UndumpableException
  def initialize(original); end
end

class Parallel::UndumpableException
end

class Parallel::UserInterruptHandler
  INTERRUPT_SIGNAL = ::T.let(nil, ::T.untyped)
end

class Parallel::UserInterruptHandler
  def self.kill(thing); end

  def self.kill_on_ctrl_c(pids, options); end
end

class Parallel::Worker
  def close_pipes(); end

  def initialize(read, write, pid); end

  def pid(); end

  def read(); end

  def stop(); end

  def thread(); end

  def thread=(thread); end

  def work(data); end

  def write(); end
end

class Parallel::Worker
end

module Parallel
  extend ::Parallel::ProcessorCount
  def self.all?(*args, &block); end

  def self.any?(*args, &block); end

  def self.each(array, options=T.unsafe(nil), &block); end

  def self.each_with_index(array, options=T.unsafe(nil), &block); end

  def self.flat_map(*args, &block); end

  def self.in_processes(options=T.unsafe(nil), &block); end

  def self.in_threads(options=T.unsafe(nil)); end

  def self.map(source, options=T.unsafe(nil), &block); end

  def self.map_with_index(array, options=T.unsafe(nil), &block); end

  def self.worker_number(); end

  def self.worker_number=(worker_num); end
end

ParseError = Racc::ParseError

module Parser
  MESSAGES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Parser::AST
end

class Parser::AST::Node
  def loc(); end

  def location(); end
end

class Parser::AST::Node
end

class Parser::AST::Processor
  def on_alias(node); end

  def on_and(node); end

  def on_and_asgn(node); end

  def on_arg(node); end

  def on_arg_expr(node); end

  def on_args(node); end

  def on_argument(node); end

  def on_array(node); end

  def on_array_pattern(node); end

  def on_array_pattern_with_tail(node); end

  def on_back_ref(node); end

  def on_begin(node); end

  def on_block(node); end

  def on_block_pass(node); end

  def on_blockarg(node); end

  def on_blockarg_expr(node); end

  def on_break(node); end

  def on_case(node); end

  def on_case_match(node); end

  def on_casgn(node); end

  def on_class(node); end

  def on_const(node); end

  def on_const_pattern(node); end

  def on_csend(node); end

  def on_cvar(node); end

  def on_cvasgn(node); end

  def on_def(node); end

  def on_defined?(node); end

  def on_defs(node); end

  def on_dstr(node); end

  def on_dsym(node); end

  def on_eflipflop(node); end

  def on_ensure(node); end

  def on_erange(node); end

  def on_for(node); end

  def on_gvar(node); end

  def on_gvasgn(node); end

  def on_hash(node); end

  def on_hash_pattern(node); end

  def on_if(node); end

  def on_if_guard(node); end

  def on_iflipflop(node); end

  def on_in_match(node); end

  def on_in_pattern(node); end

  def on_index(node); end

  def on_indexasgn(node); end

  def on_irange(node); end

  def on_ivar(node); end

  def on_ivasgn(node); end

  def on_kwarg(node); end

  def on_kwbegin(node); end

  def on_kwoptarg(node); end

  def on_kwrestarg(node); end

  def on_kwsplat(node); end

  def on_lambda(node); end

  def on_lvar(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_match_alt(node); end

  def on_match_as(node); end

  def on_match_current_line(node); end

  def on_match_rest(node); end

  def on_match_var(node); end

  def on_match_with_lvasgn(node); end

  def on_mlhs(node); end

  def on_module(node); end

  def on_next(node); end

  def on_not(node); end

  def on_nth_ref(node); end

  def on_numblock(node); end

  def on_op_asgn(node); end

  def on_optarg(node); end

  def on_or(node); end

  def on_or_asgn(node); end

  def on_pair(node); end

  def on_pin(node); end

  def on_postexe(node); end

  def on_preexe(node); end

  def on_procarg0(node); end

  def on_redo(node); end

  def on_regexp(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_restarg(node); end

  def on_restarg_expr(node); end

  def on_retry(node); end

  def on_return(node); end

  def on_sclass(node); end

  def on_send(node); end

  def on_shadowarg(node); end

  def on_splat(node); end

  def on_super(node); end

  def on_undef(node); end

  def on_unless_guard(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_var(node); end

  def on_vasgn(node); end

  def on_when(node); end

  def on_while(node); end

  def on_while_post(node); end

  def on_xstr(node); end

  def on_yield(node); end

  def process_argument_node(node); end

  def process_regular_node(node); end

  def process_var_asgn_node(node); end

  def process_variable_node(node); end
end

class Parser::AST::Processor
end

module Parser::AST
end

class Parser::Base
  def builder(); end

  def context(); end

  def current_arg_stack(); end

  def diagnostics(); end

  def initialize(builder=T.unsafe(nil)); end

  def max_numparam_stack(); end

  def parse(source_buffer); end

  def parse_with_comments(source_buffer); end

  def pattern_hash_keys(); end

  def pattern_variables(); end

  def reset(); end

  def source_buffer(); end

  def static_env(); end

  def tokenize(source_buffer, recover=T.unsafe(nil)); end
end

class Parser::Base
  def self.default_parser(); end

  def self.parse(string, file=T.unsafe(nil), line=T.unsafe(nil)); end

  def self.parse_file(filename); end

  def self.parse_file_with_comments(filename); end

  def self.parse_with_comments(string, file=T.unsafe(nil), line=T.unsafe(nil)); end
end

module Parser::Builders
end

class Parser::Builders::Default
  def __ENCODING__(__ENCODING__t); end

  def __FILE__(__FILE__t); end

  def __LINE__(__LINE__t); end

  def accessible(node); end

  def alias(alias_t, to, from); end

  def arg(name_t); end

  def arg_expr(expr); end

  def args(begin_t, args, end_t, check_args=T.unsafe(nil)); end

  def array(begin_t, elements, end_t); end

  def array_pattern(lbrack_t, elements, rbrack_t); end

  def assign(lhs, eql_t, rhs); end

  def assignable(node); end

  def associate(begin_t, pairs, end_t); end

  def attr_asgn(receiver, dot_t, selector_t); end

  def back_ref(token); end

  def begin(begin_t, body, end_t); end

  def begin_body(compound_stmt, rescue_bodies=T.unsafe(nil), else_t=T.unsafe(nil), else_=T.unsafe(nil), ensure_t=T.unsafe(nil), ensure_=T.unsafe(nil)); end

  def begin_keyword(begin_t, body, end_t); end

  def binary_op(receiver, operator_t, arg); end

  def block(method_call, begin_t, args, body, end_t); end

  def block_pass(amper_t, arg); end

  def blockarg(amper_t, name_t); end

  def blockarg_expr(amper_t, expr); end

  def call_lambda(lambda_t); end

  def call_method(receiver, dot_t, selector_t, lparen_t=T.unsafe(nil), args=T.unsafe(nil), rparen_t=T.unsafe(nil)); end

  def call_type_for_dot(dot_t); end

  def case(case_t, expr, when_bodies, else_t, else_body, end_t); end

  def case_match(case_t, expr, in_bodies, else_t, else_body, end_t); end

  def character(char_t); end

  def complex(complex_t); end

  def compstmt(statements); end

  def condition(cond_t, cond, then_t, if_true, else_t, if_false, end_t); end

  def condition_mod(if_true, if_false, cond_t, cond); end

  def const(name_t); end

  def const_fetch(scope, t_colon2, name_t); end

  def const_global(t_colon3, name_t); end

  def const_op_assignable(node); end

  def const_pattern(const, ldelim_t, pattern, rdelim_t); end

  def cvar(token); end

  def dedent_string(node, dedent_level); end

  def def_class(class_t, name, lt_t, superclass, body, end_t); end

  def def_method(def_t, name_t, args, body, end_t); end

  def def_module(module_t, name, body, end_t); end

  def def_sclass(class_t, lshft_t, expr, body, end_t); end

  def def_singleton(def_t, definee, dot_t, name_t, args, body, end_t); end

  def emit_file_line_as_literals(); end

  def emit_file_line_as_literals=(emit_file_line_as_literals); end

  def false(false_t); end

  def float(float_t); end

  def for(for_t, iterator, in_t, iteratee, do_t, body, end_t); end

  def forward_args(begin_t, dots_t, end_t); end

  def forwarded_args(dots_t); end

  def gvar(token); end

  def hash_pattern(lbrace_t, kwargs, rbrace_t); end

  def ident(token); end

  def if_guard(if_t, if_body); end

  def in_match(lhs, in_t, rhs); end

  def in_pattern(in_t, pattern, guard, then_t, body); end

  def index(receiver, lbrack_t, indexes, rbrack_t); end

  def index_asgn(receiver, lbrack_t, indexes, rbrack_t); end

  def integer(integer_t); end

  def ivar(token); end

  def keyword_cmd(type, keyword_t, lparen_t=T.unsafe(nil), args=T.unsafe(nil), rparen_t=T.unsafe(nil)); end

  def kwarg(name_t); end

  def kwnilarg(dstar_t, nil_t); end

  def kwoptarg(name_t, value); end

  def kwrestarg(dstar_t, name_t=T.unsafe(nil)); end

  def kwsplat(dstar_t, arg); end

  def logical_op(type, lhs, op_t, rhs); end

  def loop(type, keyword_t, cond, do_t, body, end_t); end

  def loop_mod(type, body, keyword_t, cond); end

  def match_alt(left, pipe_t, right); end

  def match_as(value, assoc_t, as); end

  def match_hash_var(name_t); end

  def match_hash_var_from_str(begin_t, strings, end_t); end

  def match_label(label_type, label); end

  def match_nil_pattern(dstar_t, nil_t); end

  def match_op(receiver, match_t, arg); end

  def match_pair(label_type, label, value); end

  def match_rest(star_t, name_t=T.unsafe(nil)); end

  def match_var(name_t); end

  def match_with_trailing_comma(match); end

  def multi_assign(lhs, eql_t, rhs); end

  def multi_lhs(begin_t, items, end_t); end

  def nil(nil_t); end

  def not_op(not_t, begin_t=T.unsafe(nil), receiver=T.unsafe(nil), end_t=T.unsafe(nil)); end

  def nth_ref(token); end

  def numargs(max_numparam); end

  def objc_kwarg(kwname_t, assoc_t, name_t); end

  def objc_restarg(star_t, name=T.unsafe(nil)); end

  def objc_varargs(pair, rest_of_varargs); end

  def op_assign(lhs, op_t, rhs); end

  def optarg(name_t, eql_t, value); end

  def pair(key, assoc_t, value); end

  def pair_keyword(key_t, value); end

  def pair_list_18(list); end

  def pair_quoted(begin_t, parts, end_t, value); end

  def parser(); end

  def parser=(parser); end

  def pin(pin_t, var); end

  def postexe(postexe_t, lbrace_t, compstmt, rbrace_t); end

  def preexe(preexe_t, lbrace_t, compstmt, rbrace_t); end

  def procarg0(arg); end

  def range_exclusive(lhs, dot3_t, rhs); end

  def range_inclusive(lhs, dot2_t, rhs); end

  def rational(rational_t); end

  def regexp_compose(begin_t, parts, end_t, options); end

  def regexp_options(regopt_t); end

  def rescue_body(rescue_t, exc_list, assoc_t, exc_var, then_t, compound_stmt); end

  def restarg(star_t, name_t=T.unsafe(nil)); end

  def restarg_expr(star_t, expr=T.unsafe(nil)); end

  def self(token); end

  def shadowarg(name_t); end

  def splat(star_t, arg=T.unsafe(nil)); end

  def string(string_t); end

  def string_compose(begin_t, parts, end_t); end

  def string_internal(string_t); end

  def symbol(symbol_t); end

  def symbol_compose(begin_t, parts, end_t); end

  def symbol_internal(symbol_t); end

  def symbols_compose(begin_t, parts, end_t); end

  def ternary(cond, question_t, if_true, colon_t, if_false); end

  def true(true_t); end

  def unary_num(unary_t, numeric); end

  def unary_op(op_t, receiver); end

  def undef_method(undef_t, names); end

  def unless_guard(unless_t, unless_body); end

  def when(when_t, patterns, then_t, body); end

  def word(parts); end

  def words_compose(begin_t, parts, end_t); end

  def xstring_compose(begin_t, parts, end_t); end
end

class Parser::Builders::Default
  def self.emit_arg_inside_procarg0(); end

  def self.emit_arg_inside_procarg0=(emit_arg_inside_procarg0); end

  def self.emit_encoding(); end

  def self.emit_encoding=(emit_encoding); end

  def self.emit_index(); end

  def self.emit_index=(emit_index); end

  def self.emit_lambda(); end

  def self.emit_lambda=(emit_lambda); end

  def self.emit_procarg0(); end

  def self.emit_procarg0=(emit_procarg0); end

  def self.modernize(); end
end

module Parser::Builders
end

class Parser::ClobberingError
end

class Parser::ClobberingError
end

class Parser::Context
  def class_definition_allowed?(); end

  def dynamic_const_definition_allowed?(); end

  def in_block?(); end

  def in_class?(); end

  def in_dynamic_block?(); end

  def in_lambda?(); end

  def indirectly_in_def?(); end

  def module_definition_allowed?(); end

  def pop(); end

  def push(state); end

  def reset(); end

  def stack(); end
end

class Parser::Context
end

class Parser::CurrentArgStack
  def pop(); end

  def push(value); end

  def reset(); end

  def set(value); end

  def stack(); end

  def top(); end
end

class Parser::CurrentArgStack
end

module Parser::Deprecation
  def warn_of_deprecation(); end

  def warned_of_deprecation=(warned_of_deprecation); end
end

module Parser::Deprecation
end

class Parser::Diagnostic
  def arguments(); end

  def highlights(); end

  def initialize(level, reason, arguments, location, highlights=T.unsafe(nil)); end

  def level(); end

  def location(); end

  def message(); end

  def reason(); end

  def render(); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Parser::Diagnostic::Engine
  def all_errors_are_fatal(); end

  def all_errors_are_fatal=(all_errors_are_fatal); end

  def consumer(); end

  def consumer=(consumer); end

  def ignore?(diagnostic); end

  def ignore_warnings(); end

  def ignore_warnings=(ignore_warnings); end

  def initialize(consumer=T.unsafe(nil)); end

  def process(diagnostic); end

  def raise?(diagnostic); end
end

class Parser::Diagnostic::Engine
end

class Parser::Diagnostic
end

class Parser::Lexer
  def advance(); end

  def arg_or_cmdarg(cmd_state); end

  def cmdarg(); end

  def cmdarg=(cmdarg); end

  def command_start(); end

  def command_start=(command_start); end

  def comments(); end

  def comments=(comments); end

  def cond(); end

  def cond=(cond); end

  def context(); end

  def context=(context); end

  def dedent_level(); end

  def diagnostic(type, reason, arguments=T.unsafe(nil), location=T.unsafe(nil), highlights=T.unsafe(nil)); end

  def diagnostics(); end

  def diagnostics=(diagnostics); end

  def emit(type, value=T.unsafe(nil), s=T.unsafe(nil), e=T.unsafe(nil)); end

  def emit_comment(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def emit_do(do_block=T.unsafe(nil)); end

  def emit_table(table, s=T.unsafe(nil), e=T.unsafe(nil)); end

  def encode_escape(ord); end

  def encoding(); end

  def eof_codepoint?(point); end

  def force_utf32(); end

  def force_utf32=(force_utf32); end

  def in_kwarg(); end

  def in_kwarg=(in_kwarg); end

  def initialize(version); end

  def literal(); end

  def next_state_for_literal(literal); end

  def pop_cmdarg(); end

  def pop_cond(); end

  def pop_literal(); end

  def push_cmdarg(); end

  def push_cond(); end

  def push_literal(*args); end

  def range(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def reset(reset_state=T.unsafe(nil)); end

  def source_buffer(); end

  def source_buffer=(source_buffer); end

  def stack_pop(); end

  def state(); end

  def state=(state); end

  def static_env(); end

  def static_env=(static_env); end

  def tok(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def tokens(); end

  def tokens=(tokens); end

  def version?(*versions); end
  ESCAPES = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  KEYWORDS_BEGIN = ::T.let(nil, ::T.untyped)
  LEX_STATES = ::T.let(nil, ::T.untyped)
  PUNCTUATION = ::T.let(nil, ::T.untyped)
  PUNCTUATION_BEGIN = ::T.let(nil, ::T.untyped)
  REGEXP_META_CHARACTERS = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Dedenter
  def dedent(string); end

  def initialize(dedent_level); end

  def interrupt(); end
  TAB_WIDTH = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Dedenter
end

class Parser::Lexer::Literal
  def backslash_delimited?(); end

  def clear_buffer(); end

  def coerce_encoding(string); end

  def dedent_level(); end

  def delimiter?(delimiter); end

  def emit(token, type, s, e); end

  def emit_start_tok(); end

  def end_interp_brace_and_try_closing(); end

  def extend_content(); end

  def extend_space(ts, te); end

  def extend_string(string, ts, te); end

  def flush_string(); end

  def heredoc?(); end

  def heredoc_e(); end

  def infer_indent_level(line); end

  def initialize(lexer, str_type, delimiter, str_s, heredoc_e=T.unsafe(nil), indent=T.unsafe(nil), dedent_body=T.unsafe(nil), label_allowed=T.unsafe(nil)); end

  def interpolate?(); end

  def munge_escape?(character); end

  def nest_and_try_closing(delimiter, ts, te, lookahead=T.unsafe(nil)); end

  def plain_heredoc?(); end

  def regexp?(); end

  def saved_herebody_s(); end

  def saved_herebody_s=(saved_herebody_s); end

  def squiggly_heredoc?(); end

  def start_interp_brace(); end

  def str_s(); end

  def supports_line_continuation_via_slash?(); end

  def type(); end

  def words?(); end
  DELIMITERS = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Literal
end

class Parser::Lexer::StackState
  def active?(); end

  def clear(); end

  def empty?(); end

  def initialize(name); end

  def lexpop(); end

  def pop(); end

  def push(bit); end
end

class Parser::Lexer::StackState
end

class Parser::Lexer
  def self.lex_en_expr_arg(); end

  def self.lex_en_expr_arg=(lex_en_expr_arg); end

  def self.lex_en_expr_beg(); end

  def self.lex_en_expr_beg=(lex_en_expr_beg); end

  def self.lex_en_expr_cmdarg(); end

  def self.lex_en_expr_cmdarg=(lex_en_expr_cmdarg); end

  def self.lex_en_expr_dot(); end

  def self.lex_en_expr_dot=(lex_en_expr_dot); end

  def self.lex_en_expr_end(); end

  def self.lex_en_expr_end=(lex_en_expr_end); end

  def self.lex_en_expr_endarg(); end

  def self.lex_en_expr_endarg=(lex_en_expr_endarg); end

  def self.lex_en_expr_endfn(); end

  def self.lex_en_expr_endfn=(lex_en_expr_endfn); end

  def self.lex_en_expr_fname(); end

  def self.lex_en_expr_fname=(lex_en_expr_fname); end

  def self.lex_en_expr_labelarg(); end

  def self.lex_en_expr_labelarg=(lex_en_expr_labelarg); end

  def self.lex_en_expr_mid(); end

  def self.lex_en_expr_mid=(lex_en_expr_mid); end

  def self.lex_en_expr_value(); end

  def self.lex_en_expr_value=(lex_en_expr_value); end

  def self.lex_en_expr_variable(); end

  def self.lex_en_expr_variable=(lex_en_expr_variable); end

  def self.lex_en_interp_backslash_delimited(); end

  def self.lex_en_interp_backslash_delimited=(lex_en_interp_backslash_delimited); end

  def self.lex_en_interp_backslash_delimited_words(); end

  def self.lex_en_interp_backslash_delimited_words=(lex_en_interp_backslash_delimited_words); end

  def self.lex_en_interp_string(); end

  def self.lex_en_interp_string=(lex_en_interp_string); end

  def self.lex_en_interp_words(); end

  def self.lex_en_interp_words=(lex_en_interp_words); end

  def self.lex_en_leading_dot(); end

  def self.lex_en_leading_dot=(lex_en_leading_dot); end

  def self.lex_en_line_begin(); end

  def self.lex_en_line_begin=(lex_en_line_begin); end

  def self.lex_en_line_comment(); end

  def self.lex_en_line_comment=(lex_en_line_comment); end

  def self.lex_en_plain_backslash_delimited(); end

  def self.lex_en_plain_backslash_delimited=(lex_en_plain_backslash_delimited); end

  def self.lex_en_plain_backslash_delimited_words(); end

  def self.lex_en_plain_backslash_delimited_words=(lex_en_plain_backslash_delimited_words); end

  def self.lex_en_plain_string(); end

  def self.lex_en_plain_string=(lex_en_plain_string); end

  def self.lex_en_plain_words(); end

  def self.lex_en_plain_words=(lex_en_plain_words); end

  def self.lex_en_regexp_modifiers(); end

  def self.lex_en_regexp_modifiers=(lex_en_regexp_modifiers); end

  def self.lex_error(); end

  def self.lex_error=(lex_error); end

  def self.lex_start(); end

  def self.lex_start=(lex_start); end
end

class Parser::MaxNumparamStack
  def has_numparams?(); end

  def has_ordinary_params!(); end

  def has_ordinary_params?(); end

  def pop(); end

  def push(); end

  def register(numparam); end

  def stack(); end

  def top(); end
end

class Parser::MaxNumparamStack
end

module Parser::Meta
  NODE_TYPES = ::T.let(nil, ::T.untyped)
end

module Parser::Meta
end

class Parser::Rewriter
  def assignment?(node); end

  def initialize(*_); end

  def insert_after(range, content); end

  def insert_before(range, content); end

  def remove(range); end

  def replace(range, content); end

  def rewrite(source_buffer, ast); end

  def wrap(range, before, after); end
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class Parser::Rewriter
  extend ::Parser::Deprecation
end

module Parser::Source
end

class Parser::Source::Buffer
  def column_for_position(position); end

  def decompose_position(position); end

  def first_line(); end

  def initialize(name, first_line=T.unsafe(nil)); end

  def last_line(); end

  def line_for_position(position); end

  def line_range(lineno); end

  def name(); end

  def raw_source=(input); end

  def read(); end

  def slice(range); end

  def source(); end

  def source=(input); end

  def source_line(lineno); end

  def source_lines(); end

  def source_range(); end
  ENCODING_RE = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Buffer
  def self.recognize_encoding(string); end

  def self.reencode_string(input); end
end

class Parser::Source::Comment
  def ==(other); end

  def document?(); end

  def initialize(range); end

  def inline?(); end

  def loc(); end

  def location(); end

  def text(); end

  def type(); end
end

class Parser::Source::Comment::Associator
  def associate(); end

  def associate_locations(); end

  def initialize(ast, comments); end

  def skip_directives(); end

  def skip_directives=(skip_directives); end
  MAGIC_COMMENT_RE = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Comment::Associator
end

class Parser::Source::Comment
  def self.associate(ast, comments); end

  def self.associate_locations(ast, comments); end
end

class Parser::Source::Map
  def ==(other); end

  def column(); end

  def expression(); end

  def first_line(); end

  def initialize(expression); end

  def last_column(); end

  def last_line(); end

  def line(); end

  def node(); end

  def node=(node); end

  def to_hash(); end

  def update_expression(expression_l); end

  def with(&block); end

  def with_expression(expression_l); end
end

class Parser::Source::Map::Collection
  def begin(); end

  def end(); end

  def initialize(begin_l, end_l, expression_l); end
end

class Parser::Source::Map::Collection
end

class Parser::Source::Map::Condition
  def begin(); end

  def else(); end

  def end(); end

  def initialize(keyword_l, begin_l, else_l, end_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::Condition
end

class Parser::Source::Map::Constant
  def double_colon(); end

  def initialize(double_colon, name, expression); end

  def name(); end

  def operator(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Constant
end

class Parser::Source::Map::Definition
  def end(); end

  def initialize(keyword_l, operator_l, name_l, end_l); end

  def keyword(); end

  def name(); end

  def operator(); end
end

class Parser::Source::Map::Definition
end

class Parser::Source::Map::For
  def begin(); end

  def end(); end

  def in(); end

  def initialize(keyword_l, in_l, begin_l, end_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::For
end

class Parser::Source::Map::Heredoc
  def heredoc_body(); end

  def heredoc_end(); end

  def initialize(begin_l, body_l, end_l); end
end

class Parser::Source::Map::Heredoc
end

class Parser::Source::Map::Index
  def begin(); end

  def end(); end

  def initialize(begin_l, end_l, expression_l); end

  def operator(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Index
end

class Parser::Source::Map::Keyword
  def begin(); end

  def end(); end

  def initialize(keyword_l, begin_l, end_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::Keyword
end

class Parser::Source::Map::ObjcKwarg
  def argument(); end

  def initialize(keyword_l, operator_l, argument_l, expression_l); end

  def keyword(); end

  def operator(); end
end

class Parser::Source::Map::ObjcKwarg
end

class Parser::Source::Map::Operator
  def initialize(operator, expression); end

  def operator(); end
end

class Parser::Source::Map::Operator
end

class Parser::Source::Map::RescueBody
  def assoc(); end

  def begin(); end

  def initialize(keyword_l, assoc_l, begin_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::RescueBody
end

class Parser::Source::Map::Send
  def begin(); end

  def dot(); end

  def end(); end

  def initialize(dot_l, selector_l, begin_l, end_l, expression_l); end

  def operator(); end

  def selector(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Send
end

class Parser::Source::Map::Ternary
  def colon(); end

  def initialize(question_l, colon_l, expression_l); end

  def question(); end
end

class Parser::Source::Map::Ternary
end

class Parser::Source::Map::Variable
  def initialize(name_l, expression_l=T.unsafe(nil)); end

  def name(); end

  def operator(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Variable
end

class Parser::Source::Map
end

class Parser::Source::Range
  include ::Comparable
  def adjust(begin_pos: T.unsafe(nil), end_pos: T.unsafe(nil)); end

  def begin(); end

  def begin_pos(); end

  def column(); end

  def column_range(); end

  def contained?(other); end

  def contains?(other); end

  def crossing?(other); end

  def disjoint?(other); end

  def empty?(); end

  def end(); end

  def end_pos(); end

  def first_line(); end

  def initialize(source_buffer, begin_pos, end_pos); end

  def intersect(other); end

  def is?(*what); end

  def join(other); end

  def last_column(); end

  def last_line(); end

  def length(); end

  def line(); end

  def overlaps?(other); end

  def resize(new_size); end

  def size(); end

  def source(); end

  def source_buffer(); end

  def source_line(); end

  def to_a(); end

  def with(begin_pos: T.unsafe(nil), end_pos: T.unsafe(nil)); end
end

class Parser::Source::Range
end

class Parser::Source::Rewriter
  def diagnostics(); end

  def initialize(source_buffer); end

  def insert_after(range, content); end

  def insert_after_multi(range, content); end

  def insert_before(range, content); end

  def insert_before_multi(range, content); end

  def process(); end

  def remove(range); end

  def replace(range, content); end

  def source_buffer(); end

  def transaction(); end

  def wrap(range, before, after); end
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Rewriter::Action
  include ::Comparable
  def allow_multiple_insertions(); end

  def allow_multiple_insertions?(); end

  def initialize(range, replacement=T.unsafe(nil), allow_multiple_insertions=T.unsafe(nil), order=T.unsafe(nil)); end

  def order(); end

  def range(); end

  def replacement(); end
end

class Parser::Source::Rewriter::Action
end

class Parser::Source::Rewriter
  extend ::Parser::Deprecation
end

class Parser::Source::TreeRewriter
  def diagnostics(); end

  def in_transaction?(); end

  def initialize(source_buffer, crossing_deletions: T.unsafe(nil), different_replacements: T.unsafe(nil), swallowed_insertions: T.unsafe(nil)); end

  def insert_after(range, content); end

  def insert_after_multi(range, text); end

  def insert_before(range, content); end

  def insert_before_multi(range, text); end

  def process(); end

  def remove(range); end

  def replace(range, content); end

  def source_buffer(); end

  def transaction(); end

  def wrap(range, insert_before, insert_after); end
  ACTIONS = ::T.let(nil, ::T.untyped)
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
  POLICY_TO_LEVEL = ::T.let(nil, ::T.untyped)
end

class Parser::Source::TreeRewriter::Action
  def call_enforcer_for_merge(action); end

  def combine(action); end

  def do_combine(action); end

  def fuse_deletions(action, fusible, other_sibblings); end

  def initialize(range, enforcer, insert_before: T.unsafe(nil), replacement: T.unsafe(nil), insert_after: T.unsafe(nil), children: T.unsafe(nil)); end

  def insert_after(); end

  def insert_before(); end

  def insertion?(); end

  def merge(action); end

  def ordered_replacements(); end

  def place_in_hierachy(action); end

  def range(); end

  def relationship_with(action); end

  def replacement(); end

  def swallow(children); end

  def with(range: T.unsafe(nil), children: T.unsafe(nil), insert_before: T.unsafe(nil), replacement: T.unsafe(nil), insert_after: T.unsafe(nil)); end
end

class Parser::Source::TreeRewriter::Action
end

class Parser::Source::TreeRewriter
  extend ::Parser::Deprecation
end

module Parser::Source
end

class Parser::StaticEnvironment
  def declare(name); end

  def declare_forward_args(); end

  def declared?(name); end

  def declared_forward_args?(); end

  def extend_dynamic(); end

  def extend_static(); end

  def reset(); end

  def unextend(); end
  FORWARD_ARGS = ::T.let(nil, ::T.untyped)
end

class Parser::StaticEnvironment
end

class Parser::SyntaxError
  def diagnostic(); end

  def initialize(diagnostic); end
end

class Parser::SyntaxError
end

class Parser::TreeRewriter
  def assignment?(node); end

  def insert_after(range, content); end

  def insert_before(range, content); end

  def remove(range); end

  def replace(range, content); end

  def rewrite(source_buffer, ast, **policy); end

  def wrap(range, before, after); end
end

class Parser::TreeRewriter
end

class Parser::VariablesStack
  def declare(name); end

  def declared?(name); end

  def pop(); end

  def push(); end

  def reset(); end
end

class Parser::VariablesStack
end

module Parser
end

class Pathname
  def empty?(); end

  def fnmatch?(*_); end

  def glob(*_); end

  def make_symlink(_); end
end

class Proc
  def <<(_); end

  def ===(*_); end

  def >>(_); end

  def clone(); end

  def ruby2_keywords(); end

  def yield(*_); end
end

module Process
  CLOCK_MONOTONIC_RAW_APPROX = ::T.let(nil, ::T.untyped)
  CLOCK_UPTIME_RAW = ::T.let(nil, ::T.untyped)
  CLOCK_UPTIME_RAW_APPROX = ::T.let(nil, ::T.untyped)
end

module Process::Sys
  def self.getegid(); end
end

class Process::Tms
  def cstime(); end

  def cstime=(_); end

  def cutime(); end

  def cutime=(_); end

  def stime(); end

  def stime=(_); end

  def utime(); end

  def utime=(_); end
end

class Process::Tms
  def self.[](*_); end

  def self.members(); end
end

module Process
  def self.last_status(); end

  def self.setpgrp(); end
end

class ProgressBar
end

class ProgressBar::Base
  def autofinish(); end

  def autofinish=(autofinish); end

  def autostart(); end

  def autostart=(autostart); end

  def bar(); end

  def bar=(bar); end

  def clear(*args, &block); end

  def decrement(); end

  def finish(); end

  def finished(); end

  def finished=(finished); end

  def finished?(); end

  def format(other); end

  def format=(other); end

  def increment(); end

  def initialize(options=T.unsafe(nil)); end

  def log(*args, &block); end

  def output(); end

  def output=(output); end

  def pause(); end

  def paused?(); end

  def percentage(); end

  def percentage=(percentage); end

  def progress(*args, &block); end

  def progress=(new_progress); end

  def progress_mark=(mark); end

  def progressable(); end

  def progressable=(progressable); end

  def rate(); end

  def rate=(rate); end

  def refresh(*args, &block); end

  def remainder_mark=(mark); end

  def reset(); end

  def resume(); end

  def start(options=T.unsafe(nil)); end

  def started?(); end

  def stop(); end

  def stopped?(); end

  def time(); end

  def time=(time); end

  def timer(); end

  def timer=(timer); end

  def title(); end

  def title=(title); end

  def title_comp(); end

  def title_comp=(title_comp); end

  def to_h(); end

  def to_s(new_format=T.unsafe(nil)); end

  def total(*args, &block); end

  def total=(new_total); end

  def update_progress(*args); end
end

class ProgressBar::Base
  extend ::Forwardable
end

module ProgressBar::Calculators
end

class ProgressBar::Calculators::Length
  def calculate_length(); end

  def current_length(); end

  def current_length=(current_length); end

  def initialize(options=T.unsafe(nil)); end

  def length(); end

  def length_changed?(); end

  def length_override(); end

  def length_override=(other); end

  def output(); end

  def output=(output); end

  def reset_length(); end
end

class ProgressBar::Calculators::Length
end

class ProgressBar::Calculators::RunningAverage
end

class ProgressBar::Calculators::RunningAverage
  def self.calculate(current_average, new_value_to_average, smoothing_factor); end
end

module ProgressBar::Calculators
end

module ProgressBar::Components
end

class ProgressBar::Components::Bar
  def initialize(options=T.unsafe(nil)); end

  def length(); end

  def length=(length); end

  def progress(); end

  def progress=(progress); end

  def progress_mark(); end

  def progress_mark=(progress_mark); end

  def remainder_mark(); end

  def remainder_mark=(remainder_mark); end

  def to_s(options=T.unsafe(nil)); end

  def upa_steps(); end

  def upa_steps=(upa_steps); end
  DEFAULT_PROGRESS_MARK = ::T.let(nil, ::T.untyped)
  DEFAULT_REMAINDER_MARK = ::T.let(nil, ::T.untyped)
  DEFAULT_UPA_STEPS = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Bar
end

class ProgressBar::Components::Percentage
  def initialize(options=T.unsafe(nil)); end

  def progress(); end

  def progress=(progress); end
end

class ProgressBar::Components::Percentage
end

class ProgressBar::Components::Rate
  def initialize(options=T.unsafe(nil)); end

  def progress(); end

  def progress=(progress); end

  def rate_scale(); end

  def rate_scale=(rate_scale); end

  def started_at(); end

  def started_at=(started_at); end

  def stopped_at(); end

  def stopped_at=(stopped_at); end

  def timer(); end

  def timer=(timer); end
end

class ProgressBar::Components::Rate
end

class ProgressBar::Components::Time
  def elapsed_with_label(); end

  def estimated_with_friendly_oob(); end

  def estimated_with_label(); end

  def estimated_with_no_oob(); end

  def estimated_with_unknown_oob(); end

  def initialize(options=T.unsafe(nil)); end

  def out_of_bounds_time_format(); end

  def out_of_bounds_time_format=(format); end

  def progress(); end

  def progress=(progress); end

  def timer(); end

  def timer=(timer); end
  ELAPSED_LABEL = ::T.let(nil, ::T.untyped)
  ESTIMATED_LABEL = ::T.let(nil, ::T.untyped)
  NO_TIME_ELAPSED_TEXT = ::T.let(nil, ::T.untyped)
  OOB_FRIENDLY_TIME_TEXT = ::T.let(nil, ::T.untyped)
  OOB_LIMIT_IN_HOURS = ::T.let(nil, ::T.untyped)
  OOB_TIME_FORMATS = ::T.let(nil, ::T.untyped)
  OOB_UNKNOWN_TIME_TEXT = ::T.let(nil, ::T.untyped)
  TIME_FORMAT = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Time
end

class ProgressBar::Components::Title
  def initialize(options=T.unsafe(nil)); end

  def title(); end

  def title=(title); end
  DEFAULT_TITLE = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Title
end

module ProgressBar::Components
end

module ProgressBar::Format
end

class ProgressBar::Format::Formatter
end

class ProgressBar::Format::Formatter
  def self.process(format_string, max_length, bar); end
end

class ProgressBar::Format::Molecule
  def bar_molecule?(); end

  def full_key(); end

  def initialize(letter); end

  def key(); end

  def key=(key); end

  def lookup_value(environment, length=T.unsafe(nil)); end

  def method_name(); end

  def method_name=(method_name); end

  def non_bar_molecule?(); end
  BAR_MOLECULES = ::T.let(nil, ::T.untyped)
  MOLECULES = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Format::Molecule
end

class ProgressBar::Format::String
  def bar_molecule_placeholder_length(); end

  def bar_molecules(); end

  def displayable_length(); end

  def molecules(); end

  def non_bar_molecules(); end
  ANSI_SGR_PATTERN = ::T.let(nil, ::T.untyped)
  MOLECULE_PATTERN = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Format::String
end

module ProgressBar::Format
end

class ProgressBar::InvalidProgressError
end

class ProgressBar::InvalidProgressError
end

class ProgressBar::Output
  def bar(); end

  def bar=(bar); end

  def clear_string(); end

  def initialize(options=T.unsafe(nil)); end

  def length(); end

  def length_calculator(); end

  def length_calculator=(length_calculator); end

  def log(string); end

  def refresh(options=T.unsafe(nil)); end

  def stream(); end

  def stream=(stream); end

  def throttle(); end

  def throttle=(throttle); end

  def with_refresh(); end
  DEFAULT_OUTPUT_STREAM = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Output
  def self.detect(options=T.unsafe(nil)); end
end

module ProgressBar::Outputs
end

class ProgressBar::Outputs::NonTty
  def bar_update_string(); end

  def clear(); end

  def default_format(); end

  def eol(); end

  def last_update_length(); end

  def last_update_length=(last_update_length); end

  def refresh_with_format_change(*_); end

  def resolve_format(*_); end
  DEFAULT_FORMAT_STRING = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Outputs::NonTty
end

class ProgressBar::Outputs::Tty
  def bar_update_string(); end

  def clear(); end

  def default_format(); end

  def eol(); end

  def refresh_with_format_change(); end

  def resolve_format(other_format); end
  DEFAULT_FORMAT_STRING = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Outputs::Tty
end

module ProgressBar::Outputs
end

class ProgressBar::Progress
  def absolute(); end

  def decrement(); end

  def finish(); end

  def finished?(); end

  def increment(); end

  def initialize(options=T.unsafe(nil)); end

  def none?(); end

  def percentage_completed(); end

  def percentage_completed_with_precision(); end

  def progress(); end

  def progress=(new_progress); end

  def reset(); end

  def running_average(); end

  def running_average=(running_average); end

  def smoothing(); end

  def smoothing=(smoothing); end

  def start(options=T.unsafe(nil)); end

  def starting_position(); end

  def starting_position=(starting_position); end

  def total(); end

  def total=(new_total); end

  def total_with_unknown_indicator(); end

  def unknown?(); end
  DEFAULT_BEGINNING_POSITION = ::T.let(nil, ::T.untyped)
  DEFAULT_SMOOTHING = ::T.let(nil, ::T.untyped)
  DEFAULT_TOTAL = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Progress
end

module ProgressBar::Refinements
end

module ProgressBar::Refinements::Enumerator
end

module ProgressBar::Refinements::Enumerator
end

module ProgressBar::Refinements
end

class ProgressBar::Throttle
  def choke(options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def rate(); end

  def rate=(rate); end

  def started_at(); end

  def started_at=(started_at); end

  def stopped_at(); end

  def stopped_at=(stopped_at); end

  def timer(); end

  def timer=(timer); end
end

class ProgressBar::Throttle
end

class ProgressBar::Time
  def initialize(time=T.unsafe(nil)); end

  def now(); end

  def time(); end

  def time=(time); end

  def unmocked_time_method(); end
  TIME_MOCKING_LIBRARY_METHODS = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Time
end

class ProgressBar::Timer
  def divide_seconds(seconds); end

  def elapsed_seconds(); end

  def elapsed_whole_seconds(); end

  def initialize(options=T.unsafe(nil)); end

  def pause(); end

  def reset(); end

  def reset?(); end

  def restart(); end

  def resume(); end

  def start(); end

  def started?(); end

  def started_at(); end

  def started_at=(started_at); end

  def stop(); end

  def stopped?(); end

  def stopped_at(); end

  def stopped_at=(stopped_at); end

  def time(); end

  def time=(time); end
end

class ProgressBar::Timer
end

class ProgressBar
  def self.create(*args); end
end

module Psych
  LIBYAML_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Psych::BadAlias
end

class Psych::BadAlias
end

class Psych::ClassLoader
  def big_decimal(); end

  def complex(); end

  def date(); end

  def date_time(); end

  def exception(); end

  def load(klassname); end

  def object(); end

  def psych_omap(); end

  def psych_set(); end

  def range(); end

  def rational(); end

  def regexp(); end

  def struct(); end

  def symbol(); end

  def symbolize(sym); end
  BIG_DECIMAL = ::T.let(nil, ::T.untyped)
  CACHE = ::T.let(nil, ::T.untyped)
  COMPLEX = ::T.let(nil, ::T.untyped)
  DATE = ::T.let(nil, ::T.untyped)
  DATE_TIME = ::T.let(nil, ::T.untyped)
  EXCEPTION = ::T.let(nil, ::T.untyped)
  OBJECT = ::T.let(nil, ::T.untyped)
  PSYCH_OMAP = ::T.let(nil, ::T.untyped)
  PSYCH_SET = ::T.let(nil, ::T.untyped)
  RANGE = ::T.let(nil, ::T.untyped)
  RATIONAL = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
  STRUCT = ::T.let(nil, ::T.untyped)
  SYMBOL = ::T.let(nil, ::T.untyped)
end

class Psych::ClassLoader::Restricted
  def initialize(classes, symbols); end
end

class Psych::ClassLoader::Restricted
end

class Psych::ClassLoader
end

class Psych::Coder
  def [](k); end

  def []=(k, v); end

  def add(k, v); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(tag); end

  def map(tag=T.unsafe(nil), style=T.unsafe(nil)); end

  def map=(map); end

  def object(); end

  def object=(object); end

  def represent_map(tag, map); end

  def represent_object(tag, obj); end

  def represent_scalar(tag, value); end

  def represent_seq(tag, list); end

  def scalar(*args); end

  def scalar=(value); end

  def seq(); end

  def seq=(list); end

  def style(); end

  def style=(style); end

  def tag(); end

  def tag=(tag); end

  def type(); end
end

class Psych::Coder
end

class Psych::DisallowedClass
  def initialize(klass_name); end
end

class Psych::DisallowedClass
end

class Psych::Emitter
  def alias(_); end

  def canonical(); end

  def canonical=(canonical); end

  def end_document(_); end

  def indentation(); end

  def indentation=(indentation); end

  def initialize(*_); end

  def line_width(); end

  def line_width=(line_width); end

  def scalar(_, _1, _2, _3, _4, _5); end

  def start_document(_, _1, _2); end

  def start_mapping(_, _1, _2, _3); end

  def start_sequence(_, _1, _2, _3); end

  def start_stream(_); end
end

class Psych::Emitter
end

class Psych::Exception
end

class Psych::Exception
end

class Psych::Handler
  def alias(anchor); end

  def empty(); end

  def end_document(implicit); end

  def end_mapping(); end

  def end_sequence(); end

  def end_stream(); end

  def event_location(start_line, start_column, end_line, end_column); end

  def scalar(value, anchor, tag, plain, quoted, style); end

  def start_document(version, tag_directives, implicit); end

  def start_mapping(anchor, tag, implicit, style); end

  def start_sequence(anchor, tag, implicit, style); end

  def start_stream(encoding); end

  def streaming?(); end
  EVENTS = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
end

class Psych::Handler::DumperOptions
  def canonical(); end

  def canonical=(canonical); end

  def indentation(); end

  def indentation=(indentation); end

  def line_width(); end

  def line_width=(line_width); end
end

class Psych::Handler::DumperOptions
end

class Psych::Handler
end

module Psych::Handlers
end

class Psych::Handlers::DocumentStream
  def initialize(&block); end
end

class Psych::Handlers::DocumentStream
end

module Psych::Handlers
end

module Psych::JSON
end

module Psych::JSON::RubyEvents
  def visit_DateTime(o); end

  def visit_String(o); end

  def visit_Symbol(o); end

  def visit_Time(o); end
end

module Psych::JSON::RubyEvents
end

class Psych::JSON::Stream
  include ::Psych::Streaming
end

class Psych::JSON::Stream::Emitter
  include ::Psych::JSON::YAMLEvents
end

class Psych::JSON::Stream::Emitter
end

class Psych::JSON::Stream
  extend ::Psych::Streaming::ClassMethods
end

class Psych::JSON::TreeBuilder
  include ::Psych::JSON::YAMLEvents
end

class Psych::JSON::TreeBuilder
end

module Psych::JSON::YAMLEvents
  def end_document(implicit_end=T.unsafe(nil)); end

  def scalar(value, anchor, tag, plain, quoted, style); end

  def start_document(version, tag_directives, implicit); end

  def start_mapping(anchor, tag, implicit, style); end

  def start_sequence(anchor, tag, implicit, style); end
end

module Psych::JSON::YAMLEvents
end

module Psych::JSON
end

module Psych::Nodes
end

class Psych::Nodes::Alias
  def anchor(); end

  def anchor=(anchor); end

  def initialize(anchor); end
end

class Psych::Nodes::Alias
end

class Psych::Nodes::Document
  def implicit(); end

  def implicit=(implicit); end

  def implicit_end(); end

  def implicit_end=(implicit_end); end

  def initialize(version=T.unsafe(nil), tag_directives=T.unsafe(nil), implicit=T.unsafe(nil)); end

  def root(); end

  def tag_directives(); end

  def tag_directives=(tag_directives); end

  def version(); end

  def version=(version); end
end

class Psych::Nodes::Document
end

class Psych::Nodes::Mapping
  def anchor(); end

  def anchor=(anchor); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(anchor=T.unsafe(nil), tag=T.unsafe(nil), implicit=T.unsafe(nil), style=T.unsafe(nil)); end

  def style(); end

  def style=(style); end

  def tag=(tag); end
  ANY = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Mapping
end

class Psych::Nodes::Node
  include ::Enumerable
  def alias?(); end

  def children(); end

  def document?(); end

  def each(&block); end

  def end_column(); end

  def end_column=(end_column); end

  def end_line(); end

  def end_line=(end_line); end

  def mapping?(); end

  def scalar?(); end

  def sequence?(); end

  def start_column(); end

  def start_column=(start_column); end

  def start_line(); end

  def start_line=(start_line); end

  def stream?(); end

  def tag(); end

  def to_ruby(); end

  def to_yaml(io=T.unsafe(nil), options=T.unsafe(nil)); end

  def transform(); end

  def yaml(io=T.unsafe(nil), options=T.unsafe(nil)); end
end

class Psych::Nodes::Node
end

class Psych::Nodes::Scalar
  def anchor(); end

  def anchor=(anchor); end

  def initialize(value, anchor=T.unsafe(nil), tag=T.unsafe(nil), plain=T.unsafe(nil), quoted=T.unsafe(nil), style=T.unsafe(nil)); end

  def plain(); end

  def plain=(plain); end

  def quoted(); end

  def quoted=(quoted); end

  def style(); end

  def style=(style); end

  def tag=(tag); end

  def value(); end

  def value=(value); end
  ANY = ::T.let(nil, ::T.untyped)
  DOUBLE_QUOTED = ::T.let(nil, ::T.untyped)
  FOLDED = ::T.let(nil, ::T.untyped)
  LITERAL = ::T.let(nil, ::T.untyped)
  PLAIN = ::T.let(nil, ::T.untyped)
  SINGLE_QUOTED = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Scalar
end

class Psych::Nodes::Sequence
  def anchor(); end

  def anchor=(anchor); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(anchor=T.unsafe(nil), tag=T.unsafe(nil), implicit=T.unsafe(nil), style=T.unsafe(nil)); end

  def style(); end

  def style=(style); end

  def tag=(tag); end
  ANY = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Sequence
end

class Psych::Nodes::Stream
  def encoding(); end

  def encoding=(encoding); end

  def initialize(encoding=T.unsafe(nil)); end
  ANY = ::T.let(nil, ::T.untyped)
  UTF16BE = ::T.let(nil, ::T.untyped)
  UTF16LE = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Stream
end

module Psych::Nodes
end

class Psych::Omap
end

class Psych::Omap
end

class Psych::Parser
  def external_encoding=(external_encoding); end

  def handler(); end

  def handler=(handler); end

  def initialize(handler=T.unsafe(nil)); end

  def mark(); end

  def parse(*_); end
  ANY = ::T.let(nil, ::T.untyped)
  UTF16BE = ::T.let(nil, ::T.untyped)
  UTF16LE = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

class Psych::Parser::Mark
end

class Psych::Parser::Mark
end

class Psych::Parser
end

class Psych::ScalarScanner
  def class_loader(); end

  def initialize(class_loader); end

  def parse_int(string); end

  def parse_time(string); end

  def tokenize(string); end
  FLOAT = ::T.let(nil, ::T.untyped)
  INTEGER = ::T.let(nil, ::T.untyped)
  TIME = ::T.let(nil, ::T.untyped)
end

class Psych::ScalarScanner
end

class Psych::Set
end

class Psych::Set
end

class Psych::Stream
  include ::Psych::Streaming
end

class Psych::Stream::Emitter
  def end_document(implicit_end=T.unsafe(nil)); end
end

class Psych::Stream::Emitter
end

class Psych::Stream
  extend ::Psych::Streaming::ClassMethods
end

module Psych::Streaming
  def start(encoding=T.unsafe(nil)); end
end

module Psych::Streaming::ClassMethods
  def new(io); end
end

module Psych::Streaming::ClassMethods
end

module Psych::Streaming
end

class Psych::SyntaxError
  def column(); end

  def context(); end

  def file(); end

  def initialize(file, line, col, offset, problem, context); end

  def line(); end

  def offset(); end

  def problem(); end
end

class Psych::SyntaxError
end

class Psych::TreeBuilder
  def end_document(implicit_end=T.unsafe(nil)); end

  def root(); end
end

class Psych::TreeBuilder
end

module Psych::Visitors
end

class Psych::Visitors::DepthFirst
  def initialize(block); end
end

class Psych::Visitors::DepthFirst
end

class Psych::Visitors::Emitter
  def initialize(io, options=T.unsafe(nil)); end

  def visit_Psych_Nodes_Alias(o); end

  def visit_Psych_Nodes_Document(o); end

  def visit_Psych_Nodes_Mapping(o); end

  def visit_Psych_Nodes_Scalar(o); end

  def visit_Psych_Nodes_Sequence(o); end

  def visit_Psych_Nodes_Stream(o); end
end

class Psych::Visitors::Emitter
end

class Psych::Visitors::JSONTree
  include ::Psych::JSON::RubyEvents
end

class Psych::Visitors::JSONTree
  def self.create(options=T.unsafe(nil)); end
end

class Psych::Visitors::NoAliasRuby
end

class Psych::Visitors::NoAliasRuby
end

class Psych::Visitors::ToRuby
  def class_loader(); end

  def initialize(ss, class_loader); end

  def visit_Psych_Nodes_Alias(o); end

  def visit_Psych_Nodes_Document(o); end

  def visit_Psych_Nodes_Mapping(o); end

  def visit_Psych_Nodes_Scalar(o); end

  def visit_Psych_Nodes_Sequence(o); end

  def visit_Psych_Nodes_Stream(o); end
  SHOVEL = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::ToRuby
  def self.create(); end
end

class Psych::Visitors::Visitor
  def accept(target); end
  DISPATCH = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::Visitor
end

class Psych::Visitors::YAMLTree
  def <<(object); end

  def finish(); end

  def finished(); end

  def finished?(); end

  def initialize(emitter, ss, options); end

  def push(object); end

  def start(encoding=T.unsafe(nil)); end

  def started(); end

  def started?(); end

  def tree(); end

  def visit_Array(o); end

  def visit_BasicObject(o); end

  def visit_BigDecimal(o); end

  def visit_Class(o); end

  def visit_Complex(o); end

  def visit_Date(o); end

  def visit_DateTime(o); end

  def visit_Delegator(o); end

  def visit_Encoding(o); end

  def visit_Enumerator(o); end

  def visit_Exception(o); end

  def visit_FalseClass(o); end

  def visit_Float(o); end

  def visit_Hash(o); end

  def visit_Integer(o); end

  def visit_Module(o); end

  def visit_NameError(o); end

  def visit_NilClass(o); end

  def visit_Object(o); end

  def visit_Psych_Omap(o); end

  def visit_Psych_Set(o); end

  def visit_Range(o); end

  def visit_Rational(o); end

  def visit_Regexp(o); end

  def visit_String(o); end

  def visit_Struct(o); end

  def visit_Symbol(o); end

  def visit_Time(o); end

  def visit_TrueClass(o); end
end

class Psych::Visitors::YAMLTree
  def self.create(options=T.unsafe(nil), emitter=T.unsafe(nil)); end
end

module Psych::Visitors
end

module Psych
  def self.add_builtin_type(type_tag, &block); end

  def self.add_domain_type(domain, type_tag, &block); end

  def self.add_tag(tag, klass); end

  def self.domain_types(); end

  def self.domain_types=(domain_types); end

  def self.dump(o, io=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.dump_stream(*objects); end

  def self.dump_tags(); end

  def self.dump_tags=(dump_tags); end

  def self.libyaml_version(); end

  def self.load(yaml, legacy_filename=T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil), symbolize_names: T.unsafe(nil)); end

  def self.load_file(filename, fallback: T.unsafe(nil)); end

  def self.load_stream(yaml, legacy_filename=T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil)); end

  def self.load_tags(); end

  def self.load_tags=(load_tags); end

  def self.parse(yaml, legacy_filename=T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil)); end

  def self.parse_file(filename, fallback: T.unsafe(nil)); end

  def self.parse_stream(yaml, legacy_filename=T.unsafe(nil), filename: T.unsafe(nil), &block); end

  def self.parser(); end

  def self.remove_type(type_tag); end

  def self.safe_load(yaml, legacy_permitted_classes=T.unsafe(nil), legacy_permitted_symbols=T.unsafe(nil), legacy_aliases=T.unsafe(nil), legacy_filename=T.unsafe(nil), permitted_classes: T.unsafe(nil), permitted_symbols: T.unsafe(nil), aliases: T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil), symbolize_names: T.unsafe(nil)); end

  def self.to_json(object); end
end

module Racc
  Copyright = ::T.let(nil, ::T.untyped)
  Racc_No_Extentions = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Racc::CparseParams
end

class Racc::CparseParams
end

class Racc::Parser
  Racc_Main_Parsing_Routine = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Id_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Type = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Version = ::T.let(nil, ::T.untyped)
  Racc_YY_Parse_Method = ::T.let(nil, ::T.untyped)
end

module Rack
  CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  DELETE = ::T.let(nil, ::T.untyped)
  ETAG = ::T.let(nil, ::T.untyped)
  EXPIRES = ::T.let(nil, ::T.untyped)
  GET = ::T.let(nil, ::T.untyped)
  HEAD = ::T.let(nil, ::T.untyped)
  HTTPS = ::T.let(nil, ::T.untyped)
  HTTP_COOKIE = ::T.let(nil, ::T.untyped)
  HTTP_HOST = ::T.let(nil, ::T.untyped)
  HTTP_PORT = ::T.let(nil, ::T.untyped)
  HTTP_VERSION = ::T.let(nil, ::T.untyped)
  LINK = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  PATH_INFO = ::T.let(nil, ::T.untyped)
  POST = ::T.let(nil, ::T.untyped)
  PUT = ::T.let(nil, ::T.untyped)
  QUERY_STRING = ::T.let(nil, ::T.untyped)
  RACK_ERRORS = ::T.let(nil, ::T.untyped)
  RACK_HIJACK = ::T.let(nil, ::T.untyped)
  RACK_HIJACK_IO = ::T.let(nil, ::T.untyped)
  RACK_INPUT = ::T.let(nil, ::T.untyped)
  RACK_IS_HIJACK = ::T.let(nil, ::T.untyped)
  RACK_LOGGER = ::T.let(nil, ::T.untyped)
  RACK_METHODOVERRIDE_ORIGINAL_METHOD = ::T.let(nil, ::T.untyped)
  RACK_MULTIPART_BUFFER_SIZE = ::T.let(nil, ::T.untyped)
  RACK_MULTIPART_TEMPFILE_FACTORY = ::T.let(nil, ::T.untyped)
  RACK_MULTIPROCESS = ::T.let(nil, ::T.untyped)
  RACK_MULTITHREAD = ::T.let(nil, ::T.untyped)
  RACK_RECURSIVE_INCLUDE = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_COOKIE_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_COOKIE_STRING = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_INPUT = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_VARS = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_QUERY_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_QUERY_STRING = ::T.let(nil, ::T.untyped)
  RACK_RUNONCE = ::T.let(nil, ::T.untyped)
  RACK_SESSION = ::T.let(nil, ::T.untyped)
  RACK_SESSION_OPTIONS = ::T.let(nil, ::T.untyped)
  RACK_SESSION_UNPACKED_COOKIE_DATA = ::T.let(nil, ::T.untyped)
  RACK_SHOWSTATUS_DETAIL = ::T.let(nil, ::T.untyped)
  RACK_TEMPFILES = ::T.let(nil, ::T.untyped)
  RACK_URL_SCHEME = ::T.let(nil, ::T.untyped)
  RACK_VERSION = ::T.let(nil, ::T.untyped)
  RELEASE = ::T.let(nil, ::T.untyped)
  REQUEST_METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_PATH = ::T.let(nil, ::T.untyped)
  SCRIPT_NAME = ::T.let(nil, ::T.untyped)
  SERVER_NAME = ::T.let(nil, ::T.untyped)
  SERVER_PORT = ::T.let(nil, ::T.untyped)
  SERVER_PROTOCOL = ::T.let(nil, ::T.untyped)
  SET_COOKIE = ::T.let(nil, ::T.untyped)
  TRACE = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING = ::T.let(nil, ::T.untyped)
  UNLINK = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Rack::Auth
end

class Rack::Auth::AbstractHandler
  def initialize(app, realm=T.unsafe(nil), &authenticator); end

  def realm(); end

  def realm=(realm); end
end

class Rack::Auth::AbstractHandler
end

class Rack::Auth::AbstractRequest
  def initialize(env); end

  def params(); end

  def parts(); end

  def provided?(); end

  def request(); end

  def scheme(); end

  def valid?(); end
  AUTHORIZATION_KEYS = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::AbstractRequest
end

class Rack::Auth::Basic
  def call(env); end
end

class Rack::Auth::Basic::Request
  def basic?(); end

  def credentials(); end

  def username(); end
end

class Rack::Auth::Basic::Request
end

class Rack::Auth::Basic
end

module Rack::Auth::Digest
end

class Rack::Auth::Digest::MD5
  def call(env); end

  def initialize(app, realm=T.unsafe(nil), opaque=T.unsafe(nil), &authenticator); end

  def opaque(); end

  def opaque=(opaque); end

  def passwords_hashed=(passwords_hashed); end

  def passwords_hashed?(); end
  QOP = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::Digest::MD5
end

class Rack::Auth::Digest::Nonce
  def digest(); end

  def fresh?(); end

  def initialize(timestamp=T.unsafe(nil), given_digest=T.unsafe(nil)); end

  def stale?(); end

  def valid?(); end
end

class Rack::Auth::Digest::Nonce
  def self.parse(string); end

  def self.private_key(); end

  def self.private_key=(private_key); end

  def self.time_limit(); end

  def self.time_limit=(time_limit); end
end

class Rack::Auth::Digest::Params
  def [](k); end

  def []=(k, v); end

  def initialize(); end

  def quote(str); end
  UNQUOTED = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::Digest::Params
  def self.dequote(str); end

  def self.parse(str); end

  def self.split_header_value(str); end
end

class Rack::Auth::Digest::Request
  def correct_uri?(); end

  def digest?(); end

  def method(); end

  def method_missing(sym, *args); end

  def nonce(); end

  def respond_to?(sym, *_); end
end

class Rack::Auth::Digest::Request
end

module Rack::Auth::Digest
end

module Rack::Auth
end

class Rack::BodyProxy
  def close(); end

  def closed?(); end

  def initialize(body, &block); end

  def method_missing(method_name, *args, &block); end
end

class Rack::BodyProxy
end

class Rack::Builder
  include ::Sinatra::Delegator
  def call(env); end

  def freeze_app(); end

  def initialize(default_app=T.unsafe(nil), &block); end

  def map(path, &block); end

  def run(app); end

  def to_app(); end

  def use(middleware, *args, &block); end

  def warmup(prc=T.unsafe(nil), &block); end
  UTF_8_BOM = ::T.let(nil, ::T.untyped)
end

class Rack::Builder
  def self.app(default_app=T.unsafe(nil), &block); end

  def self.load_file(path, opts=T.unsafe(nil)); end

  def self.new_from_string(builder_script, file=T.unsafe(nil)); end

  def self.parse_file(config, opts=T.unsafe(nil)); end
end

class Rack::Cascade
  def <<(app); end

  def add(app); end

  def apps(); end

  def call(env); end

  def include?(app); end

  def initialize(apps, cascade_for=T.unsafe(nil)); end
  NotFound = ::T.let(nil, ::T.untyped)
end

class Rack::Cascade
end

class Rack::Chunked
  include ::Rack::Utils
  def call(env); end

  def chunkable_version?(ver); end

  def initialize(app); end
end

class Rack::Chunked::Body
  def close(); end

  def each(&block); end

  def initialize(body); end
  TAIL = ::T.let(nil, ::T.untyped)
  TERM = ::T.let(nil, ::T.untyped)
end

class Rack::Chunked::Body
end

class Rack::Chunked::TrailerBody
end

class Rack::Chunked::TrailerBody
end

class Rack::Chunked
end

class Rack::CommonLogger
  def call(env); end

  def call_without_check(env); end

  def initialize(app, logger=T.unsafe(nil)); end
  FORMAT = ::T.let(nil, ::T.untyped)
end

class Rack::CommonLogger
end

class Rack::ConditionalGet
  def call(env); end

  def initialize(app); end
end

class Rack::ConditionalGet
end

class Rack::Config
  def call(env); end

  def initialize(app, &block); end
end

class Rack::Config
end

class Rack::ContentLength
  include ::Rack::Utils
  def call(env); end

  def initialize(app); end
end

class Rack::ContentLength
end

class Rack::ContentType
  include ::Rack::Utils
  def call(env); end

  def initialize(app, content_type=T.unsafe(nil)); end
end

class Rack::ContentType
end

class Rack::Deflater
  def call(env); end

  def initialize(app, options=T.unsafe(nil)); end
end

class Rack::Deflater::GzipStream
  def close(); end

  def each(&block); end

  def initialize(body, mtime, sync); end

  def write(data); end
end

class Rack::Deflater::GzipStream
end

class Rack::Deflater
end

class Rack::Directory
  def call(env); end

  def check_bad_request(path_info); end

  def check_forbidden(path_info); end

  def entity_not_found(path_info); end

  def filesize_format(int); end

  def get(env); end

  def initialize(root, app=T.unsafe(nil)); end

  def list_directory(path_info, path, script_name); end

  def list_path(env, path, path_info, script_name); end

  def root(); end

  def stat(path); end
  DIR_FILE = ::T.let(nil, ::T.untyped)
  DIR_PAGE_FOOTER = ::T.let(nil, ::T.untyped)
  DIR_PAGE_HEADER = ::T.let(nil, ::T.untyped)
  FILESIZE_FORMAT = ::T.let(nil, ::T.untyped)
end

class Rack::Directory::DirectoryBody
end

class Rack::Directory::DirectoryBody
end

class Rack::Directory
end

class Rack::ETag
  def call(env); end

  def initialize(app, no_cache_control=T.unsafe(nil), cache_control=T.unsafe(nil)); end
  DEFAULT_CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  ETAG_STRING = ::T.let(nil, ::T.untyped)
end

class Rack::ETag
end

class Rack::Events
  def call(env); end

  def initialize(app, handlers); end
end

module Rack::Events::Abstract
  def on_commit(req, res); end

  def on_error(req, res, e); end

  def on_finish(req, res); end

  def on_send(req, res); end

  def on_start(req, res); end
end

module Rack::Events::Abstract
end

class Rack::Events::BufferedResponse
  def body(); end

  def initialize(status, headers, body); end

  def to_a(); end
end

class Rack::Events::BufferedResponse
end

class Rack::Events::EventedBodyProxy
  def each(&blk); end

  def initialize(body, request, response, handlers, &block); end

  def request(); end

  def response(); end
end

class Rack::Events::EventedBodyProxy
end

class Rack::Events
end

Rack::File = Rack::Files

class Rack::Files
  def call(env); end

  def get(env); end

  def initialize(root, headers=T.unsafe(nil), default_mime=T.unsafe(nil)); end

  def root(); end

  def serving(request, path); end
  ALLOWED_VERBS = ::T.let(nil, ::T.untyped)
  ALLOW_HEADER = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
end

class Rack::Files::BaseIterator
  def bytesize(); end

  def close(); end

  def each(&blk); end

  def initialize(path, ranges, options); end

  def options(); end

  def path(); end

  def ranges(); end
end

class Rack::Files::BaseIterator
end

class Rack::Files::Iterator
  def to_path(); end
end

class Rack::Files::Iterator
end

class Rack::Files
  def self.method_added(name); end
end

class Rack::ForwardRequest
  def env(); end

  def initialize(url, env=T.unsafe(nil)); end

  def url(); end
end

class Rack::ForwardRequest
end

module Rack::Handler
end

class Rack::Handler::CGI
end

class Rack::Handler::CGI
  def self.run(app, **options); end

  def self.send_body(body); end

  def self.send_headers(status, headers); end

  def self.serve(app); end
end

class Rack::Handler::WEBrick
  def initialize(server, app); end
end

class Rack::Handler::WEBrick
  def self.run(app, **options); end

  def self.shutdown(); end

  def self.valid_options(); end
end

module Rack::Handler
  def self.default(); end

  def self.get(server); end

  def self.pick(server_names); end

  def self.register(server, klass); end

  def self.try_require(prefix, const_name); end
end

class Rack::Head
  def call(env); end

  def initialize(app); end
end

class Rack::Head
end

class Rack::Lint
  include ::Rack::Lint::Assertion
  def _call(env); end

  def call(env=T.unsafe(nil)); end

  def check_content_length(status, headers); end

  def check_content_type(status, headers); end

  def check_env(env); end

  def check_error(error); end

  def check_headers(header); end

  def check_hijack(env); end

  def check_hijack_response(headers, env); end

  def check_input(input); end

  def check_status(status); end

  def close(); end

  def each(&blk); end

  def initialize(app); end

  def verify_content_length(bytes); end
end

module Rack::Lint::Assertion
  def assert(message); end
end

module Rack::Lint::Assertion
end

class Rack::Lint::ErrorWrapper
  include ::Rack::Lint::Assertion
  def close(*args); end

  def flush(); end

  def initialize(error); end

  def puts(str); end

  def write(str); end
end

class Rack::Lint::ErrorWrapper
end

class Rack::Lint::HijackWrapper
  include ::Rack::Lint::Assertion
  def close(*args, &block); end

  def close_read(*args, &block); end

  def close_write(*args, &block); end

  def closed?(*args, &block); end

  def flush(*args, &block); end

  def initialize(io); end

  def read(*args, &block); end

  def read_nonblock(*args, &block); end

  def write(*args, &block); end

  def write_nonblock(*args, &block); end
  REQUIRED_METHODS = ::T.let(nil, ::T.untyped)
end

class Rack::Lint::HijackWrapper
  extend ::Forwardable
end

class Rack::Lint::InputWrapper
  include ::Rack::Lint::Assertion
  def close(*args); end

  def each(*args, &blk); end

  def gets(*args); end

  def initialize(input); end

  def read(*args); end

  def rewind(*args); end
end

class Rack::Lint::InputWrapper
end

class Rack::Lint::LintError
end

class Rack::Lint::LintError
end

class Rack::Lint
end

class Rack::Lock
  def call(env); end

  def initialize(app, mutex=T.unsafe(nil)); end
end

class Rack::Lock
end

class Rack::Logger
  def call(env); end

  def initialize(app, level=T.unsafe(nil)); end
end

class Rack::Logger
end

class Rack::MediaType
  SPLIT_PATTERN = ::T.let(nil, ::T.untyped)
end

class Rack::MediaType
  def self.params(content_type); end

  def self.type(content_type); end
end

class Rack::MethodOverride
  def call(env); end

  def initialize(app); end

  def method_override(env); end
  ALLOWED_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHOD_OVERRIDE_HEADER = ::T.let(nil, ::T.untyped)
  METHOD_OVERRIDE_PARAM_KEY = ::T.let(nil, ::T.untyped)
end

class Rack::MethodOverride
end

module Rack::Mime
  MIME_TYPES = ::T.let(nil, ::T.untyped)
end

module Rack::Mime
  def self.match?(value, matcher); end

  def self.mime_type(ext, fallback=T.unsafe(nil)); end
end

class Rack::MockRequest
  def delete(uri, opts=T.unsafe(nil)); end

  def get(uri, opts=T.unsafe(nil)); end

  def head(uri, opts=T.unsafe(nil)); end

  def initialize(app); end

  def options(uri, opts=T.unsafe(nil)); end

  def patch(uri, opts=T.unsafe(nil)); end

  def post(uri, opts=T.unsafe(nil)); end

  def put(uri, opts=T.unsafe(nil)); end

  def request(method=T.unsafe(nil), uri=T.unsafe(nil), opts=T.unsafe(nil)); end
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
end

class Rack::MockRequest::FatalWarner
  def flush(); end

  def puts(warning); end

  def string(); end

  def write(warning); end
end

class Rack::MockRequest::FatalWarner
end

class Rack::MockRequest::FatalWarning
end

class Rack::MockRequest::FatalWarning
end

class Rack::MockRequest
  def self.env_for(uri=T.unsafe(nil), opts=T.unsafe(nil)); end

  def self.parse_uri_rfc2396(uri); end
end

class Rack::MockResponse
  def =~(other); end

  def cookie(name); end

  def cookies(); end

  def errors(); end

  def errors=(errors); end

  def initialize(status, headers, body, errors=T.unsafe(nil)); end

  def match(other); end

  def original_headers(); end
end

class Rack::MockResponse
  def self.[](*_); end
end

module Rack::Multipart
  ATTRIBUTE = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_CHAR = ::T.let(nil, ::T.untyped)
  BROKEN_QUOTED = ::T.let(nil, ::T.untyped)
  BROKEN_UNQUOTED = ::T.let(nil, ::T.untyped)
  CONDISP = ::T.let(nil, ::T.untyped)
  DISPPARM = ::T.let(nil, ::T.untyped)
  EOL = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_NAME = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_PARAMETER = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_VALUE = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_NAME = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_PARAMETER = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_VALUE = ::T.let(nil, ::T.untyped)
  EXTENDED_PARAMETER = ::T.let(nil, ::T.untyped)
  MULTIPART = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_DISPOSITION = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_ID = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  REGULAR_PARAMETER = ::T.let(nil, ::T.untyped)
  REGULAR_PARAMETER_NAME = ::T.let(nil, ::T.untyped)
  RFC2183 = ::T.let(nil, ::T.untyped)
  SECTION = ::T.let(nil, ::T.untyped)
  TOKEN = ::T.let(nil, ::T.untyped)
  VALUE = ::T.let(nil, ::T.untyped)
end

class Rack::Multipart::Generator
  def dump(); end

  def initialize(params, first=T.unsafe(nil)); end
end

class Rack::Multipart::Generator
end

class Rack::Multipart::MultipartPartLimitError
end

class Rack::Multipart::MultipartPartLimitError
end

class Rack::Multipart::Parser
  def initialize(boundary, tempfile, bufsize, query_parser); end

  def on_read(content); end

  def result(); end

  def state(); end
  BOUNDARY_REGEX = ::T.let(nil, ::T.untyped)
  BUFSIZE = ::T.let(nil, ::T.untyped)
  CHARSET = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  TEMPFILE_FACTORY = ::T.let(nil, ::T.untyped)
  TEXT_PLAIN = ::T.let(nil, ::T.untyped)
end

class Rack::Multipart::Parser::BoundedIO
  def initialize(io, content_length); end

  def read(size, outbuf=T.unsafe(nil)); end

  def rewind(); end
end

class Rack::Multipart::Parser::BoundedIO
end

class Rack::Multipart::Parser::Collector
  include ::Enumerable
  def each(&blk); end

  def initialize(tempfile); end

  def on_mime_body(mime_index, content); end

  def on_mime_finish(mime_index); end

  def on_mime_head(mime_index, head, filename, content_type, name); end
end

class Rack::Multipart::Parser::Collector::BufferPart
  def close(); end

  def file?(); end
end

class Rack::Multipart::Parser::Collector::BufferPart
end

class Rack::Multipart::Parser::Collector::MimePart
  def get_data(); end
end

class Rack::Multipart::Parser::Collector::MimePart
end

class Rack::Multipart::Parser::Collector::TempfilePart
  def close(); end

  def file?(); end
end

class Rack::Multipart::Parser::Collector::TempfilePart
end

class Rack::Multipart::Parser::Collector
end

class Rack::Multipart::Parser::MultipartInfo
  def params(); end

  def params=(_); end

  def tmp_files(); end

  def tmp_files=(_); end
end

class Rack::Multipart::Parser::MultipartInfo
  def self.[](*_); end

  def self.members(); end
end

class Rack::Multipart::Parser
  def self.parse(io, content_length, content_type, tmpfile, bufsize, qp); end

  def self.parse_boundary(content_type); end
end

class Rack::Multipart::UploadedFile
  def content_type(); end

  def content_type=(content_type); end

  def initialize(filepath=T.unsafe(nil), ct=T.unsafe(nil), bin=T.unsafe(nil), path: T.unsafe(nil), content_type: T.unsafe(nil), binary: T.unsafe(nil), filename: T.unsafe(nil), io: T.unsafe(nil)); end

  def local_path(); end

  def method_missing(method_name, *args, &block); end

  def original_filename(); end

  def path(); end

  def respond_to?(*args); end
end

class Rack::Multipart::UploadedFile
end

module Rack::Multipart
  def self.build_multipart(params, first=T.unsafe(nil)); end

  def self.extract_multipart(req, params=T.unsafe(nil)); end

  def self.parse_multipart(env, params=T.unsafe(nil)); end
end

class Rack::NullLogger
  def <<(msg); end

  def add(severity, message=T.unsafe(nil), progname=T.unsafe(nil), &block); end

  def call(env); end

  def close(); end

  def datetime_format(); end

  def datetime_format=(datetime_format); end

  def debug(progname=T.unsafe(nil), &block); end

  def debug?(); end

  def error(progname=T.unsafe(nil), &block); end

  def error?(); end

  def fatal(progname=T.unsafe(nil), &block); end

  def fatal?(); end

  def formatter(); end

  def formatter=(formatter); end

  def info(progname=T.unsafe(nil), &block); end

  def info?(); end

  def initialize(app); end

  def level(); end

  def level=(level); end

  def progname(); end

  def progname=(progname); end

  def sev_threshold(); end

  def sev_threshold=(sev_threshold); end

  def unknown(progname=T.unsafe(nil), &block); end

  def warn(progname=T.unsafe(nil), &block); end

  def warn?(); end
end

class Rack::NullLogger
end

module Rack::Protection
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::Protection::AuthenticityToken
  def mask_authenticity_token(session); end
  TOKEN_LENGTH = ::T.let(nil, ::T.untyped)
end

class Rack::Protection::AuthenticityToken
  def self.random_token(); end

  def self.token(session); end
end

class Rack::Protection::Base
  def accepts?(env); end

  def app(); end

  def call(env); end

  def default_options(); end

  def default_reaction(env); end

  def deny(env); end

  def drop_session(env); end

  def encrypt(value); end

  def html?(headers); end

  def initialize(app, options=T.unsafe(nil)); end

  def instrument(env); end

  def options(); end

  def origin(env); end

  def random_string(secure=T.unsafe(nil)); end

  def react(env); end

  def referrer(env); end

  def report(env); end

  def safe?(env); end

  def secure_compare(a, b); end

  def session(env); end

  def session?(env); end

  def warn(env, message); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rack::Protection::Base
  def self.default_options(options); end

  def self.default_reaction(reaction); end
end

class Rack::Protection::ContentSecurityPolicy
  def csp_policy(); end
  DIRECTIVES = ::T.let(nil, ::T.untyped)
  NO_ARG_DIRECTIVES = ::T.let(nil, ::T.untyped)
end

class Rack::Protection::ContentSecurityPolicy
end

class Rack::Protection::CookieTossing
  def bad_cookies(); end

  def cookie_paths(path); end

  def empty_cookie(host, path); end

  def redirect(env); end

  def remove_bad_cookies(request, response); end

  def session_key(); end
end

class Rack::Protection::CookieTossing
end

class Rack::Protection::EscapedParams
  def escape(object); end

  def escape_hash(hash); end

  def escape_string(str); end

  def handle(hash); end

  def initialize(*_); end
end

class Rack::Protection::EscapedParams
  extend ::Rack::Utils
end

class Rack::Protection::FormToken
end

class Rack::Protection::FormToken
end

class Rack::Protection::FrameOptions
  def frame_options(); end
end

class Rack::Protection::FrameOptions
end

class Rack::Protection::HttpOrigin
  def base_url(env); end
  DEFAULT_PORTS = ::T.let(nil, ::T.untyped)
end

class Rack::Protection::HttpOrigin
end

class Rack::Protection::IPSpoofing
end

class Rack::Protection::IPSpoofing
end

class Rack::Protection::JsonCsrf
  def close_body(body); end

  def has_vector?(request, headers); end

  def react_and_close(env, body); end
end

class Rack::Protection::JsonCsrf
end

class Rack::Protection::PathTraversal
  def cleanup(path); end
end

class Rack::Protection::PathTraversal
end

class Rack::Protection::RemoteReferrer
end

class Rack::Protection::RemoteReferrer
end

class Rack::Protection::RemoteToken
end

class Rack::Protection::RemoteToken
end

class Rack::Protection::SessionHijacking
end

class Rack::Protection::SessionHijacking
end

class Rack::Protection::StrictTransport
  def strict_transport(); end
end

class Rack::Protection::StrictTransport
end

class Rack::Protection::XSSHeader
end

class Rack::Protection::XSSHeader
end

module Rack::Protection
  def self.new(app, options=T.unsafe(nil)); end
end

class Rack::QueryParser
  def initialize(params_class, key_space_limit, param_depth_limit); end

  def key_space_limit(); end

  def make_params(); end

  def new_depth_limit(param_depth_limit); end

  def new_space_limit(key_space_limit); end

  def normalize_params(params, name, v, depth); end

  def param_depth_limit(); end

  def parse_nested_query(qs, d=T.unsafe(nil)); end

  def parse_query(qs, d=T.unsafe(nil), &unescaper); end
  COMMON_SEP = ::T.let(nil, ::T.untyped)
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
end

class Rack::QueryParser::InvalidParameterError
end

class Rack::QueryParser::InvalidParameterError
end

class Rack::QueryParser::ParameterTypeError
end

class Rack::QueryParser::ParameterTypeError
end

class Rack::QueryParser::Params
  def [](key); end

  def []=(key, value); end

  def initialize(limit); end

  def key?(key); end

  def to_h(); end

  def to_params_hash(); end
end

class Rack::QueryParser::Params
end

class Rack::QueryParser
  def self.make_default(key_space_limit, param_depth_limit); end
end

class Rack::Recursive
  def _call(env); end

  def call(env); end

  def include(env, path); end

  def initialize(app); end
end

class Rack::Recursive
end

class Rack::Reloader
  def call(env); end

  def initialize(app, cooldown=T.unsafe(nil), backend=T.unsafe(nil)); end

  def reload!(stderr=T.unsafe(nil)); end

  def safe_load(file, mtime, stderr=T.unsafe(nil)); end
end

module Rack::Reloader::Stat
  def figure_path(file, paths); end

  def rotation(); end

  def safe_stat(file); end
end

module Rack::Reloader::Stat
end

class Rack::Reloader
end

class Rack::Request
  include ::Rack::Request::Env
  include ::Rack::Request::Helpers
  ALLOWED_SCHEMES = ::T.let(nil, ::T.untyped)
  SCHEME_WHITELIST = ::T.let(nil, ::T.untyped)
end

module Rack::Request::Env
  def add_header(key, v); end

  def delete_header(name); end

  def each_header(&block); end

  def env(); end

  def fetch_header(name, &block); end

  def get_header(name); end

  def has_header?(name); end

  def initialize(env); end

  def set_header(name, v); end
end

module Rack::Request::Env
end

module Rack::Request::Helpers
  def GET(); end

  def POST(); end

  def [](key); end

  def []=(key, value); end

  def accept_encoding(); end

  def accept_language(); end

  def authority(); end

  def base_url(); end

  def body(); end

  def content_charset(); end

  def content_length(); end

  def content_type(); end

  def cookies(); end

  def delete?(); end

  def delete_param(k); end

  def form_data?(); end

  def forwarded_authority(); end

  def forwarded_for(); end

  def forwarded_port(); end

  def fullpath(); end

  def get?(); end

  def head?(); end

  def host(); end

  def host_authority(); end

  def host_with_port(authority=T.unsafe(nil)); end

  def hostname(); end

  def ip(); end

  def link?(); end

  def logger(); end

  def media_type(); end

  def media_type_params(); end

  def multithread?(); end

  def options?(); end

  def params(); end

  def parseable_data?(); end

  def patch?(); end

  def path(); end

  def path_info(); end

  def path_info=(s); end

  def port(); end

  def post?(); end

  def put?(); end

  def query_string(); end

  def referer(); end

  def referrer(); end

  def request_method(); end

  def scheme(); end

  def script_name(); end

  def script_name=(s); end

  def server_authority(); end

  def server_name(); end

  def server_port(); end

  def session(); end

  def session_options(); end

  def ssl?(); end

  def trace?(); end

  def trusted_proxy?(ip); end

  def unlink?(); end

  def update_param(k, v); end

  def url(); end

  def user_agent(); end

  def values_at(*keys); end

  def xhr?(); end
  DEFAULT_PORTS = ::T.let(nil, ::T.untyped)
  FORM_DATA_MEDIA_TYPES = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_FOR = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_HOST = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_PORT = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_PROTO = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SCHEME = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SSL = ::T.let(nil, ::T.untyped)
  PARSEABLE_DATA_MEDIA_TYPES = ::T.let(nil, ::T.untyped)
end

module Rack::Request::Helpers
end

class Rack::Request
  def self.ip_filter(); end

  def self.ip_filter=(ip_filter); end
end

class Rack::Response
  include ::Rack::Response::Helpers
  def [](key); end

  def []=(key, v); end

  def body(); end

  def body=(body); end

  def chunked?(); end

  def close(); end

  def delete_header(key); end

  def each(&callback); end

  def empty?(); end

  def finish(&block); end

  def get_header(key); end

  def has_header?(key); end

  def header(); end

  def headers(); end

  def initialize(body=T.unsafe(nil), status=T.unsafe(nil), headers=T.unsafe(nil)); end

  def length(); end

  def length=(length); end

  def redirect(target, status=T.unsafe(nil)); end

  def set_header(key, v); end

  def status(); end

  def status=(status); end

  def to_a(&block); end

  def write(chunk); end
  CHUNKED = ::T.let(nil, ::T.untyped)
  STATUS_WITH_NO_ENTITY_BODY = ::T.let(nil, ::T.untyped)
end

module Rack::Response::Helpers
  def accepted?(); end

  def add_header(key, v); end

  def append(chunk); end

  def bad_request?(); end

  def buffered_body!(); end

  def cache!(duration=T.unsafe(nil), directive: T.unsafe(nil)); end

  def cache_control(); end

  def cache_control=(v); end

  def client_error?(); end

  def content_length(); end

  def content_type(); end

  def content_type=(content_type); end

  def created?(); end

  def delete_cookie(key, value=T.unsafe(nil)); end

  def do_not_cache!(); end

  def etag(); end

  def etag=(v); end

  def forbidden?(); end

  def include?(header); end

  def informational?(); end

  def invalid?(); end

  def location(); end

  def location=(location); end

  def media_type(); end

  def media_type_params(); end

  def method_not_allowed?(); end

  def moved_permanently?(); end

  def no_content?(); end

  def not_found?(); end

  def ok?(); end

  def precondition_failed?(); end

  def redirect?(); end

  def redirection?(); end

  def server_error?(); end

  def set_cookie(key, value); end

  def set_cookie_header(); end

  def set_cookie_header=(v); end

  def successful?(); end

  def unauthorized?(); end

  def unprocessable?(); end
end

module Rack::Response::Helpers
end

class Rack::Response::Raw
  include ::Rack::Response::Helpers
  def delete_header(key); end

  def get_header(key); end

  def has_header?(key); end

  def headers(); end

  def initialize(status, headers); end

  def set_header(key, v); end

  def status(); end

  def status=(status); end
end

class Rack::Response::Raw
end

class Rack::Response
  def self.[](status, headers, body); end
end

class Rack::RewindableInput
  def close(); end

  def each(&block); end

  def gets(); end

  def initialize(io); end

  def read(*args); end

  def rewind(); end
end

class Rack::RewindableInput
end

class Rack::Runtime
  def call(env); end

  def initialize(app, name=T.unsafe(nil)); end
  FORMAT_STRING = ::T.let(nil, ::T.untyped)
  HEADER_NAME = ::T.let(nil, ::T.untyped)
end

class Rack::Runtime
end

class Rack::Sendfile
  def call(env); end

  def initialize(app, variation=T.unsafe(nil), mappings=T.unsafe(nil)); end
end

class Rack::Sendfile
end

class Rack::Server
  def app(); end

  def default_options(); end

  def initialize(options=T.unsafe(nil)); end

  def middleware(); end

  def options(); end

  def options=(options); end

  def server(); end

  def start(&block); end
end

class Rack::Server::Options
  def handler_opts(options); end

  def parse!(args); end
end

class Rack::Server::Options
end

class Rack::Server
  def self.default_middleware_by_environment(); end

  def self.logging_middleware(); end

  def self.middleware(); end

  def self.start(options=T.unsafe(nil)); end
end

module Rack::Session
end

module Rack::Session::Abstract
end

class Rack::Session::Abstract::ID
  def find_session(req, sid); end
end

class Rack::Session::Abstract::ID
  def self.inherited(klass); end
end

class Rack::Session::Abstract::Persisted
  def call(env); end

  def commit_session(req, res); end

  def context(env, app=T.unsafe(nil)); end

  def default_options(); end

  def initialize(app, options=T.unsafe(nil)); end

  def key(); end

  def sid_secure(); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Abstract::Persisted
end

class Rack::Session::Abstract::PersistedSecure
  def extract_session_id(*_); end

  def generate_sid(*_); end
end

class Rack::Session::Abstract::PersistedSecure::SecureSessionHash
end

class Rack::Session::Abstract::PersistedSecure::SecureSessionHash
end

class Rack::Session::Abstract::PersistedSecure
end

class Rack::Session::Abstract::SessionHash
  include ::Enumerable
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def delete(key); end

  def destroy(); end

  def dig(key, *keys); end

  def each(&block); end

  def empty?(); end

  def exists?(); end

  def fetch(key, default=T.unsafe(nil), &block); end

  def has_key?(key); end

  def id(); end

  def id=(id); end

  def include?(key); end

  def initialize(store, req); end

  def key?(key); end

  def keys(); end

  def loaded?(); end

  def merge!(hash); end

  def options(); end

  def replace(hash); end

  def store(key, value); end

  def to_hash(); end

  def update(hash); end

  def values(); end
  Unspecified = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Abstract::SessionHash
  def self.find(req); end

  def self.set(req, session); end

  def self.set_options(req, options); end
end

module Rack::Session::Abstract
end

class Rack::Session::Cookie
  def coder(); end
end

class Rack::Session::Cookie::Base64
  def decode(str); end

  def encode(str); end
end

class Rack::Session::Cookie::Base64::JSON
  def encode(obj); end
end

class Rack::Session::Cookie::Base64::JSON
end

class Rack::Session::Cookie::Base64::Marshal
end

class Rack::Session::Cookie::Base64::Marshal
end

class Rack::Session::Cookie::Base64::ZipJSON
  def encode(obj); end
end

class Rack::Session::Cookie::Base64::ZipJSON
end

class Rack::Session::Cookie::Base64
end

class Rack::Session::Cookie::Identity
  def decode(str); end

  def encode(str); end
end

class Rack::Session::Cookie::Identity
end

class Rack::Session::Cookie::SessionId
  def cookie_value(); end

  def initialize(session_id, cookie_value); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Cookie::SessionId
end

class Rack::Session::Cookie
end

class Rack::Session::Pool
  def delete_session(req, session_id, options); end

  def find_session(req, sid); end

  def generate_sid(); end

  def mutex(); end

  def pool(); end

  def with_lock(req); end

  def write_session(req, session_id, new_session, options); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Pool
end

class Rack::Session::SessionId
  def cookie_value(); end

  def empty?(); end

  def initialize(public_id); end

  def private_id(); end

  def public_id(); end
  ID_VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::Session::SessionId
end

module Rack::Session
end

class Rack::ShowExceptions
  def call(env); end

  def dump_exception(exception); end

  def h(obj); end

  def initialize(app); end

  def prefers_plaintext?(env); end

  def pretty(env, exception); end

  def template(); end
  CONTEXT = ::T.let(nil, ::T.untyped)
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Rack::ShowExceptions
end

class Rack::ShowStatus
  def call(env); end

  def h(obj); end

  def initialize(app); end
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Rack::ShowStatus
end

class Rack::Static
  def add_index_root?(path); end

  def applicable_rules(path); end

  def call(env); end

  def can_serve(path); end

  def initialize(app, options=T.unsafe(nil)); end

  def overwrite_file_path(path); end

  def route_file(path); end
end

class Rack::Static
end

class Rack::TempfileReaper
  def call(env); end

  def initialize(app); end
end

class Rack::TempfileReaper
end

class Rack::URLMap
  def call(env); end

  def initialize(map=T.unsafe(nil)); end

  def remap(map); end
end

class Rack::URLMap
end

module Rack::Utils
  COMMON_SEP = ::T.let(nil, ::T.untyped)
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
  ESCAPE_HTML = ::T.let(nil, ::T.untyped)
  ESCAPE_HTML_PATTERN = ::T.let(nil, ::T.untyped)
  HTTP_STATUS_CODES = ::T.let(nil, ::T.untyped)
  NULL_BYTE = ::T.let(nil, ::T.untyped)
  PATH_SEPS = ::T.let(nil, ::T.untyped)
  STATUS_WITH_NO_ENTITY_BODY = ::T.let(nil, ::T.untyped)
  SYMBOL_TO_STATUS_CODE = ::T.let(nil, ::T.untyped)
end

class Rack::Utils::Context
  def app(); end

  def call(env); end

  def context(env, app=T.unsafe(nil)); end

  def for(); end

  def initialize(app_f, app_r); end

  def recontext(app); end
end

class Rack::Utils::Context
end

class Rack::Utils::HeaderHash
  def [](k); end

  def []=(k, v); end

  def delete(k); end

  def has_key?(k); end

  def include?(k); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(k); end

  def member?(k); end

  def merge(other); end

  def merge!(other); end

  def names(); end

  def replace(other); end
end

class Rack::Utils::HeaderHash
  def self.[](headers); end
end

Rack::Utils::InvalidParameterError = Rack::QueryParser::InvalidParameterError

Rack::Utils::KeySpaceConstrainedParams = Rack::QueryParser::Params

Rack::Utils::ParameterTypeError = Rack::QueryParser::ParameterTypeError

module Rack::Utils
  def self.add_cookie_to_header(header, key, value); end

  def self.add_remove_cookie_to_header(header, key, value=T.unsafe(nil)); end

  def self.best_q_match(q_value_header, available_mimes); end

  def self.build_nested_query(value, prefix=T.unsafe(nil)); end

  def self.build_query(params); end

  def self.byte_ranges(env, size); end

  def self.clean_path_info(path_info); end

  def self.clock_time(); end

  def self.default_query_parser(); end

  def self.default_query_parser=(default_query_parser); end

  def self.delete_cookie_header!(header, key, value=T.unsafe(nil)); end

  def self.escape(s); end

  def self.escape_html(string); end

  def self.escape_path(s); end

  def self.get_byte_ranges(http_range, size); end

  def self.key_space_limit(); end

  def self.key_space_limit=(v); end

  def self.make_delete_cookie_header(header, key, value); end

  def self.multipart_part_limit(); end

  def self.multipart_part_limit=(multipart_part_limit); end

  def self.param_depth_limit(); end

  def self.param_depth_limit=(v); end

  def self.parse_cookies(env); end

  def self.parse_cookies_header(header); end

  def self.parse_nested_query(qs, d=T.unsafe(nil)); end

  def self.parse_query(qs, d=T.unsafe(nil), &unescaper); end

  def self.q_values(q_value_header); end

  def self.rfc2109(time); end

  def self.rfc2822(time); end

  def self.secure_compare(a, b); end

  def self.select_best_encoding(available_encodings, accept_encoding); end

  def self.set_cookie_header!(header, key, value); end

  def self.status_code(status); end

  def self.unescape(s, encoding=T.unsafe(nil)); end

  def self.unescape_path(s); end

  def self.valid_path?(path); end
end

module Rack
  def self.release(); end

  def self.version(); end
end

class Rainbow::Color::RGB
  def self.to_ansi_domain(value); end
end

class Rainbow::NullPresenter
  def method_missing(method_name, *args); end
end

class Rainbow::Presenter
  def method_missing(method_name, *args); end
end

class Rainbow::StringUtils
  def self.uncolor(string); end
end

module Rainbow
  def self.new(); end
end

module Random::Formatter
  def alphanumeric(n=T.unsafe(nil)); end

  ALPHANUMERIC = ::T.let(nil, ::T.untyped)
end

class Random
  def self.bytes(_); end

  def self.urandom(_); end
end

class Range
  def %(_); end

  def entries(); end

  def to_a(); end
end

module RbConfig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.fire_update!(key, val, mkconf=T.unsafe(nil), conf=T.unsafe(nil)); end

  def self.ruby(); end
end

class Regexp
  def match?(*_); end
end

class Resolv::DNS
  def extract_resources(msg, name, typeclass); end

  def fetch_resource(name, typeclass); end

  def lazy_initialize(); end

  def make_tcp_requester(host, port); end

  def make_udp_requester(); end
  RequestID = ::T.let(nil, ::T.untyped)
  RequestIDMutex = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Config
  def generate_candidates(name); end

  def generate_timeouts(); end

  def initialize(config_info=T.unsafe(nil)); end

  def lazy_initialize(); end

  def nameserver_port(); end

  def resolv(name); end

  def single?(); end

  def timeouts=(values); end
  InitialTimeout = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Config::NXDomain
end

class Resolv::DNS::Config::NXDomain
end

class Resolv::DNS::Config::OtherResolvError
end

class Resolv::DNS::Config::OtherResolvError
end

class Resolv::DNS::Config
  def self.default_config_hash(filename=T.unsafe(nil)); end

  def self.parse_resolv_conf(filename); end
end

module Resolv::DNS::Label
end

class Resolv::DNS::Label::Str
  def ==(other); end

  def downcase(); end

  def eql?(other); end

  def initialize(string); end

  def string(); end
end

class Resolv::DNS::Label::Str
end

module Resolv::DNS::Label
  def self.split(arg); end
end

class Resolv::DNS::Message
  def ==(other); end

  def aa(); end

  def aa=(aa); end

  def add_additional(name, ttl, data); end

  def add_answer(name, ttl, data); end

  def add_authority(name, ttl, data); end

  def add_question(name, typeclass); end

  def additional(); end

  def answer(); end

  def authority(); end

  def each_additional(); end

  def each_answer(); end

  def each_authority(); end

  def each_question(); end

  def each_resource(); end

  def encode(); end

  def id(); end

  def id=(id); end

  def initialize(id=T.unsafe(nil)); end

  def opcode(); end

  def opcode=(opcode); end

  def qr(); end

  def qr=(qr); end

  def question(); end

  def ra(); end

  def ra=(ra); end

  def rcode(); end

  def rcode=(rcode); end

  def rd(); end

  def rd=(rd); end

  def tc(); end

  def tc=(tc); end
end

class Resolv::DNS::Message::MessageDecoder
  def get_bytes(len=T.unsafe(nil)); end

  def get_label(); end

  def get_labels(); end

  def get_length16(); end

  def get_name(); end

  def get_question(); end

  def get_rr(); end

  def get_string(); end

  def get_string_list(); end

  def get_unpack(template); end

  def initialize(data); end
end

class Resolv::DNS::Message::MessageDecoder
end

class Resolv::DNS::Message::MessageEncoder
  def put_bytes(d); end

  def put_label(d); end

  def put_labels(d); end

  def put_length16(); end

  def put_name(d); end

  def put_pack(template, *d); end

  def put_string(d); end

  def put_string_list(ds); end
end

class Resolv::DNS::Message::MessageEncoder
end

class Resolv::DNS::Message
  def self.decode(m); end
end

class Resolv::DNS::Name
  def ==(other); end

  def [](i); end

  def eql?(other); end

  def length(); end

  def to_a(); end
end

module Resolv::DNS::OpCode
  IQuery = ::T.let(nil, ::T.untyped)
  Notify = ::T.let(nil, ::T.untyped)
  Query = ::T.let(nil, ::T.untyped)
  Status = ::T.let(nil, ::T.untyped)
  Update = ::T.let(nil, ::T.untyped)
end

module Resolv::DNS::OpCode
end

class Resolv::DNS::Query
  def encode_rdata(msg); end
end

class Resolv::DNS::Query
  def self.decode_rdata(msg); end
end

module Resolv::DNS::RCode
  BADALG = ::T.let(nil, ::T.untyped)
  BADKEY = ::T.let(nil, ::T.untyped)
  BADMODE = ::T.let(nil, ::T.untyped)
  BADNAME = ::T.let(nil, ::T.untyped)
  BADSIG = ::T.let(nil, ::T.untyped)
  BADTIME = ::T.let(nil, ::T.untyped)
  BADVERS = ::T.let(nil, ::T.untyped)
  FormErr = ::T.let(nil, ::T.untyped)
  NXDomain = ::T.let(nil, ::T.untyped)
  NXRRSet = ::T.let(nil, ::T.untyped)
  NoError = ::T.let(nil, ::T.untyped)
  NotAuth = ::T.let(nil, ::T.untyped)
  NotImp = ::T.let(nil, ::T.untyped)
  NotZone = ::T.let(nil, ::T.untyped)
  Refused = ::T.let(nil, ::T.untyped)
  ServFail = ::T.let(nil, ::T.untyped)
  YXDomain = ::T.let(nil, ::T.untyped)
  YXRRSet = ::T.let(nil, ::T.untyped)
end

module Resolv::DNS::RCode
end

class Resolv::DNS::Requester
  def close(); end

  def request(sender, tout); end

  def sender_for(addr, msg); end
end

class Resolv::DNS::Requester::ConnectedUDP
  def initialize(host, port=T.unsafe(nil)); end

  def lazy_initialize(); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host=T.unsafe(nil), port=T.unsafe(nil)); end
end

class Resolv::DNS::Requester::ConnectedUDP::Sender
  def data(); end

  def send(); end
end

class Resolv::DNS::Requester::ConnectedUDP::Sender
end

class Resolv::DNS::Requester::ConnectedUDP
end

class Resolv::DNS::Requester::MDNSOneShot
end

class Resolv::DNS::Requester::MDNSOneShot
end

class Resolv::DNS::Requester::RequestError
end

class Resolv::DNS::Requester::RequestError
end

class Resolv::DNS::Requester::Sender
  def initialize(msg, data, sock); end
end

class Resolv::DNS::Requester::Sender
end

class Resolv::DNS::Requester::TCP
  def initialize(host, port=T.unsafe(nil)); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host=T.unsafe(nil), port=T.unsafe(nil)); end
end

class Resolv::DNS::Requester::TCP::Sender
  def data(); end

  def send(); end
end

class Resolv::DNS::Requester::TCP::Sender
end

class Resolv::DNS::Requester::TCP
end

class Resolv::DNS::Requester::UnconnectedUDP
  def initialize(*nameserver_port); end

  def lazy_initialize(); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host, port=T.unsafe(nil)); end
end

class Resolv::DNS::Requester::UnconnectedUDP::Sender
  def data(); end

  def initialize(msg, data, sock, host, port); end

  def send(); end
end

class Resolv::DNS::Requester::UnconnectedUDP::Sender
end

class Resolv::DNS::Requester::UnconnectedUDP
end

class Resolv::DNS::Requester
end

class Resolv::DNS::Resource
  def ==(other); end

  def eql?(other); end
  ClassHash = ::T.let(nil, ::T.untyped)
  ClassInsensitiveTypes = ::T.let(nil, ::T.untyped)
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::ANY
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::CNAME
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::Generic
  def self.create(type_value, class_value); end
end

class Resolv::DNS::Resource::HINFO
  TypeValue = ::T.let(nil, ::T.untyped)
end

module Resolv::DNS::Resource::IN
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::A
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::AAAA
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::ANY
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::ANY
end

class Resolv::DNS::Resource::IN::CNAME
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::CNAME
end

class Resolv::DNS::Resource::IN::HINFO
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::HINFO
end

class Resolv::DNS::Resource::IN::LOC
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::LOC
end

class Resolv::DNS::Resource::IN::MINFO
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::MINFO
end

class Resolv::DNS::Resource::IN::MX
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::MX
end

class Resolv::DNS::Resource::IN::NS
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::NS
end

class Resolv::DNS::Resource::IN::PTR
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::PTR
end

class Resolv::DNS::Resource::IN::SOA
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::SOA
end

class Resolv::DNS::Resource::IN::SRV
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::TXT
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::TXT
end

class Resolv::DNS::Resource::IN::WKS
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::LOC
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::MINFO
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::MX
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::NS
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::PTR
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::SOA
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::TXT
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource
  def self.get_class(type_value, class_value); end
end

class Resolv::DNS
  def self.allocate_request_id(host, port); end

  def self.bind_random_port(udpsock, bind_host=T.unsafe(nil)); end

  def self.free_request_id(host, port, id); end

  def self.random(arg); end
end

class Resolv::Hosts
  def lazy_initialize(); end
end

class Resolv::IPv4
  def ==(other); end

  def eql?(other); end
end

class Resolv::IPv6
  def ==(other); end

  def eql?(other); end
end

class Resolv::LOC::Alt
  def ==(other); end

  def eql?(other); end
end

class Resolv::LOC::Coord
  def ==(other); end

  def eql?(other); end
end

class Resolv::LOC::Size
  def ==(other); end

  def eql?(other); end
end

module RuboCop
end

module RuboCop::AST
end

class RuboCop::AST::AliasNode
  def new_identifier(); end

  def old_identifier(); end
end

class RuboCop::AST::AliasNode
end

class RuboCop::AST::AndNode
  include ::RuboCop::AST::BinaryOperatorNode
  include ::RuboCop::AST::PredicateOperatorNode
  def alternate_operator(); end

  def inverse_operator(); end
end

class RuboCop::AST::AndNode
end

class RuboCop::AST::ArgsNode
  include ::RuboCop::AST::CollectionNode
  def empty_and_without_delimiters?(); end
end

class RuboCop::AST::ArgsNode
end

class RuboCop::AST::ArrayNode
  def bracketed?(); end

  def percent_literal?(type=T.unsafe(nil)); end

  def square_brackets?(); end

  def values(); end
  PERCENT_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::ArrayNode
end

module RuboCop::AST::BasicLiteralNode
  def value(); end
end

module RuboCop::AST::BasicLiteralNode
end

module RuboCop::AST::BinaryOperatorNode
  def conditions(); end

  def lhs(); end

  def rhs(); end
end

module RuboCop::AST::BinaryOperatorNode
end

class RuboCop::AST::BlockNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def arguments(); end

  def arguments?(); end

  def body(); end

  def braces?(); end

  def closing_delimiter(); end

  def delimiters(); end

  def keywords?(); end

  def lambda?(); end

  def method_name(); end

  def opening_delimiter(); end

  def send_node(); end

  def void_context?(); end
  VOID_CONTEXT_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::BlockNode
end

class RuboCop::AST::BreakNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  include ::RuboCop::AST::ParameterizedNode
end

class RuboCop::AST::BreakNode
end

class RuboCop::AST::Builder
  NODE_MAP = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::Builder
end

class RuboCop::AST::CaseNode
  include ::RuboCop::AST::ConditionalNode
  def each_when(); end

  def else?(); end

  def else_branch(); end

  def keyword(); end

  def when_branches(); end
end

class RuboCop::AST::CaseNode
end

class RuboCop::AST::ClassNode
  def body(); end

  def identifier(); end

  def parent_class(); end
end

class RuboCop::AST::ClassNode
end

module RuboCop::AST::CollectionNode
  def &(*args, &block); end

  def *(*args, &block); end

  def +(*args, &block); end

  def -(*args, &block); end

  def <<(*args, &block); end

  def [](*args, &block); end

  def []=(*args, &block); end

  def all?(*args, &block); end

  def any?(*args, &block); end

  def append(*args, &block); end

  def assoc(*args, &block); end

  def at(*args, &block); end

  def bsearch(*args, &block); end

  def bsearch_index(*args, &block); end

  def chain(*args, &block); end

  def chunk(*args, &block); end

  def chunk_while(*args, &block); end

  def clear(*args, &block); end

  def collect(*args, &block); end

  def collect!(*args, &block); end

  def collect_concat(*args, &block); end

  def combination(*args, &block); end

  def compact(*args, &block); end

  def compact!(*args, &block); end

  def concat(*args, &block); end

  def count(*args, &block); end

  def cycle(*args, &block); end

  def deconstruct(*args, &block); end

  def delete(*args, &block); end

  def delete_at(*args, &block); end

  def delete_if(*args, &block); end

  def detect(*args, &block); end

  def difference(*args, &block); end

  def dig(*args, &block); end

  def drop(*args, &block); end

  def drop_while(*args, &block); end

  def each(*args, &block); end

  def each_cons(*args, &block); end

  def each_entry(*args, &block); end

  def each_index(*args, &block); end

  def each_slice(*args, &block); end

  def each_with_index(*args, &block); end

  def each_with_object(*args, &block); end

  def empty?(*args, &block); end

  def entries(*args, &block); end

  def fetch(*args, &block); end

  def fill(*args, &block); end

  def filter(*args, &block); end

  def filter!(*args, &block); end

  def filter_map(*args, &block); end

  def find(*args, &block); end

  def find_all(*args, &block); end

  def find_index(*args, &block); end

  def first(*args, &block); end

  def flat_map(*args, &block); end

  def flatten(*args, &block); end

  def flatten!(*args, &block); end

  def grep(*args, &block); end

  def grep_v(*args, &block); end

  def group_by(*args, &block); end

  def include?(*args, &block); end

  def index(*args, &block); end

  def inject(*args, &block); end

  def insert(*args, &block); end

  def intersection(*args, &block); end

  def join(*args, &block); end

  def keep_if(*args, &block); end

  def last(*args, &block); end

  def lazy(*args, &block); end

  def length(*args, &block); end

  def map(*args, &block); end

  def map!(*args, &block); end

  def max(*args, &block); end

  def max_by(*args, &block); end

  def member?(*args, &block); end

  def min(*args, &block); end

  def min_by(*args, &block); end

  def minmax(*args, &block); end

  def minmax_by(*args, &block); end

  def none?(*args, &block); end

  def one?(*args, &block); end

  def pack(*args, &block); end

  def partition(*args, &block); end

  def permutation(*args, &block); end

  def pop(*args, &block); end

  def prepend(*args, &block); end

  def product(*args, &block); end

  def push(*args, &block); end

  def rassoc(*args, &block); end

  def reduce(*args, &block); end

  def reject(*args, &block); end

  def reject!(*args, &block); end

  def repeated_combination(*args, &block); end

  def repeated_permutation(*args, &block); end

  def replace(*args, &block); end

  def reverse(*args, &block); end

  def reverse!(*args, &block); end

  def reverse_each(*args, &block); end

  def rindex(*args, &block); end

  def rotate(*args, &block); end

  def rotate!(*args, &block); end

  def sample(*args, &block); end

  def select(*args, &block); end

  def select!(*args, &block); end

  def shift(*args, &block); end

  def shuffle(*args, &block); end

  def shuffle!(*args, &block); end

  def size(*args, &block); end

  def slice(*args, &block); end

  def slice!(*args, &block); end

  def slice_after(*args, &block); end

  def slice_before(*args, &block); end

  def slice_when(*args, &block); end

  def sort(*args, &block); end

  def sort!(*args, &block); end

  def sort_by(*args, &block); end

  def sort_by!(*args, &block); end

  def sum(*args, &block); end

  def take(*args, &block); end

  def take_while(*args, &block); end

  def tally(*args, &block); end

  def to_ary(*args, &block); end

  def to_h(*args, &block); end

  def to_set(*args, &block); end

  def transpose(*args, &block); end

  def union(*args, &block); end

  def uniq(*args, &block); end

  def uniq!(*args, &block); end

  def unshift(*args, &block); end

  def values_at(*args, &block); end

  def zip(*args, &block); end

  def |(*args, &block); end
  ARRAY_METHODS = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::CollectionNode
  extend ::Forwardable
end

module RuboCop::AST::ConditionalNode
  def body(); end

  def condition(); end

  def multiline_condition?(); end

  def single_line_condition?(); end
end

module RuboCop::AST::ConditionalNode
end

class RuboCop::AST::DefNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def argument_forwarding?(); end

  def arguments(); end

  def body(); end

  def method_name(); end

  def receiver(); end

  def void_context?(); end
end

class RuboCop::AST::DefNode
end

class RuboCop::AST::DefinedNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
end

class RuboCop::AST::DefinedNode
end

class RuboCop::AST::EnsureNode
  def body(); end
end

class RuboCop::AST::EnsureNode
end

class RuboCop::AST::FloatNode
  include ::RuboCop::AST::NumericNode
end

class RuboCop::AST::FloatNode
end

class RuboCop::AST::ForNode
  def body(); end

  def collection(); end

  def do?(); end

  def keyword(); end

  def variable(); end

  def void_context?(); end
end

class RuboCop::AST::ForNode
end

class RuboCop::AST::ForwardArgsNode
  include ::RuboCop::AST::CollectionNode
end

class RuboCop::AST::ForwardArgsNode
end

module RuboCop::AST::HashElementNode
  def delimiter_delta(other); end

  def key(); end

  def key_delta(other, alignment=T.unsafe(nil)); end

  def same_line?(other); end

  def value(); end

  def value_delta(other); end
end

module RuboCop::AST::HashElementNode
end

class RuboCop::AST::HashNode
  def braces?(); end

  def each_key(); end

  def each_pair(); end

  def each_value(); end

  def empty?(); end

  def keys(); end

  def mixed_delimiters?(); end

  def pairs(); end

  def pairs_on_same_line?(); end

  def values(); end
end

class RuboCop::AST::HashNode
end

class RuboCop::AST::IfNode
  include ::RuboCop::AST::ConditionalNode
  include ::RuboCop::AST::ModifierNode
  def branches(); end

  def each_branch(); end

  def else?(); end

  def else_branch(); end

  def elsif?(); end

  def elsif_conditional?(); end

  def if?(); end

  def if_branch(); end

  def inverse_keyword(); end

  def keyword(); end

  def nested_conditional?(); end

  def ternary?(); end

  def unless?(); end
end

class RuboCop::AST::IfNode
end

class RuboCop::AST::IntNode
  include ::RuboCop::AST::NumericNode
end

class RuboCop::AST::IntNode
end

class RuboCop::AST::KeywordSplatNode
  include ::RuboCop::AST::HashElementNode
  def colon?(); end

  def hash_rocket?(); end

  def operator(); end
  DOUBLE_SPLAT = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::KeywordSplatNode
end

module RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def access_modifier?(); end

  def adjacent_def_modifier?(node=T.unsafe(nil)); end

  def arguments(); end

  def arithmetic_operation?(); end

  def assignment?(); end

  def bare_access_modifier?(); end

  def bare_access_modifier_declaration?(node=T.unsafe(nil)); end

  def binary_operation?(); end

  def block_literal?(); end

  def block_node(); end

  def command?(name); end

  def const_receiver?(); end

  def def_modifier?(); end

  def dot?(); end

  def double_colon?(); end

  def implicit_call?(); end

  def lambda?(); end

  def lambda_literal?(); end

  def macro?(); end

  def macro_scope?(node=T.unsafe(nil)); end

  def method_name(); end

  def non_bare_access_modifier?(); end

  def non_bare_access_modifier_declaration?(node=T.unsafe(nil)); end

  def receiver(); end

  def self_receiver?(); end

  def setter_method?(); end

  def special_modifier?(); end

  def unary_operation?(); end
  ARITHMETIC_OPERATORS = ::T.let(nil, ::T.untyped)
  SPECIAL_MODIFIERS = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::MethodDispatchNode
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::AST::MethodIdentifierPredicates
  def assignment_method?(); end

  def bang_method?(); end

  def camel_case_method?(); end

  def comparison_method?(); end

  def const_receiver?(); end

  def enumerator_method?(); end

  def method?(name); end

  def negation_method?(); end

  def operator_method?(); end

  def predicate_method?(); end

  def prefix_bang?(); end

  def prefix_not?(); end

  def self_receiver?(); end
  ENUMERATOR_METHODS = ::T.let(nil, ::T.untyped)
  OPERATOR_METHODS = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::MethodIdentifierPredicates
end

module RuboCop::AST::ModifierNode
  def modifier_form?(); end
end

module RuboCop::AST::ModifierNode
end

class RuboCop::AST::ModuleNode
  def body(); end

  def identifier(); end
end

class RuboCop::AST::ModuleNode
end

class RuboCop::AST::Node
  include ::RuboCop::AST::Sexp
  def __ENCODING___type?(); end

  def __FILE___type?(); end

  def __LINE___type?(); end

  def alias_type?(); end

  def ancestors(); end

  def and_asgn_type?(); end

  def and_type?(); end

  def arg_expr_type?(); end

  def arg_type?(); end

  def args_type?(); end

  def argument?(); end

  def array_pattern_type?(); end

  def array_pattern_with_tail_type?(); end

  def array_type?(); end

  def assignment?(); end

  def assignment_or_similar?(node=T.unsafe(nil)); end

  def back_ref_type?(); end

  def basic_conditional?(); end

  def basic_literal?(); end

  def begin_type?(); end

  def block_pass_type?(); end

  def block_type?(); end

  def blockarg_expr_type?(); end

  def blockarg_type?(); end

  def boolean_type?(); end

  def break_type?(); end

  def call_type?(); end

  def case_match_type?(); end

  def case_type?(); end

  def casgn_type?(); end

  def cbase_type?(); end

  def chained?(); end

  def child_nodes(); end

  def class_constructor?(node=T.unsafe(nil)); end

  def class_type?(); end

  def complete!(); end

  def complete?(); end

  def complex_type?(); end

  def conditional?(); end

  def const_name(); end

  def const_pattern_type?(); end

  def const_type?(); end

  def csend_type?(); end

  def cvar_type?(); end

  def cvasgn_type?(); end

  def def_type?(); end

  def defined_module(); end

  def defined_module_name(); end

  def defined_type?(); end

  def defs_type?(); end

  def descendants(); end

  def dstr_type?(); end

  def dsym_type?(); end

  def each_ancestor(*types, &block); end

  def each_child_node(*types); end

  def each_descendant(*types, &block); end

  def each_node(*types, &block); end

  def eflipflop_type?(); end

  def empty_source?(); end

  def ensure_type?(); end

  def equals_asgn?(); end

  def erange_type?(); end

  def false_type?(); end

  def falsey_literal?(); end

  def first_line(); end

  def float_type?(); end

  def for_type?(); end

  def forward_args_type?(); end

  def forwarded_args_type?(); end

  def guard_clause?(node=T.unsafe(nil)); end

  def gvar_type?(); end

  def gvasgn_type?(); end

  def hash_pattern_type?(); end

  def hash_type?(); end

  def ident_type?(); end

  def if_guard_type?(); end

  def if_type?(); end

  def iflipflop_type?(); end

  def immutable_literal?(); end

  def in_match_type?(); end

  def in_pattern_type?(); end

  def index_type?(); end

  def indexasgn_type?(); end

  def int_type?(); end

  def irange_type?(); end

  def ivar_type?(); end

  def ivasgn_type?(); end

  def keyword?(); end

  def kwarg_type?(); end

  def kwbegin_type?(); end

  def kwnilarg_type?(); end

  def kwoptarg_type?(); end

  def kwrestarg_type?(); end

  def kwsplat_type?(); end

  def lambda?(node=T.unsafe(nil)); end

  def lambda_or_proc?(node=T.unsafe(nil)); end

  def lambda_type?(); end

  def last_line(); end

  def line_count(); end

  def literal?(); end

  def lvar_type?(); end

  def lvasgn_type?(); end

  def masgn_type?(); end

  def match_alt_type?(); end

  def match_as_type?(); end

  def match_current_line_type?(); end

  def match_nil_pattern_type?(); end

  def match_rest_type?(); end

  def match_var_type?(); end

  def match_with_lvasgn_type?(); end

  def match_with_trailing_comma_type?(); end

  def mlhs_type?(); end

  def module_type?(); end

  def multiline?(); end

  def mutable_literal?(); end

  def new_class_or_module_block?(node=T.unsafe(nil)); end

  def next_type?(); end

  def nil_type?(); end

  def node_parts(); end

  def nonempty_line_count(); end

  def not_type?(); end

  def nth_ref_type?(); end

  def numargs_type?(); end

  def numblock_type?(); end

  def numeric_type?(); end

  def objc_kwarg_type?(); end

  def objc_restarg_type?(); end

  def objc_varargs_type?(); end

  def op_asgn_type?(); end

  def operator_keyword?(); end

  def optarg_type?(); end

  def or_asgn_type?(); end

  def or_type?(); end

  def pair_type?(); end

  def parent(); end

  def parent=(node); end

  def parent_module_name(); end

  def parenthesized_call?(); end

  def pin_type?(); end

  def postexe_type?(); end

  def preexe_type?(); end

  def proc?(node=T.unsafe(nil)); end

  def procarg0_type?(); end

  def pure?(); end

  def range_type?(); end

  def rational_type?(); end

  def receiver(node=T.unsafe(nil)); end

  def recursive_basic_literal?(); end

  def recursive_literal?(); end

  def redo_type?(); end

  def reference?(); end

  def regexp_type?(); end

  def regopt_type?(); end

  def resbody_type?(); end

  def rescue_type?(); end

  def restarg_expr_type?(); end

  def restarg_type?(); end

  def retry_type?(); end

  def return_type?(); end

  def root_type?(); end

  def sclass_type?(); end

  def self_type?(); end

  def send_type?(); end

  def shadowarg_type?(); end

  def shorthand_asgn?(); end

  def sibling_index(); end

  def single_line?(); end

  def source(); end

  def source_length(); end

  def source_range(); end

  def special_keyword?(); end

  def splat_type?(); end

  def str_content(node=T.unsafe(nil)); end

  def str_type?(); end

  def super_type?(); end

  def sym_type?(); end

  def true_type?(); end

  def truthy_literal?(); end

  def undef_type?(); end

  def unless_guard_type?(); end

  def until_post_type?(); end

  def until_type?(); end

  def value_used?(); end

  def variable?(); end

  def visit_descendants(types, &block); end

  def when_type?(); end

  def while_post_type?(); end

  def while_type?(); end

  def xstr_type?(); end

  def yield_type?(); end

  def zsuper_type?(); end
  ASSIGNMENTS = ::T.let(nil, ::T.untyped)
  BASIC_CONDITIONALS = ::T.let(nil, ::T.untyped)
  BASIC_LITERALS = ::T.let(nil, ::T.untyped)
  COMPARISON_OPERATORS = ::T.let(nil, ::T.untyped)
  COMPOSITE_LITERALS = ::T.let(nil, ::T.untyped)
  CONDITIONALS = ::T.let(nil, ::T.untyped)
  EQUALS_ASSIGNMENTS = ::T.let(nil, ::T.untyped)
  FALSEY_LITERALS = ::T.let(nil, ::T.untyped)
  IMMUTABLE_LITERALS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  LITERALS = ::T.let(nil, ::T.untyped)
  MUTABLE_LITERALS = ::T.let(nil, ::T.untyped)
  OPERATOR_KEYWORDS = ::T.let(nil, ::T.untyped)
  REFERENCES = ::T.let(nil, ::T.untyped)
  SHORTHAND_ASSIGNMENTS = ::T.let(nil, ::T.untyped)
  SPECIAL_KEYWORDS = ::T.let(nil, ::T.untyped)
  TRUTHY_LITERALS = ::T.let(nil, ::T.untyped)
  VARIABLES = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::Node
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::AST::NumericNode
  def sign?(); end
  SIGN_REGEX = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::NumericNode
end

class RuboCop::AST::OrNode
  include ::RuboCop::AST::BinaryOperatorNode
  include ::RuboCop::AST::PredicateOperatorNode
  def alternate_operator(); end

  def inverse_operator(); end
end

class RuboCop::AST::OrNode
end

class RuboCop::AST::PairNode
  include ::RuboCop::AST::HashElementNode
  def colon?(); end

  def delimiter(with_spacing=T.unsafe(nil)); end

  def hash_rocket?(); end

  def inverse_delimiter(with_spacing=T.unsafe(nil)); end

  def value_on_new_line?(); end
  COLON = ::T.let(nil, ::T.untyped)
  HASH_ROCKET = ::T.let(nil, ::T.untyped)
  SPACED_COLON = ::T.let(nil, ::T.untyped)
  SPACED_HASH_ROCKET = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::PairNode
end

module RuboCop::AST::ParameterizedNode
  def arguments?(); end

  def block_argument?(); end

  def first_argument(); end

  def last_argument(); end

  def parenthesized?(); end

  def rest_argument?(); end

  def splat_argument?(); end
end

module RuboCop::AST::ParameterizedNode
end

module RuboCop::AST::PredicateOperatorNode
  def logical_operator?(); end

  def operator(); end

  def semantic_operator?(); end
  LOGICAL_AND = ::T.let(nil, ::T.untyped)
  LOGICAL_OR = ::T.let(nil, ::T.untyped)
  SEMANTIC_AND = ::T.let(nil, ::T.untyped)
  SEMANTIC_OR = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::PredicateOperatorNode
end

class RuboCop::AST::RangeNode
  def begin(); end

  def end(); end
end

class RuboCop::AST::RangeNode
end

class RuboCop::AST::RegexpNode
  def content(); end

  def regopt(); end

  def to_regexp(); end
  OPTIONS = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::RegexpNode
end

class RuboCop::AST::ResbodyNode
  def body(); end

  def exception_variable(); end
end

class RuboCop::AST::ResbodyNode
end

class RuboCop::AST::RetryNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  include ::RuboCop::AST::ParameterizedNode
end

class RuboCop::AST::RetryNode
end

class RuboCop::AST::ReturnNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  include ::RuboCop::AST::ParameterizedNode
end

class RuboCop::AST::ReturnNode
end

class RuboCop::AST::SelfClassNode
  def body(); end

  def identifier(); end
end

class RuboCop::AST::SelfClassNode
end

class RuboCop::AST::SendNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
end

class RuboCop::AST::SendNode
end

module RuboCop::AST::Sexp
  def s(type, *children); end
end

module RuboCop::AST::Sexp
end

class RuboCop::AST::StrNode
  include ::RuboCop::AST::BasicLiteralNode
  def heredoc?(); end
end

class RuboCop::AST::StrNode
end

class RuboCop::AST::SuperNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
end

class RuboCop::AST::SuperNode
end

class RuboCop::AST::SymbolNode
  include ::RuboCop::AST::BasicLiteralNode
end

class RuboCop::AST::SymbolNode
end

module RuboCop::AST::Traversal
  def on_alias(node); end

  def on_and(node); end

  def on_and_asgn(node); end

  def on_arg(node); end

  def on_arg_expr(node); end

  def on_args(node); end

  def on_array(node); end

  def on_array_pattern(node); end

  def on_array_pattern_with_tail(node); end

  def on_back_ref(node); end

  def on_begin(node); end

  def on_block(node); end

  def on_block_pass(node); end

  def on_blockarg(node); end

  def on_break(node); end

  def on_case(node); end

  def on_case_match(node); end

  def on_casgn(node); end

  def on_cbase(node); end

  def on_class(node); end

  def on_complex(node); end

  def on_const(node); end

  def on_const_pattern(node); end

  def on_csend(node); end

  def on_cvar(node); end

  def on_cvasgn(node); end

  def on_def(node); end

  def on_defined?(node); end

  def on_defs(node); end

  def on_dstr(node); end

  def on_dsym(node); end

  def on_eflipflop(node); end

  def on_ensure(node); end

  def on_erange(node); end

  def on_false(node); end

  def on_float(node); end

  def on_for(node); end

  def on_forward_args(node); end

  def on_forwarded_args(node); end

  def on_gvar(node); end

  def on_gvasgn(node); end

  def on_hash(node); end

  def on_hash_pattern(node); end

  def on_if(node); end

  def on_if_guard(node); end

  def on_iflipflop(node); end

  def on_in_match(node); end

  def on_in_pattern(node); end

  def on_int(node); end

  def on_irange(node); end

  def on_ivar(node); end

  def on_ivasgn(node); end

  def on_kwarg(node); end

  def on_kwbegin(node); end

  def on_kwoptarg(node); end

  def on_kwrestarg(node); end

  def on_kwsplat(node); end

  def on_lambda(node); end

  def on_lvar(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_match_alt(node); end

  def on_match_as(node); end

  def on_match_current_line(node); end

  def on_match_nil_pattern(node); end

  def on_match_rest(node); end

  def on_match_var(node); end

  def on_match_with_lvasgn(node); end

  def on_match_with_trailing_comma(node); end

  def on_mlhs(node); end

  def on_module(node); end

  def on_next(node); end

  def on_nil(node); end

  def on_not(node); end

  def on_nth_ref(node); end

  def on_op_asgn(node); end

  def on_optarg(node); end

  def on_or(node); end

  def on_or_asgn(node); end

  def on_pair(node); end

  def on_pin(node); end

  def on_postexe(node); end

  def on_preexe(node); end

  def on_rational(node); end

  def on_redo(node); end

  def on_regexp(node); end

  def on_regopt(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_restarg(node); end

  def on_retry(node); end

  def on_return(node); end

  def on_sclass(node); end

  def on_self(node); end

  def on_send(node); end

  def on_shadowarg(node); end

  def on_splat(node); end

  def on_str(node); end

  def on_super(node); end

  def on_sym(node); end

  def on_true(node); end

  def on_undef(node); end

  def on_unless_guard(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_when(node); end

  def on_while(node); end

  def on_while_post(node); end

  def on_xstr(node); end

  def on_yield(node); end

  def on_zsuper(node); end

  def walk(node); end
  MANY_CHILD_NODES = ::T.let(nil, ::T.untyped)
  NO_CHILD_NODES = ::T.let(nil, ::T.untyped)
  ONE_CHILD_NODE = ::T.let(nil, ::T.untyped)
  SECOND_CHILD_ONLY = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::Traversal
end

class RuboCop::AST::UntilNode
  include ::RuboCop::AST::ConditionalNode
  include ::RuboCop::AST::ModifierNode
  def do?(); end

  def inverse_keyword(); end

  def keyword(); end
end

class RuboCop::AST::UntilNode
end

class RuboCop::AST::WhenNode
  def body(); end

  def branch_index(); end

  def conditions(); end

  def each_condition(); end

  def then?(); end
end

class RuboCop::AST::WhenNode
end

class RuboCop::AST::WhileNode
  include ::RuboCop::AST::ConditionalNode
  include ::RuboCop::AST::ModifierNode
  def do?(); end

  def inverse_keyword(); end

  def keyword(); end
end

class RuboCop::AST::WhileNode
end

class RuboCop::AST::YieldNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
end

class RuboCop::AST::YieldNode
end

module RuboCop::AST
end

class RuboCop::CLI
  def config_store(); end

  def options(); end

  def run(args=T.unsafe(nil)); end
  STATUS_ERROR = ::T.let(nil, ::T.untyped)
  STATUS_INTERRUPTED = ::T.let(nil, ::T.untyped)
  STATUS_OFFENSES = ::T.let(nil, ::T.untyped)
  STATUS_SUCCESS = ::T.let(nil, ::T.untyped)
end

module RuboCop::CLI::Command
end

class RuboCop::CLI::Command::AutoGenerateConfig
  def run(); end
  PHASE_1 = ::T.let(nil, ::T.untyped)
  PHASE_1_DISABLED = ::T.let(nil, ::T.untyped)
  PHASE_1_OVERRIDDEN = ::T.let(nil, ::T.untyped)
  PHASE_2 = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Command::AutoGenerateConfig
end

class RuboCop::CLI::Command::Base
  def env(); end

  def initialize(env); end
end

class RuboCop::CLI::Command::Base
  def self.by_command_name(name); end

  def self.command_name(); end

  def self.command_name=(command_name); end

  def self.inherited(subclass); end
end

class RuboCop::CLI::Command::ExecuteRunner
  include ::RuboCop::Formatter::TextUtil
  def run(); end
end

class RuboCop::CLI::Command::ExecuteRunner
end

class RuboCop::CLI::Command::InitDotfile
  def run(); end
  DOTFILE = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Command::InitDotfile
end

class RuboCop::CLI::Command::ShowCops
  def run(); end
end

class RuboCop::CLI::Command::ShowCops
end

class RuboCop::CLI::Command::Version
  def run(); end
end

class RuboCop::CLI::Command::Version
end

module RuboCop::CLI::Command
  def self.run(env, name); end
end

class RuboCop::CLI::Environment
  def config_store(); end

  def initialize(options, config_store, paths); end

  def options(); end

  def paths(); end

  def run(name); end
end

class RuboCop::CLI::Environment
end

class RuboCop::CLI::Finished
end

class RuboCop::CLI::Finished
end

class RuboCop::CLI
end

class RuboCop::CachedData
  def from_json(text); end

  def initialize(filename); end

  def to_json(offenses); end
end

class RuboCop::CachedData
end

class RuboCop::CommentConfig
  def cop_disabled_line_ranges(); end

  def cop_enabled_at_line?(cop, line_number); end

  def extra_enabled_comments(); end

  def initialize(processed_source); end

  def processed_source(); end
  COMMENT_DIRECTIVE_REGEXP = ::T.let(nil, ::T.untyped)
  COPS_PATTERN = ::T.let(nil, ::T.untyped)
  COP_NAMES_PATTERN = ::T.let(nil, ::T.untyped)
  COP_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  REDUNDANT_DISABLE = ::T.let(nil, ::T.untyped)
end

class RuboCop::CommentConfig::CopAnalysis
  def line_ranges(); end

  def line_ranges=(_); end

  def start_line_number(); end

  def start_line_number=(_); end
end

class RuboCop::CommentConfig::CopAnalysis
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::CommentConfig
end

class RuboCop::Config
  include ::RuboCop::PathUtil
  include ::RuboCop::FileFinder
  def [](*args, &block); end

  def []=(*args, &block); end

  def add_excludes_from_higher_level(highest_config); end

  def allowed_camel_case_file?(file); end

  def base_dir_for_path_parameters(); end

  def bundler_lock_file_path(); end

  def check(); end

  def delete(*args, &block); end

  def deprecation_check(); end

  def each(*args, &block); end

  def each_key(*args, &block); end

  def file_to_exclude?(file); end

  def file_to_include?(file); end

  def for_all_cops(); end

  def for_cop(cop); end

  def for_department(department_name); end

  def initialize(hash=T.unsafe(nil), loaded_path=T.unsafe(nil)); end

  def internal?(); end

  def key?(*args, &block); end

  def keys(*args, &block); end

  def loaded_path(); end

  def make_excludes_absolute(); end

  def map(*args, &block); end

  def merge(*args, &block); end

  def path_relative_to_config(path); end

  def patterns_to_exclude(); end

  def patterns_to_include(); end

  def possibly_include_hidden?(); end

  def signature(); end

  def smart_loaded_path(); end

  def target_rails_version(); end

  def target_ruby_version(*args, &block); end

  def to_h(*args, &block); end

  def to_hash(*args, &block); end

  def validate(*args, &block); end
  DEFAULT_RAILS_VERSION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Config
  extend ::Forwardable
  def self.create(hash, path); end
end

class RuboCop::ConfigLoader
  AUTO_GENERATED_FILE = ::T.let(nil, ::T.untyped)
  DEFAULT_FILE = ::T.let(nil, ::T.untyped)
  DOTFILE = ::T.let(nil, ::T.untyped)
  RUBOCOP_HOME = ::T.let(nil, ::T.untyped)
  XDG_CONFIG = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigLoader
  extend ::RuboCop::FileFinder
  def self.add_excludes_from_files(config, config_file); end

  def self.add_inheritance_from_auto_generated_file(); end

  def self.add_missing_namespaces(path, hash); end

  def self.auto_gen_config(); end

  def self.auto_gen_config=(auto_gen_config); end

  def self.auto_gen_config?(); end

  def self.clear_options(); end

  def self.configuration_file_for(target_dir); end

  def self.configuration_from_file(config_file); end

  def self.debug(); end

  def self.debug=(debug); end

  def self.debug?(); end

  def self.default_configuration(); end

  def self.default_configuration=(default_configuration); end

  def self.ignore_parent_exclusion(); end

  def self.ignore_parent_exclusion=(ignore_parent_exclusion); end

  def self.ignore_parent_exclusion?(); end

  def self.load_file(file); end

  def self.merge(base_hash, derived_hash); end

  def self.merge_with_default(config, config_file, unset_nil: T.unsafe(nil)); end

  def self.options_config(); end

  def self.options_config=(options_config); end

  def self.warn_on_pending_cops(config); end
end

class RuboCop::ConfigLoaderResolver
  def merge(base_hash, derived_hash, **opts); end

  def merge_with_default(config, config_file, unset_nil:); end

  def resolve_inheritance(path, hash, file, debug); end

  def resolve_inheritance_from_gems(hash); end

  def resolve_requires(path, hash); end
end

class RuboCop::ConfigLoaderResolver
end

class RuboCop::ConfigNotFoundError
end

class RuboCop::ConfigNotFoundError
end

class RuboCop::ConfigObsoletion
  def initialize(config); end

  def reject_obsolete_cops_and_parameters(); end
  MOVED_COPS = ::T.let(nil, ::T.untyped)
  OBSOLETE_COPS = ::T.let(nil, ::T.untyped)
  OBSOLETE_ENFORCED_STYLES = ::T.let(nil, ::T.untyped)
  OBSOLETE_PARAMETERS = ::T.let(nil, ::T.untyped)
  REMOVED_COPS = ::T.let(nil, ::T.untyped)
  REMOVED_COPS_WITH_REASON = ::T.let(nil, ::T.untyped)
  RENAMED_COPS = ::T.let(nil, ::T.untyped)
  SPLIT_COPS = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigObsoletion
end

class RuboCop::ConfigStore
  def for(file_or_dir); end

  def force_default_config!(); end

  def options_config=(options_config); end
end

class RuboCop::ConfigStore
end

class RuboCop::ConfigValidator
  def for_all_cops(*args, &block); end

  def initialize(config); end

  def smart_loaded_path(*args, &block); end

  def target_ruby_version(); end

  def validate(); end

  def validate_section_presence(name); end
  COMMON_PARAMS = ::T.let(nil, ::T.untyped)
  INTERNAL_PARAMS = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigValidator
  extend ::Forwardable
end

module RuboCop::Cop
end

module RuboCop::Cop::Alignment
  SPACE = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Alignment
end

class RuboCop::Cop::AlignmentCorrector
end

class RuboCop::Cop::AlignmentCorrector
  extend ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::Alignment
  def self.align_end(processed_source, node, align_to); end

  def self.correct(processed_source, node, column_delta); end

  def self.processed_source(); end
end

class RuboCop::Cop::AmbiguousCopName
  def initialize(name, origin, badges); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::AmbiguousCopName
end

module RuboCop::Cop::ArrayMinSize
end

module RuboCop::Cop::ArrayMinSize
end

module RuboCop::Cop::ArraySyntax
end

module RuboCop::Cop::ArraySyntax
end

module RuboCop::Cop::AutocorrectLogic
  def autocorrect?(); end

  def autocorrect_enabled?(); end

  def autocorrect_requested?(); end

  def correctable?(); end

  def disable_offense(node); end

  def disable_uncorrectable?(); end

  def safe_autocorrect?(); end

  def support_autocorrect?(); end
end

module RuboCop::Cop::AutocorrectLogic
end

class RuboCop::Cop::Badge
  def ==(other); end

  def cop_name(); end

  def department(); end

  def eql?(other); end

  def initialize(department, cop_name); end

  def match?(other); end

  def qualified?(); end

  def with_department(department); end
end

class RuboCop::Cop::Badge::InvalidBadge
  def initialize(token); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Badge::InvalidBadge
end

class RuboCop::Cop::Badge
  def self.for(class_name); end

  def self.parse(identifier); end
end

module RuboCop::Cop::Bundler
end

class RuboCop::Cop::Bundler::DuplicatedGem
  include ::RuboCop::Cop::RangeHelp
  def gem_declarations(node0); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::DuplicatedGem
end

class RuboCop::Cop::Bundler::GemComment
  include ::RuboCop::Cop::DefNode
  def gem_declaration?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::GemComment
end

class RuboCop::Cop::Bundler::InsecureProtocolSource
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def insecure_protocol_source?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::InsecureProtocolSource
end

class RuboCop::Cop::Bundler::OrderedGems
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::OrderedGemNode
  def autocorrect(node); end

  def gem_declarations(node0); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::OrderedGems
end

module RuboCop::Cop::Bundler
end

module RuboCop::Cop::CheckAssignment
  def on_and_asgn(node); end

  def on_casgn(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_op_asgn(node); end

  def on_or_asgn(node); end

  def on_send(node); end
end

module RuboCop::Cop::CheckAssignment
  def self.extract_rhs(node); end
end

module RuboCop::Cop::CheckLineBreakable
  def extract_breakable_node(node, max); end
end

module RuboCop::Cop::CheckLineBreakable
end

module RuboCop::Cop::ClassishLength
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
end

module RuboCop::Cop::ClassishLength
end

module RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
end

module RuboCop::Cop::CodeLength
end

class RuboCop::Cop::Commissioner
  include ::RuboCop::AST::Traversal
  def errors(); end

  def initialize(cops, forces=T.unsafe(nil), options=T.unsafe(nil)); end

  def investigate(processed_source); end
end

class RuboCop::Cop::Commissioner
end

class RuboCop::Cop::ConditionCorrector
end

class RuboCop::Cop::ConditionCorrector
  def self.correct_negative_condition(node); end
end

module RuboCop::Cop::ConfigurableEnforcedStyle
  def alternative_style(); end

  def alternative_styles(); end

  def ambiguous_style_detected(*possibilities); end

  def conflicting_styles_detected(); end

  def correct_style_detected(); end

  def detected_style(); end

  def detected_style=(style); end

  def no_acceptable_style!(); end

  def no_acceptable_style?(); end

  def opposite_style_detected(); end

  def style(); end

  def style_detected(detected); end

  def style_parameter_name(); end

  def supported_styles(); end

  def unexpected_style_detected(unexpected); end

  def unrecognized_style_detected(); end
end

module RuboCop::Cop::ConfigurableEnforcedStyle
end

module RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def check_name(node, name, name_range); end

  def class_emitter_method?(node, name); end

  def report_opposing_styles(node, name); end

  def valid_name?(node, name, given_style=T.unsafe(nil)); end
end

module RuboCop::Cop::ConfigurableFormatting
end

module RuboCop::Cop::ConfigurableMax
end

module RuboCop::Cop::ConfigurableMax
end

module RuboCop::Cop::ConfigurableNaming
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  FORMATS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::ConfigurableNaming
end

module RuboCop::Cop::ConfigurableNumbering
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  FORMATS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::ConfigurableNumbering
end

class RuboCop::Cop::Cop
  include ::RuboCop::AST::Sexp
  include ::RuboCop::Cop::Util
  include ::RuboCop::PathUtil
  include ::RuboCop::Cop::IgnoredNode
  include ::RuboCop::Cop::AutocorrectLogic
  def add_offense(node, location: T.unsafe(nil), message: T.unsafe(nil), severity: T.unsafe(nil)); end

  def config(); end

  def config_to_allow_offenses(); end

  def config_to_allow_offenses=(hash); end

  def cop_config(); end

  def cop_name(); end

  def correct(node); end

  def corrections(); end

  def disable_uncorrectable(node); end

  def duplicate_location?(location); end

  def excluded_file?(file); end

  def external_dependency_checksum(); end

  def find_location(node, loc); end

  def initialize(config=T.unsafe(nil), options=T.unsafe(nil)); end

  def join_force?(_force_class); end

  def message(_node=T.unsafe(nil)); end

  def name(); end

  def offenses(); end

  def parse(source, path=T.unsafe(nil)); end

  def processed_source(); end

  def processed_source=(processed_source); end

  def reason_to_not_correct(node); end

  def relevant_file?(file); end

  def target_rails_version(); end

  def target_ruby_version(); end
end

class RuboCop::Cop::Cop::Correction
  def call(corrector); end

  def cop(); end

  def cop=(_); end

  def lambda=(_); end

  def node(); end

  def node=(_); end
end

class RuboCop::Cop::Cop::Correction
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Cop::Cop
  extend ::RuboCop::AST::Sexp
  extend ::RuboCop::NodePattern::Macros
  def self.all(); end

  def self.autocorrect_incompatible_with(); end

  def self.badge(); end

  def self.cop_name(); end

  def self.department(); end

  def self.inherited(subclass); end

  def self.lint?(); end

  def self.match?(given_names); end

  def self.qualified_cop_name(name, origin); end

  def self.registry(); end
end

class RuboCop::Cop::Corrector
  def corrections(); end

  def diagnostics(); end

  def initialize(source_buffer, corrections=T.unsafe(nil)); end

  def insert_after(range, content); end

  def insert_before(range, content); end

  def remove(range); end

  def remove_leading(range, size); end

  def remove_preceding(range, size); end

  def remove_trailing(range, size); end

  def replace(range, content); end

  def rewrite(); end
end

class RuboCop::Cop::Corrector
end

module RuboCop::Cop::DefNode
  def non_public_modifier?(node=T.unsafe(nil)); end
  NON_PUBLIC_MODIFIERS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::DefNode
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::Cop::DocumentationComment
  include ::RuboCop::Cop::Style::AnnotationComment
end

module RuboCop::Cop::DocumentationComment
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::Cop::Duplication
end

module RuboCop::Cop::Duplication
end

class RuboCop::Cop::EachToForCorrector
  def call(corrector); end

  def initialize(block_node); end
  CORRECTION_WITHOUT_ARGUMENTS = ::T.let(nil, ::T.untyped)
  CORRECTION_WITH_ARGUMENTS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::EachToForCorrector
  extend ::RuboCop::NodePattern::Macros
end

class RuboCop::Cop::EmptyLineCorrector
end

class RuboCop::Cop::EmptyLineCorrector
  def self.correct(node); end

  def self.insert_before(node); end
end

module RuboCop::Cop::EmptyParameter
  def empty_arguments?(node=T.unsafe(nil)); end
end

module RuboCop::Cop::EmptyParameter
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::EndKeywordAlignment
end

module RuboCop::Cop::EnforceSuperclass
  def on_class(node); end

  def on_send(node); end
end

module RuboCop::Cop::EnforceSuperclass
  def self.included(base); end
end

module RuboCop::Cop::FirstElementLineBreak
end

module RuboCop::Cop::FirstElementLineBreak
end

class RuboCop::Cop::ForToEachCorrector
  def call(corrector); end

  def initialize(for_node); end
  CORRECTION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::ForToEachCorrector
  extend ::RuboCop::NodePattern::Macros
end

class RuboCop::Cop::Force
  def cops(); end

  def initialize(cops); end

  def investigate(_processed_source); end

  def name(); end

  def run_hook(method_name, *args); end
end

class RuboCop::Cop::Force
  def self.all(); end

  def self.force_name(); end

  def self.inherited(subclass); end
end

module RuboCop::Cop::FrozenStringLiteral
  FROZEN_STRING_LITERAL = ::T.let(nil, ::T.untyped)
  FROZEN_STRING_LITERAL_ENABLED = ::T.let(nil, ::T.untyped)
  FROZEN_STRING_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::FrozenStringLiteral
  def self.frozen_string_literal_comment_exists?(); end
end

module RuboCop::Cop::Gemspec
end

class RuboCop::Cop::Gemspec::DuplicatedAssignment
  include ::RuboCop::Cop::RangeHelp
  def assignment_method_declarations(node0); end

  def gem_specification(node0); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::DuplicatedAssignment
end

class RuboCop::Cop::Gemspec::OrderedDependencies
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::OrderedGemNode
  def autocorrect(node); end

  def dependency_declarations(node0); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::OrderedDependencies
end

class RuboCop::Cop::Gemspec::RequiredRubyVersion
  def investigate(processed_source); end

  def required_ruby_version(node0); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::RequiredRubyVersion
end

class RuboCop::Cop::Gemspec::RubyVersionGlobalsUsage
  def gem_specification?(node0); end

  def on_const(node); end

  def ruby_version?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::RubyVersionGlobalsUsage
end

module RuboCop::Cop::Gemspec
end

class RuboCop::Cop::Generator
  def initialize(name, github_user, output: T.unsafe(nil)); end

  def inject_config(config_file_path: T.unsafe(nil)); end

  def inject_require(root_file_path: T.unsafe(nil)); end

  def todo(); end

  def write_source(); end

  def write_spec(); end
  CONFIGURATION_ADDED_MESSAGE = ::T.let(nil, ::T.untyped)
  SOURCE_TEMPLATE = ::T.let(nil, ::T.untyped)
  SPEC_TEMPLATE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Generator::ConfigurationInjector
  def initialize(configuration_file_path:, badge:, version_added:); end

  def inject(); end
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Generator::ConfigurationInjector
end

class RuboCop::Cop::Generator::RequireFileInjector
  def initialize(source_path:, root_file_path:, output: T.unsafe(nil)); end

  def inject(); end
  REQUIRE_PATH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Generator::RequireFileInjector
end

class RuboCop::Cop::Generator
end

module RuboCop::Cop::HashAlignmentStyles
end

class RuboCop::Cop::HashAlignmentStyles::KeyAlignment
  def checkable_layout?(_node); end

  def deltas(first_pair, current_pair); end

  def deltas_for_first_pair(first_pair, _node); end
end

class RuboCop::Cop::HashAlignmentStyles::KeyAlignment
end

class RuboCop::Cop::HashAlignmentStyles::SeparatorAlignment
  include ::RuboCop::Cop::HashAlignmentStyles::ValueAlignment
  def deltas_for_first_pair(*_nodes); end
end

class RuboCop::Cop::HashAlignmentStyles::SeparatorAlignment
end

class RuboCop::Cop::HashAlignmentStyles::TableAlignment
  include ::RuboCop::Cop::HashAlignmentStyles::ValueAlignment
  def deltas_for_first_pair(first_pair, node); end
end

class RuboCop::Cop::HashAlignmentStyles::TableAlignment
end

module RuboCop::Cop::HashAlignmentStyles::ValueAlignment
  def checkable_layout?(node); end

  def deltas(first_pair, current_pair); end
end

module RuboCop::Cop::HashAlignmentStyles::ValueAlignment
end

module RuboCop::Cop::HashAlignmentStyles
end

module RuboCop::Cop::Heredoc
  def on_dstr(node); end

  def on_heredoc(_node); end

  def on_str(node); end

  def on_xstr(node); end
  OPENING_DELIMITER = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Heredoc
end

module RuboCop::Cop::IgnoredMethods
end

module RuboCop::Cop::IgnoredMethods
end

module RuboCop::Cop::IgnoredNode
  def ignore_node(node); end

  def ignored_node?(node); end

  def part_of_ignored_node?(node); end
end

module RuboCop::Cop::IgnoredNode
end

module RuboCop::Cop::IgnoredPattern
end

module RuboCop::Cop::IgnoredPattern
end

module RuboCop::Cop::IntegerNode
end

module RuboCop::Cop::IntegerNode
end

module RuboCop::Cop::Interpolation
  def on_dstr(node); end

  def on_dsym(node); end

  def on_node_with_interpolations(node); end

  def on_regexp(node); end

  def on_xstr(node); end
end

module RuboCop::Cop::Interpolation
end

class RuboCop::Cop::LambdaLiteralToMethodCorrector
  def call(corrector); end

  def initialize(block_node); end
end

class RuboCop::Cop::LambdaLiteralToMethodCorrector
end

module RuboCop::Cop::Layout
end

class RuboCop::Cop::Layout::AccessModifierIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end

  def on_class(node); end

  def on_module(node); end

  def on_sclass(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::AccessModifierIndentation
end

class RuboCop::Cop::Layout::ArgumentAlignment
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_csend(node); end

  def on_send(node); end
  ALIGN_PARAMS_MSG = ::T.let(nil, ::T.untyped)
  FIXED_INDENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ArgumentAlignment
end

class RuboCop::Cop::Layout::ArrayAlignment
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_array(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ArrayAlignment
end

class RuboCop::Cop::Layout::AssignmentIndentation
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def check_assignment(node, rhs); end

  def leftmost_multiple_assignment(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::AssignmentIndentation
end

class RuboCop::Cop::Layout::BlockAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def block_end_align_target?(node=T.unsafe(nil), param1); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::BlockAlignment
end

class RuboCop::Cop::Layout::BlockEndNewline
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::BlockEndNewline
end

class RuboCop::Cop::Layout::CaseIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_case(case_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::CaseIndentation
end

class RuboCop::Cop::Layout::ClassStructure
  def autocorrect(node); end

  def on_class(class_node); end

  def visibility_block?(node=T.unsafe(nil)); end
  HUMANIZED_NODE_TYPE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  VISIBILITY_SCOPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ClassStructure
end

class RuboCop::Cop::Layout::ClosingHeredocIndentation
  include ::RuboCop::Cop::Heredoc
  def autocorrect(node); end

  def on_heredoc(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_ARG = ::T.let(nil, ::T.untyped)
  SIMPLE_HEREDOC = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ClosingHeredocIndentation
end

class RuboCop::Cop::Layout::ClosingParenthesisIndentation
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_begin(node); end

  def on_csend(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end
  MSG_ALIGN = ::T.let(nil, ::T.untyped)
  MSG_INDENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ClosingParenthesisIndentation
end

class RuboCop::Cop::Layout::CommentIndentation
  include ::RuboCop::Cop::Alignment
  def autocorrect(comment); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::CommentIndentation
end

class RuboCop::Cop::Layout::ConditionPosition
  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ConditionPosition
end

class RuboCop::Cop::Layout::DefEndAlignment
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::DefEndAlignment
end

class RuboCop::Cop::Layout::DotPosition
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Layout::DotPosition
end

class RuboCop::Cop::Layout::ElseAlignment
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::CheckAssignment
  def autocorrect(node); end

  def on_case(node); end

  def on_if(node, base=T.unsafe(nil)); end

  def on_rescue(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ElseAlignment
end

class RuboCop::Cop::Layout::EmptyComment
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyComment
end

class RuboCop::Cop::Layout::EmptyLineAfterGuardClause
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_if(node); end
  END_OF_HEREDOC_LINE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineAfterGuardClause
end

class RuboCop::Cop::Layout::EmptyLineAfterMagicComment
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(token); end

  def investigate(source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineAfterMagicComment
end

class RuboCop::Cop::Layout::EmptyLineBetweenDefs
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def check_defs(nodes); end

  def on_begin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineBetweenDefs
end

class RuboCop::Cop::Layout::EmptyLines
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(processed_source); end
  LINE_OFFSET = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLines
end

class RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end

  def on_class(node); end

  def on_module(node); end

  def on_sclass(node); end

  def on_send(node); end
  MSG_AFTER = ::T.let(nil, ::T.untyped)
  MSG_AFTER_FOR_ONLY_BEFORE = ::T.let(nil, ::T.untyped)
  MSG_BEFORE_AND_AFTER = ::T.let(nil, ::T.untyped)
  MSG_BEFORE_FOR_ONLY_BEFORE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier
end

class RuboCop::Cop::Layout::EmptyLinesAroundArguments
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundArguments
end

class RuboCop::Cop::Layout::EmptyLinesAroundBeginBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_kwbegin(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundBeginBody
end

class RuboCop::Cop::Layout::EmptyLinesAroundBlockBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundBlockBody
end

module RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def constant_definition?(node=T.unsafe(nil)); end

  def empty_line_required?(node=T.unsafe(nil)); end
  MSG_DEFERRED = ::T.let(nil, ::T.untyped)
  MSG_EXTRA = ::T.let(nil, ::T.untyped)
  MSG_MISSING = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Layout::EmptyLinesAroundBody
  extend ::RuboCop::NodePattern::Macros
end

class RuboCop::Cop::Layout::EmptyLinesAroundClassBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_class(node); end

  def on_sclass(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundClassBody
end

class RuboCop::Cop::Layout::EmptyLinesAroundExceptionHandlingKeywords
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_kwbegin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundExceptionHandlingKeywords
end

class RuboCop::Cop::Layout::EmptyLinesAroundMethodBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundMethodBody
end

class RuboCop::Cop::Layout::EmptyLinesAroundModuleBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_module(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundModuleBody
end

class RuboCop::Cop::Layout::EndAlignment
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_case(node); end

  def on_class(node); end

  def on_if(node); end

  def on_module(node); end

  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Layout::EndAlignment
end

class RuboCop::Cop::Layout::EndOfLine
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def investigate(processed_source); end

  def offense_message(line); end

  def unimportant_missing_cr?(index, last_line, line); end
  MSG_DETECTED = ::T.let(nil, ::T.untyped)
  MSG_MISSING = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EndOfLine
end

class RuboCop::Cop::Layout::ExtraSpacing
  include ::RuboCop::Cop::PrecedingFollowingAlignment
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(processed_source); end
  MSG_UNALIGNED_ASGN = ::T.let(nil, ::T.untyped)
  MSG_UNNECESSARY = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ExtraSpacing
end

class RuboCop::Cop::Layout::FirstArgumentIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def eligible_method_call?(node=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstArgumentIndentation
end

class RuboCop::Cop::Layout::FirstArrayElementIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineElementIndentation
  def autocorrect(node); end

  def on_array(node); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstArrayElementIndentation
end

class RuboCop::Cop::Layout::FirstArrayElementLineBreak
  include ::RuboCop::Cop::FirstElementLineBreak
  def autocorrect(node); end

  def on_array(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstArrayElementLineBreak
end

class RuboCop::Cop::Layout::FirstHashElementIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineElementIndentation
  def autocorrect(node); end

  def on_csend(node); end

  def on_hash(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstHashElementIndentation
end

class RuboCop::Cop::Layout::FirstHashElementLineBreak
  include ::RuboCop::Cop::FirstElementLineBreak
  def autocorrect(node); end

  def on_hash(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstHashElementLineBreak
end

class RuboCop::Cop::Layout::FirstMethodArgumentLineBreak
  include ::RuboCop::Cop::FirstElementLineBreak
  def autocorrect(node); end

  def on_csend(node); end

  def on_send(node); end

  def on_super(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstMethodArgumentLineBreak
end

class RuboCop::Cop::Layout::FirstMethodParameterLineBreak
  include ::RuboCop::Cop::FirstElementLineBreak
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstMethodParameterLineBreak
end

class RuboCop::Cop::Layout::FirstParameterIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineElementIndentation
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstParameterIndentation
end

class RuboCop::Cop::Layout::HashAlignment
  include ::RuboCop::Cop::HashAlignmentStyles
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def column_deltas(); end

  def column_deltas=(column_deltas); end

  def offences_by(); end

  def offences_by=(offences_by); end

  def on_hash(node); end

  def on_send(node); end

  def on_super(node); end

  def on_yield(node); end
  MESSAGES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::HashAlignment
end

class RuboCop::Cop::Layout::HeredocArgumentClosingParenthesis
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::HeredocArgumentClosingParenthesis
end

class RuboCop::Cop::Layout::HeredocIndentation
  include ::RuboCop::Cop::Heredoc
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_heredoc(node); end
  LIBRARY_MSG = ::T.let(nil, ::T.untyped)
  RUBY23_TYPE_MSG = ::T.let(nil, ::T.untyped)
  RUBY23_WIDTH_MSG = ::T.let(nil, ::T.untyped)
  STRIP_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::HeredocIndentation
end

class RuboCop::Cop::Layout::IndentationConsistency
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_begin(node); end

  def on_kwbegin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentationConsistency
end

class RuboCop::Cop::Layout::IndentationWidth
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::IgnoredPattern
  def access_modifier?(node=T.unsafe(nil)); end

  def autocorrect(node); end

  def on_block(node); end

  def on_case(case_node); end

  def on_class(node); end

  def on_csend(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_ensure(node); end

  def on_for(node); end

  def on_if(node, base=T.unsafe(nil)); end

  def on_kwbegin(node); end

  def on_module(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_sclass(node); end

  def on_until(node, base=T.unsafe(nil)); end

  def on_while(node, base=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentationWidth
end

class RuboCop::Cop::Layout::InitialIndentation
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(_processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::InitialIndentation
end

class RuboCop::Cop::Layout::LeadingCommentSpace
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(comment); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::LeadingCommentSpace
end

class RuboCop::Cop::Layout::LeadingEmptyLines
  def autocorrect(node); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::LeadingEmptyLines
end

class RuboCop::Cop::Layout::LineLength
  include ::RuboCop::Cop::CheckLineBreakable
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::IgnoredPattern
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::LineLengthHelp
  def autocorrect(range); end

  def investigate(processed_source); end

  def investigate_post_walk(processed_source); end

  def on_array(node); end

  def on_hash(node); end

  def on_potential_breakable_node(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::LineLength
end

class RuboCop::Cop::Layout::MultilineArrayBraceLayout
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_array(node); end
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineArrayBraceLayout
end

class RuboCop::Cop::Layout::MultilineArrayLineBreaks
  include ::RuboCop::Cop::MultilineElementLineBreaks
  def autocorrect(node); end

  def on_array(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineArrayLineBreaks
end

class RuboCop::Cop::Layout::MultilineAssignmentLayout
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def check_assignment(node, rhs); end

  def check_by_enforced_style(node, rhs); end

  def check_new_line_offense(node, rhs); end

  def check_same_line_offense(node, rhs); end
  NEW_LINE_OFFENSE = ::T.let(nil, ::T.untyped)
  SAME_LINE_OFFENSE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineAssignmentLayout
end

class RuboCop::Cop::Layout::MultilineBlockLayout
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end
  ARG_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PIPE_SIZE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineBlockLayout
end

class RuboCop::Cop::Layout::MultilineHashBraceLayout
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_hash(node); end
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineHashBraceLayout
end

class RuboCop::Cop::Layout::MultilineHashKeyLineBreaks
  include ::RuboCop::Cop::MultilineElementLineBreaks
  def autocorrect(node); end

  def on_hash(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineHashKeyLineBreaks
end

class RuboCop::Cop::Layout::MultilineMethodArgumentLineBreaks
  include ::RuboCop::Cop::MultilineElementLineBreaks
  def autocorrect(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodArgumentLineBreaks
end

class RuboCop::Cop::Layout::MultilineMethodCallBraceLayout
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_send(node); end
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodCallBraceLayout
end

class RuboCop::Cop::Layout::MultilineMethodCallIndentation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::MultilineExpressionIndentation
  def autocorrect(node); end

  def validate_config(); end
end

class RuboCop::Cop::Layout::MultilineMethodCallIndentation
end

class RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout
end

class RuboCop::Cop::Layout::MultilineOperationIndentation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::MultilineExpressionIndentation
  def autocorrect(node); end

  def on_and(node); end

  def on_or(node); end

  def validate_config(); end
end

class RuboCop::Cop::Layout::MultilineOperationIndentation
end

class RuboCop::Cop::Layout::ParameterAlignment
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  ALIGN_PARAMS_MSG = ::T.let(nil, ::T.untyped)
  FIXED_INDENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ParameterAlignment
end

class RuboCop::Cop::Layout::RescueEnsureAlignment
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def investigate(processed_source); end

  def on_ensure(node); end

  def on_resbody(node); end
  ALTERNATIVE_ACCESS_MODIFIERS = ::T.let(nil, ::T.untyped)
  ANCESTOR_TYPES = ::T.let(nil, ::T.untyped)
  ANCESTOR_TYPES_WITH_ACCESS_MODIFIERS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RUBY_2_5_ANCESTOR_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::RescueEnsureAlignment
end

class RuboCop::Cop::Layout::SpaceAfterColon
  def autocorrect(range); end

  def on_kwoptarg(node); end

  def on_pair(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterColon
end

class RuboCop::Cop::Layout::SpaceAfterComma
  include ::RuboCop::Cop::SpaceAfterPunctuation
  def autocorrect(comma); end

  def kind(token); end

  def space_style_before_rcurly(); end
end

class RuboCop::Cop::Layout::SpaceAfterComma
end

class RuboCop::Cop::Layout::SpaceAfterMethodName
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(pos_before_left_paren); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterMethodName
end

class RuboCop::Cop::Layout::SpaceAfterNot
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end

  def whitespace_after_operator?(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterNot
end

class RuboCop::Cop::Layout::SpaceAfterSemicolon
  include ::RuboCop::Cop::SpaceAfterPunctuation
  def autocorrect(semicolon); end

  def kind(token); end

  def space_style_before_rcurly(); end
end

class RuboCop::Cop::Layout::SpaceAfterSemicolon
end

class RuboCop::Cop::Layout::SpaceAroundBlockParameters
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(target); end

  def on_block(node); end
end

class RuboCop::Cop::Layout::SpaceAroundBlockParameters
end

class RuboCop::Cop::Layout::SpaceAroundEqualsInParameterDefault
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(range); end

  def on_optarg(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundEqualsInParameterDefault
end

class RuboCop::Cop::Layout::SpaceAroundKeyword
  def autocorrect(range); end

  def on_and(node); end

  def on_block(node); end

  def on_break(node); end

  def on_case(node); end

  def on_defined?(node); end

  def on_ensure(node); end

  def on_for(node); end

  def on_if(node); end

  def on_kwbegin(node); end

  def on_next(node); end

  def on_or(node); end

  def on_postexe(node); end

  def on_preexe(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_return(node); end

  def on_send(node); end

  def on_super(node); end

  def on_until(node); end

  def on_when(node); end

  def on_while(node); end

  def on_yield(node); end

  def on_zsuper(node); end
  ACCEPT_LEFT_PAREN = ::T.let(nil, ::T.untyped)
  ACCEPT_LEFT_SQUARE_BRACKET = ::T.let(nil, ::T.untyped)
  ACCEPT_NAMESPACE_OPERATOR = ::T.let(nil, ::T.untyped)
  DO = ::T.let(nil, ::T.untyped)
  MSG_AFTER = ::T.let(nil, ::T.untyped)
  MSG_BEFORE = ::T.let(nil, ::T.untyped)
  NAMESPACE_OPERATOR = ::T.let(nil, ::T.untyped)
  SAFE_NAVIGATION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundKeyword
end

class RuboCop::Cop::Layout::SpaceAroundOperators
  include ::RuboCop::Cop::PrecedingFollowingAlignment
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::RationalLiteral
  def autocorrect(range); end

  def on_and(node); end

  def on_and_asgn(node); end

  def on_assignment(node); end

  def on_binary(node); end

  def on_casgn(node); end

  def on_class(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_if(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_op_asgn(node); end

  def on_or(node); end

  def on_or_asgn(node); end

  def on_pair(node); end

  def on_resbody(node); end

  def on_send(node); end

  def on_special_asgn(node); end
  EXCESSIVE_SPACE = ::T.let(nil, ::T.untyped)
  IRREGULAR_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundOperators
end

class RuboCop::Cop::Layout::SpaceBeforeBlockBraces
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def on_block(node); end
  DETECTED_MSG = ::T.let(nil, ::T.untyped)
  MISSING_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeBlockBraces
end

class RuboCop::Cop::Layout::SpaceBeforeComma
  include ::RuboCop::Cop::SpaceBeforePunctuation
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(space); end

  def kind(token); end
end

class RuboCop::Cop::Layout::SpaceBeforeComma
end

class RuboCop::Cop::Layout::SpaceBeforeComment
  def autocorrect(range); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeComment
end

class RuboCop::Cop::Layout::SpaceBeforeFirstArg
  include ::RuboCop::Cop::PrecedingFollowingAlignment
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeFirstArg
end

class RuboCop::Cop::Layout::SpaceBeforeSemicolon
  include ::RuboCop::Cop::SpaceBeforePunctuation
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(space); end

  def kind(token); end
end

class RuboCop::Cop::Layout::SpaceBeforeSemicolon
end

class RuboCop::Cop::Layout::SpaceInLambdaLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(lambda_node); end

  def on_send(node); end
  MSG_REQUIRE_NO_SPACE = ::T.let(nil, ::T.untyped)
  MSG_REQUIRE_SPACE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInLambdaLiteral
end

class RuboCop::Cop::Layout::SpaceInsideArrayLiteralBrackets
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_array(node); end
  EMPTY_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideArrayLiteralBrackets
end

class RuboCop::Cop::Layout::SpaceInsideArrayPercentLiteral
  include ::RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_array(node); end

  def on_percent_literal(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MULTIPLE_SPACES_BETWEEN_ITEMS_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideArrayPercentLiteral
end

class RuboCop::Cop::Layout::SpaceInsideBlockBraces
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def on_block(node); end
end

class RuboCop::Cop::Layout::SpaceInsideBlockBraces
end

class RuboCop::Cop::Layout::SpaceInsideHashLiteralBraces
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(range); end

  def on_hash(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideHashLiteralBraces
end

class RuboCop::Cop::Layout::SpaceInsideParens
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(range); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_SPACE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideParens
end

class RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters
  include ::RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_array(node); end

  def on_percent_literal(node); end

  def on_xstr(node); end
  BEGIN_REGEX = ::T.let(nil, ::T.untyped)
  END_REGEX = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters
end

class RuboCop::Cop::Layout::SpaceInsideRangeLiteral
  def autocorrect(node); end

  def on_erange(node); end

  def on_irange(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideRangeLiteral
end

class RuboCop::Cop::Layout::SpaceInsideReferenceBrackets
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_send(node); end
  BRACKET_METHODS = ::T.let(nil, ::T.untyped)
  EMPTY_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideReferenceBrackets
end

class RuboCop::Cop::Layout::SpaceInsideStringInterpolation
  include ::RuboCop::Cop::Interpolation
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(begin_node); end

  def on_interpolation(begin_node); end
  NO_SPACE_MSG = ::T.let(nil, ::T.untyped)
  SPACE_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideStringInterpolation
end

class RuboCop::Cop::Layout::Tab
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::Tab
end

class RuboCop::Cop::Layout::TrailingEmptyLines
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(processed_source); end
end

class RuboCop::Cop::Layout::TrailingEmptyLines
end

class RuboCop::Cop::Layout::TrailingWhitespace
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::TrailingWhitespace
end

module RuboCop::Cop::Layout
end

class RuboCop::Cop::LineBreakCorrector
end

class RuboCop::Cop::LineBreakCorrector
  extend ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::TrailingBody
  extend ::RuboCop::Cop::Util
  extend ::RuboCop::PathUtil
  def self.break_line_before(range:, node:, corrector:, configured_width:, indent_steps: T.unsafe(nil)); end

  def self.correct_trailing_body(configured_width:, corrector:, node:, processed_source:); end

  def self.move_comment(eol_comment:, node:, corrector:); end

  def self.processed_source(); end
end

module RuboCop::Cop::LineLengthHelp
end

module RuboCop::Cop::LineLengthHelp
end

module RuboCop::Cop::Lint
end

class RuboCop::Cop::Lint::AmbiguousBlockAssociation
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousBlockAssociation
end

class RuboCop::Cop::Lint::AmbiguousOperator
  include ::RuboCop::Cop::ParserDiagnostic
  AMBIGUITIES = ::T.let(nil, ::T.untyped)
  MSG_FORMAT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousOperator
end

class RuboCop::Cop::Lint::AmbiguousRegexpLiteral
  include ::RuboCop::Cop::ParserDiagnostic
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousRegexpLiteral
end

class RuboCop::Cop::Lint::AssignmentInCondition
  include ::RuboCop::Cop::SafeAssignment
  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
  ASGN_TYPES = ::T.let(nil, ::T.untyped)
  MSG_WITHOUT_SAFE_ASSIGNMENT_ALLOWED = ::T.let(nil, ::T.untyped)
  MSG_WITH_SAFE_ASSIGNMENT_ALLOWED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AssignmentInCondition
end

class RuboCop::Cop::Lint::BigDecimalNew
  def autocorrect(node); end

  def big_decimal_new(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::BigDecimalNew
end

class RuboCop::Cop::Lint::BooleanSymbol
  def boolean_symbol?(node=T.unsafe(nil)); end

  def on_sym(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::BooleanSymbol
end

class RuboCop::Cop::Lint::CircularArgumentReference
  def on_kwoptarg(node); end

  def on_optarg(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::CircularArgumentReference
end

class RuboCop::Cop::Lint::Debugger
  def binding_irb_call?(node=T.unsafe(nil)); end

  def debugger_call?(node=T.unsafe(nil)); end

  def kernel?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Debugger
end

class RuboCop::Cop::Lint::DeprecatedClassMethods
  def autocorrect(node); end

  def on_send(node); end
  DEPRECATED_METHODS_OBJECT = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DeprecatedClassMethods::DeprecatedClassMethod
  include ::RuboCop::AST::Sexp
  def class_constant(); end

  def class_nodes(); end

  def deprecated_method(); end

  def initialize(deprecated:, replacement:, class_constant: T.unsafe(nil)); end

  def replacement_method(); end
end

class RuboCop::Cop::Lint::DeprecatedClassMethods::DeprecatedClassMethod
end

class RuboCop::Cop::Lint::DeprecatedClassMethods
end

class RuboCop::Cop::Lint::DisjunctiveAssignmentInConstructor
  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DisjunctiveAssignmentInConstructor
end

class RuboCop::Cop::Lint::DuplicateCaseCondition
  def on_case(case_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateCaseCondition
end

class RuboCop::Cop::Lint::DuplicateHashKey
  include ::RuboCop::Cop::Duplication
  def on_hash(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateHashKey
end

class RuboCop::Cop::Lint::DuplicateMethods
  def alias_method?(node=T.unsafe(nil)); end

  def attr?(node=T.unsafe(nil)); end

  def method_alias?(node=T.unsafe(nil)); end

  def on_alias(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end

  def sym_name(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateMethods
end

class RuboCop::Cop::Lint::EachWithObjectArgument
  def each_with_object?(node=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EachWithObjectArgument
end

class RuboCop::Cop::Lint::ElseLayout
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ElseLayout
end

class RuboCop::Cop::Lint::EmptyEnsure
  def autocorrect(node); end

  def on_ensure(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyEnsure
end

class RuboCop::Cop::Lint::EmptyExpression
  def on_begin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyExpression
end

class RuboCop::Cop::Lint::EmptyInterpolation
  include ::RuboCop::Cop::Interpolation
  def autocorrect(node); end

  def on_interpolation(begin_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyInterpolation
end

class RuboCop::Cop::Lint::EmptyWhen
  def on_case(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyWhen
end

class RuboCop::Cop::Lint::EndInMethod
  def on_postexe(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EndInMethod
end

class RuboCop::Cop::Lint::EnsureReturn
  def on_ensure(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EnsureReturn
end

class RuboCop::Cop::Lint::ErbNewArguments
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def erb_new_with_non_keyword_arguments(node=T.unsafe(nil)); end

  def on_send(node); end
  MESSAGES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ErbNewArguments
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Lint::FlipFlop
  def on_eflipflop(node); end

  def on_iflipflop(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FlipFlop
end

class RuboCop::Cop::Lint::FloatOutOfRange
  def on_float(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FloatOutOfRange
end

class RuboCop::Cop::Lint::FormatParameterMismatch
  def called_on_string?(node=T.unsafe(nil)); end

  def on_send(node); end
  KERNEL = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SHOVEL = ::T.let(nil, ::T.untyped)
  STRING_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FormatParameterMismatch
end

class RuboCop::Cop::Lint::HeredocMethodCallPosition
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::HeredocMethodCallPosition
end

class RuboCop::Cop::Lint::ImplicitStringConcatenation
  def on_dstr(node); end
  FOR_ARRAY = ::T.let(nil, ::T.untyped)
  FOR_METHOD = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ImplicitStringConcatenation
end

class RuboCop::Cop::Lint::IneffectiveAccessModifier
  def on_class(node); end

  def on_module(node); end

  def private_class_methods(node0); end
  ALTERNATIVE_PRIVATE = ::T.let(nil, ::T.untyped)
  ALTERNATIVE_PROTECTED = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::IneffectiveAccessModifier
end

class RuboCop::Cop::Lint::InheritException
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def class_new_call?(node=T.unsafe(nil)); end

  def on_class(node); end

  def on_send(node); end
  ILLEGAL_CLASSES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PREFERRED_BASE_CLASS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::InheritException
end

class RuboCop::Cop::Lint::InterpolationCheck
  def heredoc?(node); end

  def on_str(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::InterpolationCheck
end

class RuboCop::Cop::Lint::LiteralAsCondition
  def message(node); end

  def on_case(case_node); end

  def on_if(node); end

  def on_send(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::LiteralAsCondition
end

class RuboCop::Cop::Lint::LiteralInInterpolation
  include ::RuboCop::Cop::Interpolation
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_interpolation(begin_node); end
  COMPOSITE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::LiteralInInterpolation
end

class RuboCop::Cop::Lint::Loop
  def on_until_post(node); end

  def on_while_post(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Loop
end

class RuboCop::Cop::Lint::MissingCopEnableDirective
  include ::RuboCop::Cop::RangeHelp
  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_BOUND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MissingCopEnableDirective
end

class RuboCop::Cop::Lint::MultipleComparison
  def autocorrect(node); end

  def multiple_compare?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MultipleComparison
end

class RuboCop::Cop::Lint::NestedMethodDefinition
  def class_or_module_or_struct_new_call?(node=T.unsafe(nil)); end

  def eval_call?(node=T.unsafe(nil)); end

  def exec_call?(node=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NestedMethodDefinition
end

class RuboCop::Cop::Lint::NestedPercentLiteral
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_array(node); end

  def on_percent_literal(node); end
  MSG = ::T.let(nil, ::T.untyped)
  PERCENT_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
  REGEXES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NestedPercentLiteral
end

class RuboCop::Cop::Lint::NextWithoutAccumulator
  def on_block(node); end

  def on_body_of_reduce(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NextWithoutAccumulator
end

class RuboCop::Cop::Lint::NonDeterministicRequireOrder
  def autocorrect(node); end

  def loop_variable(node=T.unsafe(nil)); end

  def on_block(node); end

  def unsorted_dir_block?(node=T.unsafe(nil)); end

  def unsorted_dir_each?(node=T.unsafe(nil)); end

  def var_is_required?(node0, param1); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NonDeterministicRequireOrder
end

class RuboCop::Cop::Lint::NonLocalExitFromIterator
  def chained_send?(node=T.unsafe(nil)); end

  def define_method?(node=T.unsafe(nil)); end

  def on_return(return_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NonLocalExitFromIterator
end

class RuboCop::Cop::Lint::NumberConversion
  def autocorrect(node); end

  def datetime?(node=T.unsafe(nil)); end

  def on_send(node); end

  def to_method(node=T.unsafe(nil)); end
  CONVERSION_METHOD_CLASS_MAPPING = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NumberConversion
end

class RuboCop::Cop::Lint::OrderedMagicComments
  include ::RuboCop::Cop::FrozenStringLiteral
  def autocorrect(_node); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::OrderedMagicComments
end

class RuboCop::Cop::Lint::ParenthesesAsGroupedExpression
  include ::RuboCop::Cop::RangeHelp
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ParenthesesAsGroupedExpression
end

class RuboCop::Cop::Lint::PercentStringArray
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_array(node); end

  def on_percent_literal(node); end
  LEADING_QUOTE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  QUOTES_AND_COMMAS = ::T.let(nil, ::T.untyped)
  TRAILING_QUOTE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::PercentStringArray
end

class RuboCop::Cop::Lint::PercentSymbolArray
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_array(node); end

  def on_percent_literal(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::PercentSymbolArray
end

class RuboCop::Cop::Lint::RandOne
  def on_send(node); end

  def rand_one?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RandOne
end

class RuboCop::Cop::Lint::RedundantCopDisableDirective
  include ::RuboCop::NameSimilarity
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(args); end

  def check(offenses, cop_disabled_line_ranges, comments); end
  COP_NAME = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantCopDisableDirective
end

class RuboCop::Cop::Lint::RedundantCopEnableDirective
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(comment_and_name); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantCopEnableDirective
end

class RuboCop::Cop::Lint::RedundantRequireStatement
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end

  def unnecessary_require_statement?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantRequireStatement
end

class RuboCop::Cop::Lint::RedundantSplatExpansion
  def array_new?(node=T.unsafe(nil)); end

  def autocorrect(node); end

  def literal_expansion(node=T.unsafe(nil)); end

  def on_splat(node); end
  ARRAY_PARAM_MSG = ::T.let(nil, ::T.untyped)
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PERCENT_CAPITAL_I = ::T.let(nil, ::T.untyped)
  PERCENT_CAPITAL_W = ::T.let(nil, ::T.untyped)
  PERCENT_I = ::T.let(nil, ::T.untyped)
  PERCENT_W = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantSplatExpansion
end

class RuboCop::Cop::Lint::RedundantStringCoercion
  include ::RuboCop::Cop::Interpolation
  def autocorrect(node); end

  def on_interpolation(begin_node); end

  def to_s_without_args?(node=T.unsafe(nil)); end
  MSG_DEFAULT = ::T.let(nil, ::T.untyped)
  MSG_SELF = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantStringCoercion
end

class RuboCop::Cop::Lint::RedundantWithIndex
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end

  def redundant_with_index?(node=T.unsafe(nil)); end
  MSG_EACH_WITH_INDEX = ::T.let(nil, ::T.untyped)
  MSG_WITH_INDEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantWithIndex
end

class RuboCop::Cop::Lint::RedundantWithObject
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end

  def redundant_with_object?(node=T.unsafe(nil)); end
  MSG_EACH_WITH_OBJECT = ::T.let(nil, ::T.untyped)
  MSG_WITH_OBJECT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantWithObject
end

class RuboCop::Cop::Lint::RegexpAsCondition
  def on_match_current_line(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RegexpAsCondition
end

class RuboCop::Cop::Lint::RequireParentheses
  include ::RuboCop::Cop::RangeHelp
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RequireParentheses
end

class RuboCop::Cop::Lint::RescueException
  def on_resbody(node); end

  def targets_exception?(rescue_arg_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RescueException
end

class RuboCop::Cop::Lint::RescueType
  include ::RuboCop::Cop::RescueNode
  def autocorrect(node); end

  def on_resbody(node); end
  INVALID_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RescueType
end

class RuboCop::Cop::Lint::ReturnInVoidContext
  def on_return(return_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ReturnInVoidContext
end

class RuboCop::Cop::Lint::SafeNavigationChain
  include ::RuboCop::Cop::NilMethods
  def bad_method?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SafeNavigationChain
end

class RuboCop::Cop::Lint::SafeNavigationConsistency
  include ::RuboCop::Cop::NilMethods
  def autocorrect(node); end

  def check(node); end

  def on_csend(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SafeNavigationConsistency
end

class RuboCop::Cop::Lint::SafeNavigationWithEmpty
  def on_if(node); end

  def safe_navigation_empty_in_conditional?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SafeNavigationWithEmpty
end

class RuboCop::Cop::Lint::ScriptPermission
  def autocorrect(node); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
  SHEBANG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ScriptPermission
end

class RuboCop::Cop::Lint::SendWithMixinArgument
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end

  def send_with_mixin_argument?(node=T.unsafe(nil)); end
  MIXIN_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SendWithMixinArgument
end

class RuboCop::Cop::Lint::ShadowedArgument
  def after_leaving_scope(scope, _variable_table); end

  def join_force?(force_class); end

  def uses_var?(node0, param1); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ShadowedArgument
end

class RuboCop::Cop::Lint::ShadowedException
  include ::RuboCop::Cop::RescueNode
  include ::RuboCop::Cop::RangeHelp
  def on_rescue(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ShadowedException
end

class RuboCop::Cop::Lint::ShadowingOuterLocalVariable
  def before_declaring_variable(variable, variable_table); end

  def join_force?(force_class); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ShadowingOuterLocalVariable
end

class RuboCop::Cop::Lint::SuppressedException
  def on_resbody(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SuppressedException
end

class RuboCop::Cop::Lint::Syntax
  def add_offense_from_diagnostic(diagnostic, ruby_version); end

  def add_offense_from_error(error); end
  ERROR_SOURCE_RANGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Syntax::PseudoSourceRange
  def begin_pos(); end

  def begin_pos=(_); end

  def column(); end

  def column=(_); end

  def end_pos(); end

  def end_pos=(_); end

  def line(); end

  def line=(_); end

  def source_line(); end

  def source_line=(_); end
end

class RuboCop::Cop::Lint::Syntax::PseudoSourceRange
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Cop::Lint::Syntax
  def self.offenses_from_processed_source(processed_source, config, options); end
end

class RuboCop::Cop::Lint::ToJSON
  def autocorrect(node); end

  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ToJSON
end

class RuboCop::Cop::Lint::UnderscorePrefixedVariableName
  def after_leaving_scope(scope, _variable_table); end

  def check_variable(variable); end

  def join_force?(force_class); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnderscorePrefixedVariableName
end

class RuboCop::Cop::Lint::UnifiedInteger
  def autocorrect(node); end

  def fixnum_or_bignum_const(node=T.unsafe(nil)); end

  def on_const(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnifiedInteger
end

class RuboCop::Cop::Lint::UnreachableCode
  def flow_command?(node=T.unsafe(nil)); end

  def on_begin(node); end

  def on_kwbegin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnreachableCode
end

module RuboCop::Cop::Lint::UnusedArgument
  def after_leaving_scope(scope, _variable_table); end

  def join_force?(force_class); end
end

module RuboCop::Cop::Lint::UnusedArgument
  extend ::RuboCop::NodePattern::Macros
end

class RuboCop::Cop::Lint::UnusedBlockArgument
  include ::RuboCop::Cop::Lint::UnusedArgument
  def autocorrect(node); end
end

class RuboCop::Cop::Lint::UnusedBlockArgument
end

class RuboCop::Cop::Lint::UnusedMethodArgument
  include ::RuboCop::Cop::Lint::UnusedArgument
  def autocorrect(node); end
end

class RuboCop::Cop::Lint::UnusedMethodArgument
end

class RuboCop::Cop::Lint::UriEscapeUnescape
  def on_send(node); end

  def uri_escape_unescape?(node=T.unsafe(nil)); end
  ALTERNATE_METHODS_OF_URI_ESCAPE = ::T.let(nil, ::T.untyped)
  ALTERNATE_METHODS_OF_URI_UNESCAPE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UriEscapeUnescape
end

class RuboCop::Cop::Lint::UriRegexp
  def autocorrect(node); end

  def on_send(node); end

  def uri_regexp_with_argument?(node=T.unsafe(nil)); end

  def uri_regexp_without_argument?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UriRegexp
end

class RuboCop::Cop::Lint::UselessAccessModifier
  def class_or_instance_eval?(node=T.unsafe(nil)); end

  def class_or_module_or_struct_new_call?(node=T.unsafe(nil)); end

  def dynamic_method_definition?(node=T.unsafe(nil)); end

  def on_block(node); end

  def on_class(node); end

  def on_module(node); end

  def on_sclass(node); end

  def static_method_definition?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessAccessModifier
end

class RuboCop::Cop::Lint::UselessAssignment
  include ::RuboCop::NameSimilarity
  def after_leaving_scope(scope, _variable_table); end

  def check_for_unused_assignments(variable); end

  def collect_variable_like_names(scope); end

  def join_force?(force_class); end

  def message_for_useless_assignment(assignment); end

  def message_specification(assignment, variable); end

  def multiple_assignment_message(variable_name); end

  def operator_assignment_message(scope, assignment); end

  def return_value_node_of_scope(scope); end

  def similar_name_message(variable); end

  def variable_like_method_invocation?(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessAssignment
end

class RuboCop::Cop::Lint::UselessComparison
  def on_send(node); end

  def useless_comparison?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  OPS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessComparison
end

class RuboCop::Cop::Lint::UselessElseWithoutRescue
  include ::RuboCop::Cop::ParserDiagnostic
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessElseWithoutRescue
end

class RuboCop::Cop::Lint::UselessSetterCall
  def on_def(node); end

  def on_defs(node); end

  def setter_call_to_local_variable?(node=T.unsafe(nil)); end
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessSetterCall::MethodVariableTracker
  def constructor?(node); end

  def contain_local_object?(variable_name); end

  def initialize(body_node); end

  def process_assignment(asgn_node, rhs_node); end

  def process_assignment_node(node); end

  def process_binary_operator_assignment(op_asgn_node); end

  def process_logical_operator_assignment(asgn_node); end

  def process_multiple_assignment(masgn_node); end

  def scan(node, &block); end
end

class RuboCop::Cop::Lint::UselessSetterCall::MethodVariableTracker
end

class RuboCop::Cop::Lint::UselessSetterCall
end

class RuboCop::Cop::Lint::Void
  def on_begin(node); end

  def on_block(node); end

  def on_kwbegin(node); end
  BINARY_OPERATORS = ::T.let(nil, ::T.untyped)
  DEFINED_MSG = ::T.let(nil, ::T.untyped)
  LIT_MSG = ::T.let(nil, ::T.untyped)
  NONMUTATING_METHODS = ::T.let(nil, ::T.untyped)
  NONMUTATING_MSG = ::T.let(nil, ::T.untyped)
  OPERATORS = ::T.let(nil, ::T.untyped)
  OP_MSG = ::T.let(nil, ::T.untyped)
  SELF_MSG = ::T.let(nil, ::T.untyped)
  UNARY_OPERATORS = ::T.let(nil, ::T.untyped)
  VAR_MSG = ::T.let(nil, ::T.untyped)
  VOID_CONTEXT_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Void
end

module RuboCop::Cop::Lint
end

module RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::RangeHelp
end

module RuboCop::Cop::MatchRange
end

class RuboCop::Cop::MessageAnnotator
  def annotate(message); end

  def config(); end

  def cop_config(); end

  def cop_name(); end

  def initialize(config, cop_name, cop_config, options); end

  def options(); end

  def urls(); end
end

class RuboCop::Cop::MessageAnnotator
  def self.style_guide_urls(); end
end

module RuboCop::Cop::MethodComplexity
  include ::RuboCop::Cop::ConfigurableMax
  def define_method?(node=T.unsafe(nil)); end

  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end
end

module RuboCop::Cop::MethodComplexity
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::Cop::MethodPreference
end

module RuboCop::Cop::MethodPreference
end

module RuboCop::Cop::Metrics
end

class RuboCop::Cop::Metrics::AbcSize
  include ::RuboCop::Cop::MethodComplexity
  include ::RuboCop::Cop::ConfigurableMax
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::AbcSize
end

class RuboCop::Cop::Metrics::BlockLength
  include ::RuboCop::Cop::TooManyLines
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  def on_block(node); end
  LABEL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::BlockLength
end

class RuboCop::Cop::Metrics::BlockNesting
  include ::RuboCop::Cop::ConfigurableMax
  def investigate(processed_source); end
  NESTING_BLOCKS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::BlockNesting
end

class RuboCop::Cop::Metrics::ClassLength
  include ::RuboCop::Cop::ClassishLength
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  def class_definition?(node=T.unsafe(nil)); end

  def on_casgn(node); end

  def on_class(node); end
end

class RuboCop::Cop::Metrics::ClassLength
end

class RuboCop::Cop::Metrics::CyclomaticComplexity
  include ::RuboCop::Cop::MethodComplexity
  include ::RuboCop::Cop::ConfigurableMax
  COUNTED_NODES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::CyclomaticComplexity
end

class RuboCop::Cop::Metrics::MethodLength
  include ::RuboCop::Cop::TooManyLines
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end
  LABEL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::MethodLength
end

class RuboCop::Cop::Metrics::ModuleLength
  include ::RuboCop::Cop::ClassishLength
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  def module_definition?(node=T.unsafe(nil)); end

  def on_casgn(node); end

  def on_module(node); end
end

class RuboCop::Cop::Metrics::ModuleLength
end

class RuboCop::Cop::Metrics::ParameterLists
  include ::RuboCop::Cop::ConfigurableMax
  def argument_to_lambda_or_proc?(node=T.unsafe(nil)); end

  def on_args(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::ParameterLists
end

class RuboCop::Cop::Metrics::PerceivedComplexity
  include ::RuboCop::Cop::MethodComplexity
  include ::RuboCop::Cop::ConfigurableMax
  COUNTED_NODES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::PerceivedComplexity
end

module RuboCop::Cop::Metrics::Utils
end

class RuboCop::Cop::Metrics::Utils::AbcSizeCalculator
  def calculate(); end

  def else_branch?(node); end

  def evaluate_branch_nodes(node); end

  def evaluate_condition_node(node); end

  def initialize(node); end
  BRANCH_NODES = ::T.let(nil, ::T.untyped)
  CONDITION_NODES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::Utils::AbcSizeCalculator
  def self.calculate(node); end
end

module RuboCop::Cop::Metrics::Utils
end

module RuboCop::Cop::Metrics
end

module RuboCop::Cop::Migration
end

class RuboCop::Cop::Migration::DepartmentName
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(processed_source); end
  DISABLE_COMMENT_FORMAT = ::T.let(nil, ::T.untyped)
  DISABLING_COPS_CONTENT_TOKEN = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Migration::DepartmentName
end

module RuboCop::Cop::Migration
end

module RuboCop::Cop::MinBodyLength
end

module RuboCop::Cop::MinBodyLength
end

module RuboCop::Cop::MultilineElementIndentation
end

module RuboCop::Cop::MultilineElementIndentation
end

module RuboCop::Cop::MultilineElementLineBreaks
end

module RuboCop::Cop::MultilineElementLineBreaks
end

module RuboCop::Cop::MultilineExpressionIndentation
  def on_send(node); end
  ASSIGNMENT_MESSAGE_TAIL = ::T.let(nil, ::T.untyped)
  DEFAULT_MESSAGE_TAIL = ::T.let(nil, ::T.untyped)
  KEYWORD_ANCESTOR_TYPES = ::T.let(nil, ::T.untyped)
  KEYWORD_MESSAGE_TAIL = ::T.let(nil, ::T.untyped)
  UNALIGNED_RHS_TYPES = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::MultilineExpressionIndentation
end

class RuboCop::Cop::MultilineLiteralBraceCorrector
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def call(corrector); end

  def initialize(node, processed_source); end
end

class RuboCop::Cop::MultilineLiteralBraceCorrector
end

module RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
end

module RuboCop::Cop::MultilineLiteralBraceLayout
end

module RuboCop::Cop::Naming
end

class RuboCop::Cop::Naming::AccessorMethodName
  def on_def(node); end

  def on_defs(node); end
  MSG_READER = ::T.let(nil, ::T.untyped)
  MSG_WRITER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::AccessorMethodName
end

class RuboCop::Cop::Naming::AsciiIdentifiers
  include ::RuboCop::Cop::RangeHelp
  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::AsciiIdentifiers
end

class RuboCop::Cop::Naming::BinaryOperatorParameterName
  def on_def(node); end

  def op_method_candidate?(node=T.unsafe(nil)); end
  BLACKLISTED = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  OP_LIKE_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::BinaryOperatorParameterName
end

class RuboCop::Cop::Naming::BlockParameterName
  include ::RuboCop::Cop::UncommunicativeName
  def on_block(node); end
end

class RuboCop::Cop::Naming::BlockParameterName
end

class RuboCop::Cop::Naming::ClassAndModuleCamelCase
  def on_class(node); end

  def on_module(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::ClassAndModuleCamelCase
end

class RuboCop::Cop::Naming::ConstantName
  def class_or_struct_return_method?(node=T.unsafe(nil)); end

  def literal_receiver?(node=T.unsafe(nil)); end

  def on_casgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
  SNAKE_CASE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::ConstantName
end

class RuboCop::Cop::Naming::FileName
  include ::RuboCop::Cop::RangeHelp
  def investigate(processed_source); end
  MSG_NO_DEFINITION = ::T.let(nil, ::T.untyped)
  MSG_REGEX = ::T.let(nil, ::T.untyped)
  MSG_SNAKE_CASE = ::T.let(nil, ::T.untyped)
  SNAKE_CASE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::FileName
end

class RuboCop::Cop::Naming::HeredocDelimiterCase
  include ::RuboCop::Cop::Heredoc
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_heredoc(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::HeredocDelimiterCase
end

class RuboCop::Cop::Naming::HeredocDelimiterNaming
  include ::RuboCop::Cop::Heredoc
  def on_heredoc(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::HeredocDelimiterNaming
end

class RuboCop::Cop::Naming::MemoizedInstanceVariableName
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def memoized?(node=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
  UNDERSCORE_REQUIRED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::MemoizedInstanceVariableName
end

class RuboCop::Cop::Naming::MethodName
  include ::RuboCop::Cop::ConfigurableNaming
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::IgnoredPattern
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::MethodName
end

class RuboCop::Cop::Naming::MethodParameterName
  include ::RuboCop::Cop::UncommunicativeName
  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Naming::MethodParameterName
end

class RuboCop::Cop::Naming::PredicateName
  def dynamic_method_define(node=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end
end

class RuboCop::Cop::Naming::PredicateName
end

class RuboCop::Cop::Naming::RescuedExceptionsVariableName
  def autocorrect(node); end

  def on_resbody(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::RescuedExceptionsVariableName
end

class RuboCop::Cop::Naming::VariableName
  include ::RuboCop::Cop::ConfigurableNaming
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_arg(node); end

  def on_blockarg(node); end

  def on_cvasgn(node); end

  def on_ivasgn(node); end

  def on_kwarg(node); end

  def on_kwoptarg(node); end

  def on_kwrestarg(node); end

  def on_lvar(node); end

  def on_lvasgn(node); end

  def on_optarg(node); end

  def on_restarg(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::VariableName
end

class RuboCop::Cop::Naming::VariableNumber
  include ::RuboCop::Cop::ConfigurableNumbering
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_arg(node); end

  def on_cvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::VariableNumber
end

module RuboCop::Cop::Naming
end

module RuboCop::Cop::NegativeConditional
  def empty_condition?(node=T.unsafe(nil)); end

  def single_negative?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::NegativeConditional
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::Cop::NilMethods
end

module RuboCop::Cop::NilMethods
end

class RuboCop::Cop::Offense
  include ::Comparable
  def ==(other); end

  def column(); end

  def column_length(); end

  def column_range(); end

  def cop_name(); end

  def correctable?(); end

  def corrected?(); end

  def corrected_with_todo?(); end

  def disabled?(); end

  def eql?(other); end

  def first_line(); end

  def highlighted_area(); end

  def initialize(severity, location, message, cop_name, status=T.unsafe(nil)); end

  def last_column(); end

  def last_line(); end

  def line(); end

  def location(); end

  def message(); end

  def real_column(); end

  def severity(); end

  def source_line(); end

  def status(); end
  COMPARISON_ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Offense
end

module RuboCop::Cop::OnNormalIfUnless
  def on_if(node); end
end

module RuboCop::Cop::OnNormalIfUnless
end

class RuboCop::Cop::OrderedGemCorrector
end

class RuboCop::Cop::OrderedGemCorrector
  extend ::RuboCop::Cop::OrderedGemNode
  def self.comments_as_separators(); end

  def self.correct(processed_source, node, previous_declaration, comments_as_separators); end

  def self.processed_source(); end
end

module RuboCop::Cop::OrderedGemNode
end

module RuboCop::Cop::OrderedGemNode
end

module RuboCop::Cop::Parentheses
end

module RuboCop::Cop::Parentheses
end

class RuboCop::Cop::ParenthesesCorrector
end

class RuboCop::Cop::ParenthesesCorrector
  def self.correct(node); end
end

module RuboCop::Cop::ParserDiagnostic
  def investigate(processed_source); end
end

module RuboCop::Cop::ParserDiagnostic
end

module RuboCop::Cop::PercentArray
end

module RuboCop::Cop::PercentArray
end

module RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
end

module RuboCop::Cop::PercentLiteral
end

class RuboCop::Cop::PercentLiteralCorrector
  include ::RuboCop::Cop::Util
  include ::RuboCop::PathUtil
  def config(); end

  def correct(node, char); end

  def initialize(config, preferred_delimiters); end

  def preferred_delimiters(); end
end

class RuboCop::Cop::PercentLiteralCorrector
end

module RuboCop::Cop::PrecedingFollowingAlignment
end

module RuboCop::Cop::PrecedingFollowingAlignment
end

class RuboCop::Cop::PreferredDelimiters
  def config(); end

  def delimiters(); end

  def initialize(type, config, preferred_delimiters); end

  def type(); end
  PERCENT_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::PreferredDelimiters
end

class RuboCop::Cop::PunctuationCorrector
end

class RuboCop::Cop::PunctuationCorrector
  def self.add_space(token); end

  def self.remove_space(space_before); end

  def self.swap_comma(range); end
end

module RuboCop::Cop::RangeHelp
  BYTE_ORDER_MARK = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::RangeHelp
end

module RuboCop::Cop::RationalLiteral
  def rational_literal?(node=T.unsafe(nil)); end
end

module RuboCop::Cop::RationalLiteral
  extend ::RuboCop::NodePattern::Macros
end

class RuboCop::Cop::Registry
  def ==(other); end

  def contains_cop_matching?(names); end

  def cops(); end

  def department_missing?(badge, name); end

  def departments(); end

  def each(&block); end

  def enabled(config, only, only_safe=T.unsafe(nil)); end

  def enabled?(cop, config, only_safe); end

  def enlist(cop); end

  def find_by_cop_name(cop_name); end

  def initialize(cops=T.unsafe(nil)); end

  def length(); end

  def names(); end

  def print_warning(name, path); end

  def qualified_cop_name(name, path, shall_warn=T.unsafe(nil)); end

  def select(&block); end

  def sort!(); end

  def to_h(); end

  def unqualified_cop_names(); end

  def with_department(department); end

  def without_department(department); end
end

class RuboCop::Cop::Registry
end

module RuboCop::Cop::RescueNode
  def investigate(processed_source); end
end

module RuboCop::Cop::RescueNode
end

module RuboCop::Cop::SafeAssignment
  def empty_condition?(node=T.unsafe(nil)); end

  def safe_assignment?(node=T.unsafe(nil)); end

  def setter_method?(node=T.unsafe(nil)); end
end

module RuboCop::Cop::SafeAssignment
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::Cop::Security
end

class RuboCop::Cop::Security::Eval
  def eval?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::Eval
end

class RuboCop::Cop::Security::JSONLoad
  def autocorrect(node); end

  def json_load(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::JSONLoad
end

class RuboCop::Cop::Security::MarshalLoad
  def marshal_load(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::MarshalLoad
end

class RuboCop::Cop::Security::Open
  def on_send(node); end

  def open?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::Open
end

class RuboCop::Cop::Security::YAMLLoad
  def autocorrect(node); end

  def on_send(node); end

  def yaml_load(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::YAMLLoad
end

module RuboCop::Cop::Security
end

class RuboCop::Cop::Severity
  include ::Comparable
  def ==(other); end

  def code(); end

  def initialize(name_or_code); end

  def level(); end

  def name(); end
  CODE_TABLE = ::T.let(nil, ::T.untyped)
  NAMES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Severity
  def self.name_from_code(code); end
end

module RuboCop::Cop::SpaceAfterPunctuation
  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::SpaceAfterPunctuation
end

module RuboCop::Cop::SpaceBeforePunctuation
  include ::RuboCop::Cop::RangeHelp
  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::SpaceBeforePunctuation
end

class RuboCop::Cop::SpaceCorrector
end

class RuboCop::Cop::SpaceCorrector
  extend ::RuboCop::Cop::SurroundingSpace
  extend ::RuboCop::Cop::RangeHelp
  def self.add_space(processed_source, corrector, left_token, right_token); end

  def self.empty_corrections(processed_source, corrector, empty_config, left_token, right_token); end

  def self.processed_source(); end

  def self.remove_space(processed_source, corrector, left_token, right_token); end
end

module RuboCop::Cop::StatementModifier
end

module RuboCop::Cop::StatementModifier
end

module RuboCop::Cop::StringHelp
  def on_regexp(node); end

  def on_str(node); end
end

module RuboCop::Cop::StringHelp
end

class RuboCop::Cop::StringLiteralCorrector
end

class RuboCop::Cop::StringLiteralCorrector
  extend ::RuboCop::Cop::Util
  extend ::RuboCop::PathUtil
  def self.correct(node, style); end
end

module RuboCop::Cop::StringLiteralsHelp
  include ::RuboCop::Cop::StringHelp
end

module RuboCop::Cop::StringLiteralsHelp
end

module RuboCop::Cop::Style
end

class RuboCop::Cop::Style::AccessModifierDeclarations
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_send(node); end
  GROUP_STYLE_MESSAGE = ::T.let(nil, ::T.untyped)
  INLINE_STYLE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AccessModifierDeclarations
end

class RuboCop::Cop::Style::Alias
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def identifier(node=T.unsafe(nil)); end

  def on_alias(node); end

  def on_send(node); end
  MSG_ALIAS = ::T.let(nil, ::T.untyped)
  MSG_ALIAS_METHOD = ::T.let(nil, ::T.untyped)
  MSG_SYMBOL_ARGS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Alias
end

class RuboCop::Cop::Style::AndOr
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_and(node); end

  def on_if(node); end

  def on_or(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AndOr
end

module RuboCop::Cop::Style::AnnotationComment
end

module RuboCop::Cop::Style::AnnotationComment
end

class RuboCop::Cop::Style::ArrayJoin
  def autocorrect(node); end

  def join_candidate?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ArrayJoin
end

class RuboCop::Cop::Style::AsciiComments
  include ::RuboCop::Cop::RangeHelp
  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AsciiComments
end

class RuboCop::Cop::Style::Attr
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def class_eval?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Attr
end

class RuboCop::Cop::Style::AutoResourceCleanup
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  TARGET_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AutoResourceCleanup
end

class RuboCop::Cop::Style::BarePercentLiterals
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_dstr(node); end

  def on_str(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BarePercentLiterals
end

class RuboCop::Cop::Style::BeginBlock
  def on_preexe(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BeginBlock
end

class RuboCop::Cop::Style::BlockComments
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(comment); end

  def investigate(processed_source); end
  BEGIN_LENGTH = ::T.let(nil, ::T.untyped)
  END_LENGTH = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BlockComments
end

class RuboCop::Cop::Style::BlockDelimiters
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::IgnoredMethods
  def autocorrect(node); end

  def on_block(node); end

  def on_send(node); end
  ALWAYS_BRACES_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BlockDelimiters
end

class RuboCop::Cop::Style::BracesAroundHashParameters
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(send_node); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BracesAroundHashParameters
end

class RuboCop::Cop::Style::CaseCorrector
end

class RuboCop::Cop::Style::CaseCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
  def self.correct(cop, node); end

  def self.move_assignment_inside_condition(node); end
end

class RuboCop::Cop::Style::CaseEquality
  def case_equality?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CaseEquality
end

class RuboCop::Cop::Style::CharacterLiteral
  include ::RuboCop::Cop::StringHelp
  def autocorrect(node); end

  def correct_style_detected(); end

  def offense?(node); end

  def opposite_style_detected(); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CharacterLiteral
end

class RuboCop::Cop::Style::ClassAndModuleChildren
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_class(node); end

  def on_module(node); end
  COMPACT_MSG = ::T.let(nil, ::T.untyped)
  NESTED_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassAndModuleChildren
end

class RuboCop::Cop::Style::ClassCheck
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def class_check?(node=T.unsafe(nil)); end

  def message(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassCheck
end

class RuboCop::Cop::Style::ClassMethods
  def autocorrect(node); end

  def on_class(node); end

  def on_module(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassMethods
end

class RuboCop::Cop::Style::ClassVars
  def message(node); end

  def on_cvasgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassVars
end

class RuboCop::Cop::Style::CollectionMethods
  include ::RuboCop::Cop::MethodPreference
  def autocorrect(node); end

  def on_block(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CollectionMethods
end

class RuboCop::Cop::Style::ColonMethodCall
  def autocorrect(node); end

  def java_type_node?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ColonMethodCall
end

class RuboCop::Cop::Style::ColonMethodDefinition
  def autocorrect(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ColonMethodDefinition
end

class RuboCop::Cop::Style::CommandLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_xstr(node); end
  MSG_USE_BACKTICKS = ::T.let(nil, ::T.untyped)
  MSG_USE_PERCENT_X = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CommandLiteral
end

class RuboCop::Cop::Style::CommentAnnotation
  include ::RuboCop::Cop::Style::AnnotationComment
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(comment); end

  def investigate(processed_source); end
  MISSING_NOTE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CommentAnnotation
end

class RuboCop::Cop::Style::CommentedKeyword
  def investigate(processed_source); end
  ALLOWED_COMMENTS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CommentedKeyword
end

class RuboCop::Cop::Style::ConditionalAssignment
  include ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def assignment_type?(node=T.unsafe(nil)); end

  def autocorrect(node); end

  def candidate_condition?(node=T.unsafe(nil)); end

  def on_and_asgn(node); end

  def on_case(node); end

  def on_casgn(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_if(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_op_asgn(node); end

  def on_or_asgn(node); end

  def on_send(node); end
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  ASSIGN_TO_CONDITION_MSG = ::T.let(nil, ::T.untyped)
  ENABLED = ::T.let(nil, ::T.untyped)
  INDENTATION_WIDTH = ::T.let(nil, ::T.untyped)
  LINE_LENGTH = ::T.let(nil, ::T.untyped)
  MAX = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SINGLE_LINE_CONDITIONS_ONLY = ::T.let(nil, ::T.untyped)
  VARIABLE_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  WIDTH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ConditionalAssignment
end

module RuboCop::Cop::Style::ConditionalAssignmentHelper
  def end_with_eq?(sym); end

  def expand_elses(branch); end

  def expand_when_branches(when_branches); end

  def indent(cop, source); end

  def lhs(node); end

  def tail(branch); end
  ALIGN_WITH = ::T.let(nil, ::T.untyped)
  END_ALIGNMENT = ::T.let(nil, ::T.untyped)
  EQUAL = ::T.let(nil, ::T.untyped)
  KEYWORD = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::Cop::Style::ConditionalCorrectorHelper
  def assignment(node); end

  def correct_branches(corrector, branches); end

  def correct_if_branches(corrector, cop, node); end

  def remove_whitespace_in_branches(corrector, branch, condition, column); end

  def replace_branch_assignment(corrector, branch); end

  def white_space_range(node, column); end
end

module RuboCop::Cop::Style::ConditionalCorrectorHelper
end

class RuboCop::Cop::Style::ConstantVisibility
  def on_casgn(node); end

  def visibility_declaration_for?(node=T.unsafe(nil), param1); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ConstantVisibility
end

class RuboCop::Cop::Style::Copyright
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(token); end

  def investigate(processed_source); end
  AUTOCORRECT_EMPTY_WARNING = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Copyright
end

class RuboCop::Cop::Style::DateTime
  def date_time?(node=T.unsafe(nil)); end

  def historic_date?(node=T.unsafe(nil)); end

  def on_send(node); end

  def to_datetime?(node=T.unsafe(nil)); end
  CLASS_MSG = ::T.let(nil, ::T.untyped)
  COERCION_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DateTime
end

class RuboCop::Cop::Style::DefWithParentheses
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DefWithParentheses
end

class RuboCop::Cop::Style::Dir
  def autocorrect(node); end

  def dir_replacement?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Dir
end

class RuboCop::Cop::Style::Documentation
  include ::RuboCop::Cop::DocumentationComment
  include ::RuboCop::Cop::Style::AnnotationComment
  def constant_definition?(node=T.unsafe(nil)); end

  def on_class(node); end

  def on_module(node); end

  def outer_module(node0); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Documentation
end

class RuboCop::Cop::Style::DocumentationMethod
  include ::RuboCop::Cop::DocumentationComment
  include ::RuboCop::Cop::Style::AnnotationComment
  include ::RuboCop::Cop::DefNode
  def module_function_node?(node=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DocumentationMethod
end

class RuboCop::Cop::Style::DoubleCopDisableDirective
  def autocorrect(comment); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DoubleCopDisableDirective
end

class RuboCop::Cop::Style::DoubleNegation
  def double_negative?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DoubleNegation
end

class RuboCop::Cop::Style::EachForSimpleLoop
  def autocorrect(node); end

  def offending_each_range(node=T.unsafe(nil)); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EachForSimpleLoop
end

class RuboCop::Cop::Style::EachWithObject
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def each_with_object_candidate?(node=T.unsafe(nil)); end

  def on_block(node); end
  METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EachWithObject
end

class RuboCop::Cop::Style::EmptyBlockParameter
  include ::RuboCop::Cop::EmptyParameter
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyBlockParameter
end

class RuboCop::Cop::Style::EmptyCaseCondition
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(case_node); end

  def on_case(case_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyCaseCondition
end

class RuboCop::Cop::Style::EmptyElse
  include ::RuboCop::Cop::OnNormalIfUnless
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_case(node); end

  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyElse
end

class RuboCop::Cop::Style::EmptyLambdaParameter
  include ::RuboCop::Cop::EmptyParameter
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyLambdaParameter
end

class RuboCop::Cop::Style::EmptyLiteral
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::RangeHelp
  def array_node(node=T.unsafe(nil)); end

  def array_with_block(node=T.unsafe(nil)); end

  def autocorrect(node); end

  def hash_node(node=T.unsafe(nil)); end

  def hash_with_block(node=T.unsafe(nil)); end

  def on_send(node); end

  def str_node(node=T.unsafe(nil)); end
  ARR_MSG = ::T.let(nil, ::T.untyped)
  HASH_MSG = ::T.let(nil, ::T.untyped)
  STR_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyLiteral
end

class RuboCop::Cop::Style::EmptyMethod
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG_COMPACT = ::T.let(nil, ::T.untyped)
  MSG_EXPANDED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyMethod
end

class RuboCop::Cop::Style::Encoding
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(processed_source); end
  ENCODING_PATTERN = ::T.let(nil, ::T.untyped)
  MSG_UNNECESSARY = ::T.let(nil, ::T.untyped)
  SHEBANG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Encoding
end

class RuboCop::Cop::Style::EndBlock
  def on_postexe(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EndBlock
end

class RuboCop::Cop::Style::EvalWithLocation
  def eval_without_location?(node=T.unsafe(nil)); end

  def line_with_offset?(node=T.unsafe(nil), param1, param2); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_INCORRECT_LINE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EvalWithLocation
end

class RuboCop::Cop::Style::EvenOdd
  def autocorrect(node); end

  def even_odd_candidate?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EvenOdd
end

class RuboCop::Cop::Style::ExpandPathArguments
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def file_expand_path(node=T.unsafe(nil)); end

  def on_send(node); end

  def pathname_new_parent_expand_path(node=T.unsafe(nil)); end

  def pathname_parent_expand_path(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  PATHNAME_MSG = ::T.let(nil, ::T.untyped)
  PATHNAME_NEW_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ExpandPathArguments
end

class RuboCop::Cop::Style::FloatDivision
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def any_coerce?(node=T.unsafe(nil)); end

  def both_coerce?(node=T.unsafe(nil)); end

  def left_coerce?(node=T.unsafe(nil)); end

  def on_send(node); end

  def right_coerce?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::FloatDivision
end

class RuboCop::Cop::Style::For
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end

  def on_for(node); end
  EACH_LENGTH = ::T.let(nil, ::T.untyped)
  PREFER_EACH = ::T.let(nil, ::T.untyped)
  PREFER_FOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::For
end

class RuboCop::Cop::Style::FormatString
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def formatter(node=T.unsafe(nil)); end

  def message(detected_style); end

  def method_name(style_name); end

  def on_send(node); end

  def variable_argument?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FormatString
end

class RuboCop::Cop::Style::FormatStringToken
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def format_string_in_typical_context?(node=T.unsafe(nil)); end

  def on_str(node); end
end

class RuboCop::Cop::Style::FormatStringToken
end

class RuboCop::Cop::Style::FrozenStringLiteralComment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_UNNECESSARY = ::T.let(nil, ::T.untyped)
  SHEBANG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FrozenStringLiteralComment
end

class RuboCop::Cop::Style::GlobalVars
  def allowed_var?(global_var); end

  def check(node); end

  def on_gvar(node); end

  def on_gvasgn(node); end

  def user_vars(); end
  BUILT_IN_VARS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::GlobalVars
end

class RuboCop::Cop::Style::GuardClause
  include ::RuboCop::Cop::MinBodyLength
  include ::RuboCop::Cop::StatementModifier
  def on_def(node); end

  def on_defs(node); end

  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::GuardClause
end

class RuboCop::Cop::Style::HashSyntax
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def hash_rockets_check(pairs); end

  def no_mixed_keys_check(pairs); end

  def on_hash(node); end

  def ruby19_check(pairs); end

  def ruby19_no_mixed_keys_check(pairs); end
  MSG_19 = ::T.let(nil, ::T.untyped)
  MSG_HASH_ROCKETS = ::T.let(nil, ::T.untyped)
  MSG_NO_MIXED_KEYS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashSyntax
end

class RuboCop::Cop::Style::IdenticalConditionalBranches
  def on_case(node); end

  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IdenticalConditionalBranches
end

class RuboCop::Cop::Style::IfCorrector
end

class RuboCop::Cop::Style::IfCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
  def self.correct(cop, node); end

  def self.move_assignment_inside_condition(node); end
end

class RuboCop::Cop::Style::IfInsideElse
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfInsideElse
end

class RuboCop::Cop::Style::IfUnlessModifier
  include ::RuboCop::Cop::StatementModifier
  include ::RuboCop::Cop::LineLengthHelp
  include ::RuboCop::Cop::IgnoredPattern
  def autocorrect(node); end

  def on_if(node); end
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  MSG_USE_MODIFIER = ::T.let(nil, ::T.untyped)
  MSG_USE_NORMAL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfUnlessModifier
end

class RuboCop::Cop::Style::IfUnlessModifierOfIfUnless
  include ::RuboCop::Cop::StatementModifier
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfUnlessModifierOfIfUnless
end

class RuboCop::Cop::Style::IfWithSemicolon
  include ::RuboCop::Cop::OnNormalIfUnless
  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfWithSemicolon
end

class RuboCop::Cop::Style::ImplicitRuntimeError
  def implicit_runtime_error_raise_or_fail(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ImplicitRuntimeError
end

class RuboCop::Cop::Style::InfiniteLoop
  def after_leaving_scope(scope, _variable_table); end

  def autocorrect(node); end

  def join_force?(force_class); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
  LEADING_SPACE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InfiniteLoop
end

class RuboCop::Cop::Style::InlineComment
  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InlineComment
end

class RuboCop::Cop::Style::InverseMethods
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def correct_inverse_block(node); end

  def correct_inverse_method(node); end

  def correct_inverse_selector(block, corrector); end

  def inverse_block?(node=T.unsafe(nil)); end

  def inverse_candidate?(node=T.unsafe(nil)); end

  def on_block(node); end

  def on_send(node); end
  CAMEL_CASE = ::T.let(nil, ::T.untyped)
  CLASS_COMPARISON_METHODS = ::T.let(nil, ::T.untyped)
  EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  NEGATED_EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InverseMethods
end

class RuboCop::Cop::Style::IpAddresses
  include ::RuboCop::Cop::StringHelp
  def correct_style_detected(); end

  def offense?(node); end

  def opposite_style_detected(); end
  IPV6_MAX_SIZE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IpAddresses
end

class RuboCop::Cop::Style::Lambda
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_block(node); end
  LITERAL_MESSAGE = ::T.let(nil, ::T.untyped)
  METHOD_MESSAGE = ::T.let(nil, ::T.untyped)
  OFFENDING_SELECTORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Lambda
end

class RuboCop::Cop::Style::LambdaCall
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_send(node); end
end

class RuboCop::Cop::Style::LambdaCall
end

class RuboCop::Cop::Style::LineEndConcatenation
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(operator_range); end

  def investigate(processed_source); end
  COMPLEX_STRING_BEGIN_TOKEN = ::T.let(nil, ::T.untyped)
  COMPLEX_STRING_END_TOKEN = ::T.let(nil, ::T.untyped)
  CONCAT_TOKEN_TYPES = ::T.let(nil, ::T.untyped)
  HIGH_PRECEDENCE_OP_TOKEN_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  QUOTE_DELIMITERS = ::T.let(nil, ::T.untyped)
  SIMPLE_STRING_TOKEN_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::LineEndConcatenation
end

class RuboCop::Cop::Style::MethodCallWithArgsParentheses
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::IgnoredMethods
  include ::RuboCop::Cop::IgnoredPattern
  def initialize(*_); end
end

module RuboCop::Cop::Style::MethodCallWithArgsParentheses::OmitParentheses
  def autocorrect(node); end

  def message(_node=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end

  def on_super(node); end

  def on_yield(node); end
  TRAILING_WHITESPACE_REGEX = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Style::MethodCallWithArgsParentheses::OmitParentheses
end

module RuboCop::Cop::Style::MethodCallWithArgsParentheses::RequireParentheses
  def autocorrect(node); end

  def message(_node=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end

  def on_super(node); end

  def on_yield(node); end
end

module RuboCop::Cop::Style::MethodCallWithArgsParentheses::RequireParentheses
end

class RuboCop::Cop::Style::MethodCallWithArgsParentheses
end

class RuboCop::Cop::Style::MethodCallWithoutArgsParentheses
  include ::RuboCop::Cop::IgnoredMethods
  def autocorrect(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodCallWithoutArgsParentheses
end

class RuboCop::Cop::Style::MethodCalledOnDoEndBlock
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodCalledOnDoEndBlock
end

class RuboCop::Cop::Style::MethodDefParentheses
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG_MISSING = ::T.let(nil, ::T.untyped)
  MSG_PRESENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodDefParentheses
end

class RuboCop::Cop::Style::MethodMissingSuper
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodMissingSuper
end

class RuboCop::Cop::Style::MinMax
  def autocorrect(node); end

  def min_max_candidate(node=T.unsafe(nil)); end

  def on_array(node); end

  def on_return(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MinMax
end

class RuboCop::Cop::Style::MissingElse
  include ::RuboCop::Cop::OnNormalIfUnless
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_case(node); end

  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_EMPTY = ::T.let(nil, ::T.untyped)
  MSG_NIL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MissingElse
end

class RuboCop::Cop::Style::MissingRespondToMissing
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MissingRespondToMissing
end

class RuboCop::Cop::Style::MixinGrouping
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_class(node); end

  def on_module(node); end
  MIXIN_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MixinGrouping
end

class RuboCop::Cop::Style::MixinUsage
  def include_statement(node=T.unsafe(nil)); end

  def on_send(node); end

  def wrapped_macro_scope?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MixinUsage
end

class RuboCop::Cop::Style::ModuleFunction
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def extend_self_node?(node=T.unsafe(nil)); end

  def module_function_node?(node=T.unsafe(nil)); end

  def on_module(node); end

  def private_directive?(node=T.unsafe(nil)); end
  EXTEND_SELF_MSG = ::T.let(nil, ::T.untyped)
  MODULE_FUNCTION_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ModuleFunction
end

class RuboCop::Cop::Style::MultilineBlockChain
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineBlockChain
end

class RuboCop::Cop::Style::MultilineIfModifier
  include ::RuboCop::Cop::StatementModifier
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineIfModifier
end

class RuboCop::Cop::Style::MultilineIfThen
  include ::RuboCop::Cop::OnNormalIfUnless
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
  NON_MODIFIER_THEN = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineIfThen
end

class RuboCop::Cop::Style::MultilineMemoization
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_or_asgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineMemoization
end

class RuboCop::Cop::Style::MultilineMethodSignature
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineMethodSignature
end

class RuboCop::Cop::Style::MultilineTernaryOperator
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineTernaryOperator
end

class RuboCop::Cop::Style::MultilineWhenThen
  include ::RuboCop::Cop::RangeHelp
  def accept_node_type?(node); end

  def autocorrect(node); end

  def on_when(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineWhenThen
end

class RuboCop::Cop::Style::MultipleComparison
  def on_or(node); end

  def simple_comparison?(node=T.unsafe(nil)); end

  def simple_double_comparison?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultipleComparison
end

class RuboCop::Cop::Style::MutableConstant
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_casgn(node); end

  def on_or_asgn(node); end

  def operation_produces_immutable_object?(node=T.unsafe(nil)); end

  def range_enclosed_in_parentheses?(node=T.unsafe(nil)); end

  def splat_value(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MutableConstant
end

class RuboCop::Cop::Style::NegatedIf
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::NegativeConditional
  def autocorrect(node); end

  def on_if(node); end
end

class RuboCop::Cop::Style::NegatedIf
end

class RuboCop::Cop::Style::NegatedUnless
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::NegativeConditional
  def autocorrect(node); end

  def on_if(node); end
end

class RuboCop::Cop::Style::NegatedUnless
end

class RuboCop::Cop::Style::NegatedWhile
  include ::RuboCop::Cop::NegativeConditional
  def autocorrect(node); end

  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Style::NegatedWhile
end

class RuboCop::Cop::Style::NestedModifier
  include ::RuboCop::Cop::RangeHelp
  def add_parentheses_to_method_arguments(send_node); end

  def autocorrect(node); end

  def check(node); end

  def left_hand_operand(node, operator); end

  def modifier?(node); end

  def new_expression(inner_node); end

  def on_if(node); end

  def on_until(node); end

  def on_while(node); end

  def replacement_operator(keyword); end

  def requires_parens?(node); end

  def right_hand_operand(node, left_hand_keyword); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedModifier
end

class RuboCop::Cop::Style::NestedParenthesizedCalls
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(nested); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedParenthesizedCalls
end

class RuboCop::Cop::Style::NestedTernaryOperator
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedTernaryOperator
end

class RuboCop::Cop::Style::Next
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MinBodyLength
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def investigate(_processed_source); end

  def on_block(node); end

  def on_for(node); end

  def on_until(node); end

  def on_while(node); end
  EXIT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Next
end

class RuboCop::Cop::Style::NilComparison
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def nil_check?(node=T.unsafe(nil)); end

  def nil_comparison?(node=T.unsafe(nil)); end

  def on_send(node); end
  EXPLICIT_MSG = ::T.let(nil, ::T.untyped)
  PREDICATE_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NilComparison
end

class RuboCop::Cop::Style::NonNilCheck
  def autocorrect(node); end

  def nil_check?(node=T.unsafe(nil)); end

  def not_and_nil_check?(node=T.unsafe(nil)); end

  def not_equal_to_nil?(node=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end

  def unless_check?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::NonNilCheck
end

class RuboCop::Cop::Style::Not
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  OPPOSITE_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Not
end

class RuboCop::Cop::Style::NumericLiteralPrefix
  include ::RuboCop::Cop::IntegerNode
  def autocorrect(node); end

  def on_int(node); end
  BINARY_MSG = ::T.let(nil, ::T.untyped)
  BINARY_REGEX = ::T.let(nil, ::T.untyped)
  DECIMAL_MSG = ::T.let(nil, ::T.untyped)
  DECIMAL_REGEX = ::T.let(nil, ::T.untyped)
  HEX_MSG = ::T.let(nil, ::T.untyped)
  HEX_REGEX = ::T.let(nil, ::T.untyped)
  OCTAL_MSG = ::T.let(nil, ::T.untyped)
  OCTAL_REGEX = ::T.let(nil, ::T.untyped)
  OCTAL_ZERO_ONLY_MSG = ::T.let(nil, ::T.untyped)
  OCTAL_ZERO_ONLY_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericLiteralPrefix
end

class RuboCop::Cop::Style::NumericLiterals
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::IntegerNode
  def autocorrect(node); end

  def on_float(node); end

  def on_int(node); end
  DELIMITER_REGEXP = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericLiterals
end

class RuboCop::Cop::Style::NumericPredicate
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::IgnoredMethods
  def autocorrect(node); end

  def comparison(node=T.unsafe(nil)); end

  def inverted_comparison(node=T.unsafe(nil)); end

  def on_send(node); end

  def predicate(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  REPLACEMENTS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericPredicate
end

class RuboCop::Cop::Style::OneLineConditional
  include ::RuboCop::Cop::OnNormalIfUnless
  def autocorrect(node); end

  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OneLineConditional
end

class RuboCop::Cop::Style::OptionHash
  def on_args(node); end

  def option_hash(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OptionHash
end

class RuboCop::Cop::Style::OptionalArguments
  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OptionalArguments
end

class RuboCop::Cop::Style::OrAssignment
  def autocorrect(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_if(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def ternary_assignment?(node=T.unsafe(nil)); end

  def unless_assignment?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OrAssignment
end

class RuboCop::Cop::Style::ParallelAssignment
  include ::RuboCop::Cop::RescueNode
  def autocorrect(node); end

  def implicit_self_getter?(node=T.unsafe(nil)); end

  def on_masgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ParallelAssignment::AssignmentSorter
  include ::TSort
  def accesses?(rhs, lhs); end

  def dependency?(lhs, rhs); end

  def initialize(assignments); end

  def matching_calls(node0, param1, param2); end

  def tsort_each_child(assignment); end

  def uses_var?(node0, param1); end

  def var_name(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::ParallelAssignment::AssignmentSorter
  extend ::RuboCop::NodePattern::Macros
end

class RuboCop::Cop::Style::ParallelAssignment::GenericCorrector
  include ::RuboCop::Cop::Alignment
  def assignment(); end

  def config(); end

  def correction(); end

  def correction_range(); end

  def initialize(node, config, new_elements); end

  def node(); end
end

class RuboCop::Cop::Style::ParallelAssignment::GenericCorrector
end

class RuboCop::Cop::Style::ParallelAssignment::ModifierCorrector
end

class RuboCop::Cop::Style::ParallelAssignment::ModifierCorrector
end

class RuboCop::Cop::Style::ParallelAssignment::RescueCorrector
end

class RuboCop::Cop::Style::ParallelAssignment::RescueCorrector
end

class RuboCop::Cop::Style::ParallelAssignment
end

class RuboCop::Cop::Style::ParenthesesAroundCondition
  include ::RuboCop::Cop::SafeAssignment
  include ::RuboCop::Cop::Parentheses
  def autocorrect(node); end

  def control_op_condition(node=T.unsafe(nil)); end

  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Style::ParenthesesAroundCondition
end

class RuboCop::Cop::Style::PercentLiteralDelimiters
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def message(node); end

  def on_array(node); end

  def on_dstr(node); end

  def on_regexp(node); end

  def on_str(node); end

  def on_sym(node); end

  def on_xstr(node); end
end

class RuboCop::Cop::Style::PercentLiteralDelimiters
end

class RuboCop::Cop::Style::PercentQLiterals
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_str(node); end
  LOWER_CASE_Q_MSG = ::T.let(nil, ::T.untyped)
  UPPER_CASE_Q_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::PercentQLiterals
end

class RuboCop::Cop::Style::PerlBackrefs
  def autocorrect(node); end

  def on_nth_ref(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::PerlBackrefs
end

class RuboCop::Cop::Style::PreferredHashMethods
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  OFFENDING_SELECTORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::PreferredHashMethods
end

class RuboCop::Cop::Style::Proc
  def autocorrect(node); end

  def on_block(node); end

  def proc_new?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Proc
end

class RuboCop::Cop::Style::RaiseArgs
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_send(node); end
  COMPACT_MSG = ::T.let(nil, ::T.untyped)
  EXPLODED_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RaiseArgs
end

class RuboCop::Cop::Style::RandomWithOffset
  def autocorrect(node); end

  def integer_op_rand?(node=T.unsafe(nil)); end

  def namespace(node=T.unsafe(nil)); end

  def on_send(node); end

  def rand_modified?(node=T.unsafe(nil)); end

  def rand_op_integer?(node=T.unsafe(nil)); end

  def random_call(node=T.unsafe(nil)); end

  def to_int(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RandomWithOffset
end

class RuboCop::Cop::Style::RedundantBegin
  def autocorrect(node); end

  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantBegin
end

class RuboCop::Cop::Style::RedundantCapitalW
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_array(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantCapitalW
end

class RuboCop::Cop::Style::RedundantCondition
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
  REDUNDANT_CONDITION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantCondition
end

class RuboCop::Cop::Style::RedundantConditional
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_if(node); end

  def redundant_condition?(node=T.unsafe(nil)); end

  def redundant_condition_inverted?(node=T.unsafe(nil)); end
  COMPARISON_OPERATORS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantConditional
end

class RuboCop::Cop::Style::RedundantException
  def autocorrect(node); end

  def compact?(node=T.unsafe(nil)); end

  def exploded?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG_1 = ::T.let(nil, ::T.untyped)
  MSG_2 = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantException
end

class RuboCop::Cop::Style::RedundantFreeze
  include ::RuboCop::Cop::FrozenStringLiteral
  def autocorrect(node); end

  def on_send(node); end

  def operation_produces_immutable_object?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantFreeze
end

class RuboCop::Cop::Style::RedundantInterpolation
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_dstr(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantInterpolation
end

class RuboCop::Cop::Style::RedundantParentheses
  include ::RuboCop::Cop::Parentheses
  def arg_in_call_with_block?(node=T.unsafe(nil)); end

  def autocorrect(node); end

  def first_send_argument?(node=T.unsafe(nil)); end

  def first_super_argument?(node=T.unsafe(nil)); end

  def method_node_and_args(node=T.unsafe(nil)); end

  def on_begin(node); end

  def range_end?(node=T.unsafe(nil)); end

  def rescue?(node=T.unsafe(nil)); end

  def square_brackets?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::RedundantParentheses
end

class RuboCop::Cop::Style::RedundantPercentQ
  def autocorrect(node); end

  def on_dstr(node); end

  def on_str(node); end
  DYNAMIC_MSG = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  ESCAPED_NON_BACKSLASH = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PERCENT_CAPITAL_Q = ::T.let(nil, ::T.untyped)
  PERCENT_Q = ::T.let(nil, ::T.untyped)
  QUOTE = ::T.let(nil, ::T.untyped)
  SINGLE_QUOTE = ::T.let(nil, ::T.untyped)
  STRING_INTERPOLATION_REGEXP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantPercentQ
end

class RuboCop::Cop::Style::RedundantReturn
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MULTI_RETURN_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantReturn
end

class RuboCop::Cop::Style::RedundantSelf
  def autocorrect(node); end

  def on_and_asgn(node); end

  def on_args(node); end

  def on_block(node); end

  def on_blockarg(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_op_asgn(node); end

  def on_or_asgn(node); end

  def on_send(node); end
  KERNEL_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSelf
end

class RuboCop::Cop::Style::RedundantSort
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end

  def redundant_sort?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSort
end

class RuboCop::Cop::Style::RedundantSortBy
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end

  def redundant_sort_by(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSortBy
end

class RuboCop::Cop::Style::RegexpLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_regexp(node); end
  MSG_USE_PERCENT_R = ::T.let(nil, ::T.untyped)
  MSG_USE_SLASHES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RegexpLiteral
end

class RuboCop::Cop::Style::RescueModifier
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::RescueNode
  def autocorrect(node); end

  def on_resbody(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RescueModifier
end

class RuboCop::Cop::Style::RescueStandardError
  include ::RuboCop::Cop::RescueNode
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_resbody(node); end

  def rescue_standard_error?(node=T.unsafe(nil)); end

  def rescue_without_error_class?(node=T.unsafe(nil)); end
  MSG_EXPLICIT = ::T.let(nil, ::T.untyped)
  MSG_IMPLICIT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RescueStandardError
end

class RuboCop::Cop::Style::ReturnNil
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def chained_send?(node=T.unsafe(nil)); end

  def define_method?(node=T.unsafe(nil)); end

  def on_return(node); end

  def return_nil_node?(node=T.unsafe(nil)); end

  def return_node?(node=T.unsafe(nil)); end
  RETURN_MSG = ::T.let(nil, ::T.untyped)
  RETURN_NIL_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ReturnNil
end

class RuboCop::Cop::Style::SafeNavigation
  include ::RuboCop::Cop::NilMethods
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def check_node(node); end

  def modifier_if_safe_navigation_candidate(node=T.unsafe(nil)); end

  def not_nil_check?(node=T.unsafe(nil)); end

  def on_and(node); end

  def on_if(node); end

  def use_var_only_in_unless_modifier?(node, variable); end
  LOGIC_JUMP_KEYWORDS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SafeNavigation
end

class RuboCop::Cop::Style::Sample
  def autocorrect(node); end

  def on_send(node); end

  def sample_candidate?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Sample
end

class RuboCop::Cop::Style::SelfAssignment
  def autocorrect(node); end

  def on_cvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
  OPS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SelfAssignment
end

class RuboCop::Cop::Style::Semicolon
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(processed_source); end

  def on_begin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Semicolon
end

class RuboCop::Cop::Style::Send
  def on_csend(node); end

  def on_send(node); end

  def sending?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Send
end

class RuboCop::Cop::Style::SignalException
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def custom_fail_methods(node0); end

  def investigate(processed_source); end

  def kernel_call?(node=T.unsafe(nil), param1); end

  def on_rescue(node); end

  def on_send(node); end
  FAIL_MSG = ::T.let(nil, ::T.untyped)
  RAISE_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SignalException
end

class RuboCop::Cop::Style::SingleLineBlockParams
  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SingleLineBlockParams
end

class RuboCop::Cop::Style::SingleLineMethods
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SingleLineMethods
end

class RuboCop::Cop::Style::SpecialGlobalVars
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def message(node); end

  def on_gvar(node); end
  ENGLISH_VARS = ::T.let(nil, ::T.untyped)
  MSG_BOTH = ::T.let(nil, ::T.untyped)
  MSG_ENGLISH = ::T.let(nil, ::T.untyped)
  MSG_REGULAR = ::T.let(nil, ::T.untyped)
  NON_ENGLISH_VARS = ::T.let(nil, ::T.untyped)
  PERL_VARS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SpecialGlobalVars
end

class RuboCop::Cop::Style::StabbyLambdaParentheses
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_send(node); end
  MSG_NO_REQUIRE = ::T.let(nil, ::T.untyped)
  MSG_REQUIRE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StabbyLambdaParentheses
end

class RuboCop::Cop::Style::StderrPuts
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end

  def stderr_puts?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StderrPuts
end

class RuboCop::Cop::Style::StringHashKeys
  def autocorrect(node); end

  def on_pair(node); end

  def receive_environments_method?(node=T.unsafe(nil)); end

  def string_hash_key?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringHashKeys
end

class RuboCop::Cop::Style::StringLiterals
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::StringLiteralsHelp
  include ::RuboCop::Cop::StringHelp
  def autocorrect(node); end

  def on_dstr(node); end
  MSG_INCONSISTENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringLiterals
end

class RuboCop::Cop::Style::StringLiteralsInInterpolation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::StringLiteralsHelp
  include ::RuboCop::Cop::StringHelp
  def autocorrect(node); end
end

class RuboCop::Cop::Style::StringLiteralsInInterpolation
end

class RuboCop::Cop::Style::StringMethods
  include ::RuboCop::Cop::MethodPreference
  def autocorrect(node); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringMethods
end

class RuboCop::Cop::Style::Strip
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def lstrip_rstrip(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Strip
end

class RuboCop::Cop::Style::StructInheritance
  def on_class(node); end

  def struct_constructor?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StructInheritance
end

class RuboCop::Cop::Style::SymbolArray
  include ::RuboCop::Cop::ArrayMinSize
  include ::RuboCop::Cop::ArraySyntax
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::PercentArray
  def autocorrect(node); end

  def on_array(node); end
  ARRAY_MSG = ::T.let(nil, ::T.untyped)
  PERCENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SymbolArray
  def self.largest_brackets(); end

  def self.largest_brackets=(largest_brackets); end
end

class RuboCop::Cop::Style::SymbolLiteral
  def autocorrect(node); end

  def on_sym(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SymbolLiteral
end

class RuboCop::Cop::Style::SymbolProc
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::IgnoredMethods
  def autocorrect(node); end

  def destructuring_block_argument?(argument_node); end

  def on_block(node); end

  def proc_node?(node=T.unsafe(nil)); end

  def symbol_proc?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  SUPER_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SymbolProc
end

class RuboCop::Cop::Style::TernaryCorrector
end

class RuboCop::Cop::Style::TernaryCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
  def self.correct(node); end

  def self.move_assignment_inside_condition(node); end
end

class RuboCop::Cop::Style::TernaryParentheses
  include ::RuboCop::Cop::SafeAssignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def method_name(node=T.unsafe(nil)); end

  def on_if(node); end

  def only_closing_parenthesis_is_last_line?(condition); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_COMPLEX = ::T.let(nil, ::T.untyped)
  NON_COMPLEX_TYPES = ::T.let(nil, ::T.untyped)
  VARIABLE_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TernaryParentheses
end

class RuboCop::Cop::Style::TrailingBodyOnClass
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::TrailingBody
  def autocorrect(node); end

  def on_class(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingBodyOnClass
end

class RuboCop::Cop::Style::TrailingBodyOnMethodDefinition
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::TrailingBody
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingBodyOnMethodDefinition
end

class RuboCop::Cop::Style::TrailingBodyOnModule
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::TrailingBody
  def autocorrect(node); end

  def on_module(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingBodyOnModule
end

class RuboCop::Cop::Style::TrailingCommaInArguments
  include ::RuboCop::Cop::TrailingComma
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Style::TrailingCommaInArguments
end

class RuboCop::Cop::Style::TrailingCommaInArrayLiteral
  include ::RuboCop::Cop::TrailingComma
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def on_array(node); end
end

class RuboCop::Cop::Style::TrailingCommaInArrayLiteral
end

class RuboCop::Cop::Style::TrailingCommaInHashLiteral
  include ::RuboCop::Cop::TrailingComma
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def on_hash(node); end
end

class RuboCop::Cop::Style::TrailingCommaInHashLiteral
end

class RuboCop::Cop::Style::TrailingMethodEndStatement
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingMethodEndStatement
end

class RuboCop::Cop::Style::TrailingUnderscoreVariable
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_masgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
  UNDERSCORE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingUnderscoreVariable
end

class RuboCop::Cop::Style::TrivialAccessors
  def autocorrect(node); end

  def looks_like_trivial_writer?(node=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrivialAccessors
end

class RuboCop::Cop::Style::UnlessElse
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_if(node); end

  def range_between_condition_and_else(node, condition); end

  def range_between_else_and_end(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnlessElse
end

class RuboCop::Cop::Style::UnpackFirst
  def autocorrect(node); end

  def on_send(node); end

  def unpack_and_first_element?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnpackFirst
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Style::VariableInterpolation
  include ::RuboCop::Cop::Interpolation
  def autocorrect(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::VariableInterpolation
end

class RuboCop::Cop::Style::WhenThen
  def autocorrect(node); end

  def on_when(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WhenThen
end

class RuboCop::Cop::Style::WhileUntilDo
  def autocorrect(node); end

  def handle(node); end

  def on_until(node); end

  def on_while(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WhileUntilDo
end

class RuboCop::Cop::Style::WhileUntilModifier
  include ::RuboCop::Cop::StatementModifier
  def autocorrect(node); end

  def on_until(node); end

  def on_while(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WhileUntilModifier
end

class RuboCop::Cop::Style::WordArray
  include ::RuboCop::Cop::ArrayMinSize
  include ::RuboCop::Cop::ArraySyntax
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::PercentArray
  def autocorrect(node); end

  def on_array(node); end
  ARRAY_MSG = ::T.let(nil, ::T.untyped)
  PERCENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WordArray
  def self.largest_brackets(); end

  def self.largest_brackets=(largest_brackets); end
end

class RuboCop::Cop::Style::YodaCondition
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def file_constant_equal_program_name?(node=T.unsafe(nil)); end

  def on_send(node); end
  EQUALITY_OPERATORS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  NONCOMMUTATIVE_OPERATORS = ::T.let(nil, ::T.untyped)
  PROGRAM_NAMES = ::T.let(nil, ::T.untyped)
  REVERSE_COMPARISON = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::YodaCondition
end

class RuboCop::Cop::Style::ZeroLengthPredicate
  def autocorrect(node); end

  def non_polymorphic_collection?(node=T.unsafe(nil)); end

  def nonzero_length_predicate(node=T.unsafe(nil)); end

  def on_send(node); end

  def other_receiver(node=T.unsafe(nil)); end

  def zero_length_predicate(node=T.unsafe(nil)); end

  def zero_length_receiver(node=T.unsafe(nil)); end
  NONZERO_MSG = ::T.let(nil, ::T.untyped)
  ZERO_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ZeroLengthPredicate
end

module RuboCop::Cop::Style
end

module RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  NO_SPACE_COMMAND = ::T.let(nil, ::T.untyped)
  SINGLE_SPACE_REGEXP = ::T.let(nil, ::T.untyped)
  SPACE_COMMAND = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::SurroundingSpace
end

module RuboCop::Cop::TargetRubyVersion
  def minimum_target_ruby_version(version); end

  def support_target_ruby_version?(version); end
end

module RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Team
  def autocorrect(buffer, cops); end

  def autocorrect?(); end

  def cops(); end

  def debug?(); end

  def errors(); end

  def external_dependency_checksum(); end

  def forces(); end

  def forces_for(cops); end

  def initialize(cop_classes, config, options=T.unsafe(nil)); end

  def inspect_file(processed_source); end

  def updated_source_file(); end

  def updated_source_file?(); end

  def warnings(); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Team::Investigation
  def errors(); end

  def errors=(_); end

  def offenses(); end

  def offenses=(_); end
end

class RuboCop::Cop::Team::Investigation
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Cop::Team
end

module RuboCop::Cop::TooManyLines
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::TooManyLines
end

module RuboCop::Cop::TrailingBody
  def body_on_first_line?(node, body); end

  def first_part_of(body); end

  def trailing_body?(node); end
end

module RuboCop::Cop::TrailingBody
end

module RuboCop::Cop::TrailingComma
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::TrailingComma
end

module RuboCop::Cop::UncommunicativeName
  def check(node, args); end
  CASE_MSG = ::T.let(nil, ::T.untyped)
  FORBIDDEN_MSG = ::T.let(nil, ::T.untyped)
  LENGTH_MSG = ::T.let(nil, ::T.untyped)
  NUM_MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::UncommunicativeName
end

class RuboCop::Cop::UnusedArgCorrector
end

class RuboCop::Cop::UnusedArgCorrector
  extend ::RuboCop::Cop::RangeHelp
  def self.correct(processed_source, node); end

  def self.correct_for_blockarg_type(node); end

  def self.processed_source(); end
end

module RuboCop::Cop::Util
  include ::RuboCop::PathUtil
  LITERAL_REGEX = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Util
  def self.begins_its_line?(range); end

  def self.comment_line?(line_source); end

  def self.double_quotes_required?(string); end

  def self.escape_string(string); end

  def self.first_part_of_call_chain(node); end

  def self.interpret_string_escapes(string); end

  def self.line_range(node); end

  def self.needs_escaping?(string); end

  def self.on_node(syms, sexp, excludes=T.unsafe(nil), &block); end

  def self.parentheses?(node); end

  def self.same_line?(node1, node2); end

  def self.to_string_literal(string); end

  def self.to_supported_styles(enforced_style); end

  def self.tokens(node); end

  def self.trim_string_interporation_escape_character(str); end
end

module RuboCop::Cop::Utils
end

class RuboCop::Cop::Utils::FormatString
  def format_sequences(); end

  def initialize(string); end

  def max_digit_dollar_num(); end

  def named_interpolation?(); end
  DIGIT_DOLLAR = ::T.let(nil, ::T.untyped)
  FLAG = ::T.let(nil, ::T.untyped)
  NAME = ::T.let(nil, ::T.untyped)
  NUMBER = ::T.let(nil, ::T.untyped)
  NUMBER_ARG = ::T.let(nil, ::T.untyped)
  PRECISION = ::T.let(nil, ::T.untyped)
  SEQUENCE = ::T.let(nil, ::T.untyped)
  TEMPLATE_NAME = ::T.let(nil, ::T.untyped)
  TYPE = ::T.let(nil, ::T.untyped)
  WIDTH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Utils::FormatString::FormatSequence
  def annotated?(); end

  def arity(); end

  def begin_pos(); end

  def end_pos(); end

  def flags(); end

  def initialize(match); end

  def max_digit_dollar_num(); end

  def name(); end

  def percent?(); end

  def precision(); end

  def style(); end

  def template?(); end

  def type(); end

  def width(); end
end

class RuboCop::Cop::Utils::FormatString::FormatSequence
end

class RuboCop::Cop::Utils::FormatString
end

module RuboCop::Cop::Utils
end

class RuboCop::Cop::VariableForce
  def investigate(processed_source); end

  def process_node(node); end

  def variable_table(); end
  ARGUMENT_DECLARATION_TYPES = ::T.let(nil, ::T.untyped)
  LOGICAL_OPERATOR_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  LOOP_TYPES = ::T.let(nil, ::T.untyped)
  MULTIPLE_ASSIGNMENT_TYPE = ::T.let(nil, ::T.untyped)
  OPERATOR_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  POST_CONDITION_LOOP_TYPES = ::T.let(nil, ::T.untyped)
  REGEXP_NAMED_CAPTURE_TYPE = ::T.let(nil, ::T.untyped)
  RESCUE_TYPE = ::T.let(nil, ::T.untyped)
  SCOPE_TYPES = ::T.let(nil, ::T.untyped)
  SEND_TYPE = ::T.let(nil, ::T.untyped)
  TWISTED_SCOPE_TYPES = ::T.let(nil, ::T.untyped)
  VARIABLE_ASSIGNMENT_TYPE = ::T.let(nil, ::T.untyped)
  VARIABLE_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  VARIABLE_REFERENCE_TYPE = ::T.let(nil, ::T.untyped)
  ZERO_ARITY_SUPER_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Assignment
  include ::RuboCop::Cop::VariableForce::Branchable
  def initialize(node, variable); end

  def meta_assignment_node(); end

  def multiple_assignment?(); end

  def name(); end

  def node(); end

  def operator(); end

  def operator_assignment?(); end

  def reference!(node); end

  def referenced(); end

  def referenced?(); end

  def references(); end

  def regexp_named_capture?(); end

  def scope(); end

  def used?(); end

  def variable(); end
  MULTIPLE_LEFT_HAND_SIDE_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Assignment
end

class RuboCop::Cop::VariableForce::AssignmentReference
  def assignment?(); end

  def node(); end

  def node=(_); end
end

class RuboCop::Cop::VariableForce::AssignmentReference
  def self.[](*_); end

  def self.members(); end
end

module RuboCop::Cop::VariableForce::Branch
  CLASSES_BY_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Branch::And
  include ::RuboCop::Cop::VariableForce::Branch::LogicalOperator
  def left_body?(); end

  def right_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::And
end

class RuboCop::Cop::VariableForce::Branch::Base
  def ==(other); end

  def always_run?(); end

  def branched?(); end

  def child_node(); end

  def child_node=(_); end

  def control_node(); end

  def each_ancestor(include_self: T.unsafe(nil), &block); end

  def eql?(other); end

  def exclusive_with?(other); end

  def may_jump_to_other_branch?(); end

  def may_run_incompletely?(); end

  def parent(); end

  def scope(); end

  def scope=(_); end
end

class RuboCop::Cop::VariableForce::Branch::Base
  def self.[](*_); end

  def self.classes(); end

  def self.define_predicate(name, child_index: T.unsafe(nil)); end

  def self.inherited(subclass); end

  def self.members(); end

  def self.type(); end
end

class RuboCop::Cop::VariableForce::Branch::Case
  def else_body?(); end

  def target?(); end

  def when_clause?(); end
end

class RuboCop::Cop::VariableForce::Branch::Case
end

class RuboCop::Cop::VariableForce::Branch::Ensure
  include ::RuboCop::Cop::VariableForce::Branch::ExceptionHandler
  def ensure_body?(); end

  def main_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::Ensure
end

module RuboCop::Cop::VariableForce::Branch::ExceptionHandler
  def may_jump_to_other_branch?(); end

  def may_run_incompletely?(); end
end

module RuboCop::Cop::VariableForce::Branch::ExceptionHandler
end

class RuboCop::Cop::VariableForce::Branch::For
  def collection?(); end

  def element?(); end

  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::For
end

class RuboCop::Cop::VariableForce::Branch::If
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def falsey_body?(); end

  def truthy_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::If
end

module RuboCop::Cop::VariableForce::Branch::LogicalOperator
  def always_run?(); end
end

module RuboCop::Cop::VariableForce::Branch::LogicalOperator
end

class RuboCop::Cop::VariableForce::Branch::Or
  include ::RuboCop::Cop::VariableForce::Branch::LogicalOperator
  def left_body?(); end

  def right_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::Or
end

class RuboCop::Cop::VariableForce::Branch::Rescue
  include ::RuboCop::Cop::VariableForce::Branch::ExceptionHandler
  def else_body?(); end

  def main_body?(); end

  def rescue_clause?(); end
end

class RuboCop::Cop::VariableForce::Branch::Rescue
end

module RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def always_run?(); end

  def conditional_clause?(); end
end

module RuboCop::Cop::VariableForce::Branch::SimpleConditional
end

class RuboCop::Cop::VariableForce::Branch::Until
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::Until
end

class RuboCop::Cop::VariableForce::Branch::UntilPost
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::UntilPost
end

class RuboCop::Cop::VariableForce::Branch::While
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::While
end

class RuboCop::Cop::VariableForce::Branch::WhilePost
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::WhilePost
end

module RuboCop::Cop::VariableForce::Branch
  def self.of(target_node, scope: T.unsafe(nil)); end
end

module RuboCop::Cop::VariableForce::Branchable
  def branch(); end

  def run_exclusively_with?(other); end
end

module RuboCop::Cop::VariableForce::Branchable
end

class RuboCop::Cop::VariableForce::Reference
  include ::RuboCop::Cop::VariableForce::Branchable
  def explicit?(); end

  def initialize(node, scope); end

  def node(); end

  def scope(); end
  VARIABLE_REFERENCE_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Reference
end

class RuboCop::Cop::VariableForce::Scope
  def ==(other); end

  def body_node(); end

  def each_node(&block); end

  def include?(target_node); end

  def initialize(node); end

  def naked_top_level(); end

  def naked_top_level?(); end

  def name(); end

  def node(); end

  def variables(); end
  OUTER_SCOPE_CHILD_INDICES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Scope
end

class RuboCop::Cop::VariableForce::Variable
  def argument?(); end

  def assign(node); end

  def assignments(); end

  def block_argument?(); end

  def capture_with_block!(); end

  def captured_by_block(); end

  def captured_by_block?(); end

  def declaration_node(); end

  def explicit_block_local_variable?(); end

  def in_modifier_if?(assignment); end

  def initialize(name, declaration_node, scope); end

  def keyword_argument?(); end

  def method_argument?(); end

  def name(); end

  def reference!(node); end

  def referenced?(); end

  def references(); end

  def scope(); end

  def should_be_unused?(); end

  def used?(); end
  VARIABLE_DECLARATION_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Variable
end

class RuboCop::Cop::VariableForce::VariableReference
  def assignment?(); end

  def name(); end

  def name=(_); end
end

class RuboCop::Cop::VariableForce::VariableReference
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Cop::VariableForce::VariableTable
  def accessible_variables(); end

  def assign_to_variable(name, node); end

  def current_scope(); end

  def current_scope_level(); end

  def declare_variable(name, node); end

  def find_variable(name); end

  def initialize(hook_receiver=T.unsafe(nil)); end

  def invoke_hook(hook_name, *args); end

  def pop_scope(); end

  def push_scope(scope_node); end

  def reference_variable(name, node); end

  def scope_stack(); end

  def variable_exist?(name); end
end

class RuboCop::Cop::VariableForce::VariableTable
end

class RuboCop::Cop::VariableForce
end

module RuboCop::Cop
end

class RuboCop::Error
end

class RuboCop::Error
end

class RuboCop::ErrorWithAnalyzedFileLocation
  def column(); end

  def cop(); end

  def initialize(cause:, node:, cop:); end

  def line(); end
end

class RuboCop::ErrorWithAnalyzedFileLocation
end

module RuboCop::FileFinder
  def find_file_upwards(filename, start_dir); end

  def find_files_upwards(filename, start_dir); end
end

module RuboCop::FileFinder
  def self.root_level=(level); end

  def self.root_level?(path); end
end

module RuboCop::Formatter
end

class RuboCop::Formatter::AutoGenConfigFormatter
end

class RuboCop::Formatter::AutoGenConfigFormatter
end

class RuboCop::Formatter::BaseFormatter
  def file_finished(file, offenses); end

  def file_started(file, options); end

  def finished(inspected_files); end

  def initialize(output, options=T.unsafe(nil)); end

  def options(); end

  def output(); end

  def started(target_files); end
end

class RuboCop::Formatter::BaseFormatter
end

class RuboCop::Formatter::ClangStyleFormatter
  ELLIPSES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::ClangStyleFormatter
end

module RuboCop::Formatter::Colorizable
  def black(string); end

  def blue(string); end

  def colorize(string, *args); end

  def cyan(string); end

  def green(string); end

  def magenta(string); end

  def rainbow(); end

  def red(string); end

  def white(string); end

  def yellow(string); end
end

module RuboCop::Formatter::Colorizable
end

class RuboCop::Formatter::DisabledConfigFormatter
  def file_started(_file, _file_info); end

  def finished(_inspected_files); end
  HEADING = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::DisabledConfigFormatter
  def self.config_to_allow_offenses(); end

  def self.config_to_allow_offenses=(config_to_allow_offenses); end

  def self.detected_styles(); end

  def self.detected_styles=(detected_styles); end
end

class RuboCop::Formatter::DisabledLinesFormatter
  include ::RuboCop::PathUtil
  include ::RuboCop::Formatter::Colorizable
  def cop_disabled_line_ranges(); end

  def finished(_inspected_files); end

  def started(_target_files); end
end

class RuboCop::Formatter::DisabledLinesFormatter
end

class RuboCop::Formatter::EmacsStyleFormatter
end

class RuboCop::Formatter::EmacsStyleFormatter
end

class RuboCop::Formatter::FileListFormatter
end

class RuboCop::Formatter::FileListFormatter
end

class RuboCop::Formatter::FormatterSet
  def add_formatter(formatter_type, output_path=T.unsafe(nil)); end

  def close_output_files(); end

  def file_finished(file, offenses); end

  def file_started(file, options); end

  def finished(*args); end

  def initialize(options=T.unsafe(nil)); end

  def started(*args); end
  BUILTIN_FORMATTERS_FOR_KEYS = ::T.let(nil, ::T.untyped)
  FORMATTER_APIS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::FormatterSet
end

class RuboCop::Formatter::FuubarStyleFormatter
  def initialize(*output); end

  def progressbar_color(); end

  def started(target_files); end

  def with_color(); end
  RESET_SEQUENCE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::FuubarStyleFormatter
end

class RuboCop::Formatter::HTMLFormatter
  def files(); end

  def render_html(); end

  def summary(); end
  ELLIPSES = ::T.let(nil, ::T.untyped)
  TEMPLATE_PATH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::HTMLFormatter::Color
  def alpha(); end

  def alpha=(_); end

  def blue(); end

  def blue=(_); end

  def fade_out(amount); end

  def green(); end

  def green=(_); end

  def red(); end

  def red=(_); end
end

class RuboCop::Formatter::HTMLFormatter::Color
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Formatter::HTMLFormatter::ERBContext
  include ::RuboCop::PathUtil
  include ::RuboCop::Formatter::TextUtil
  def base64_encoded_logo_image(); end

  def decorated_message(offense); end

  def escape(string); end

  def files(); end

  def highlighted_source_line(offense); end

  def hightlight_source_tag(offense); end

  def initialize(files, summary); end

  def possible_ellipses(location); end

  def source_after_highlight(offense); end

  def source_before_highlight(offense); end

  def summary(); end
  LOGO_IMAGE_PATH = ::T.let(nil, ::T.untyped)
  SEVERITY_COLORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::HTMLFormatter::ERBContext
end

class RuboCop::Formatter::HTMLFormatter
end

class RuboCop::Formatter::JSONFormatter
  include ::RuboCop::PathUtil
  def hash_for_file(file, offenses); end

  def hash_for_location(offense); end

  def hash_for_offense(offense); end

  def metadata_hash(); end

  def output_hash(); end
end

class RuboCop::Formatter::JSONFormatter
end

class RuboCop::Formatter::OffenseCountFormatter
  def file_finished(_file, offenses); end

  def finished(_inspected_files); end

  def offense_counts(); end

  def ordered_offense_counts(offense_counts); end

  def report_summary(offense_counts); end

  def total_offense_count(offense_counts); end
end

class RuboCop::Formatter::OffenseCountFormatter
end

class RuboCop::Formatter::PacmanFormatter
  include ::RuboCop::Formatter::TextUtil
  def cols(); end

  def file_started(_file, _options); end

  def next_step(offenses); end

  def pacdots(number); end

  def progress_line(); end

  def progress_line=(progress_line); end

  def started(target_files); end

  def step(character); end

  def update_progress_line(); end
  FALLBACK_TERMINAL_WIDTH = ::T.let(nil, ::T.untyped)
  GHOST = ::T.let(nil, ::T.untyped)
  PACDOT = ::T.let(nil, ::T.untyped)
  PACMAN = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::PacmanFormatter
end

class RuboCop::Formatter::ProgressFormatter
  include ::RuboCop::Formatter::TextUtil
  def report_file_as_mark(offenses); end

  def started(target_files); end
  DOT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::ProgressFormatter
end

class RuboCop::Formatter::QuietFormatter
end

class RuboCop::Formatter::QuietFormatter
end

class RuboCop::Formatter::SimpleTextFormatter
  include ::RuboCop::Formatter::Colorizable
  include ::RuboCop::PathUtil
  def report_file(file, offenses); end

  def report_summary(file_count, offense_count, correction_count); end

  def started(_target_files); end
  COLOR_FOR_SEVERITY = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::SimpleTextFormatter::Report
  include ::RuboCop::Formatter::Colorizable
  include ::RuboCop::Formatter::TextUtil
  def initialize(file_count, offense_count, correction_count, rainbow); end

  def summary(); end
end

class RuboCop::Formatter::SimpleTextFormatter::Report
end

class RuboCop::Formatter::SimpleTextFormatter
end

class RuboCop::Formatter::TapFormatter
  def started(target_files); end
end

class RuboCop::Formatter::TapFormatter
end

module RuboCop::Formatter::TextUtil
end

module RuboCop::Formatter::TextUtil
  def self.pluralize(number, thing, options=T.unsafe(nil)); end
end

class RuboCop::Formatter::WorstOffendersFormatter
  def finished(_inspected_files); end

  def offense_counts(); end

  def ordered_offense_counts(offense_counts); end

  def report_summary(offense_counts); end

  def total_offense_count(offense_counts); end
end

class RuboCop::Formatter::WorstOffendersFormatter
end

module RuboCop::Formatter
end

class RuboCop::IncorrectCopNameError
end

class RuboCop::IncorrectCopNameError
end

class RuboCop::MagicComment
  def any?(); end

  def encoding_specified?(); end

  def frozen_string_literal(); end

  def frozen_string_literal?(); end

  def frozen_string_literal_specified?(); end

  def initialize(comment); end

  def valid_literal_value?(); end
  TOKEN = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment::EditorComment
end

class RuboCop::MagicComment::EditorComment
end

class RuboCop::MagicComment::EmacsComment
  def encoding(); end
  FORMAT = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment::EmacsComment
end

class RuboCop::MagicComment::SimpleComment
  def encoding(); end
end

class RuboCop::MagicComment::SimpleComment
end

class RuboCop::MagicComment::VimComment
  def encoding(); end
  FORMAT = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment::VimComment
end

class RuboCop::MagicComment
  def self.parse(comment); end
end

module RuboCop::NameSimilarity
  def find_similar_name(target_name, scope); end
  MINIMUM_SIMILARITY_TO_SUGGEST = ::T.let(nil, ::T.untyped)
end

module RuboCop::NameSimilarity
end

class RuboCop::NodePattern
  def ==(other); end

  def eql?(other); end

  def initialize(str); end

  def marshal_dump(); end

  def marshal_load(pattern); end

  def match(*args); end

  def pattern(); end
end

class RuboCop::NodePattern::Invalid
end

class RuboCop::NodePattern::Invalid
end

module RuboCop::NodePattern::Macros
  def def_node_matcher(method_name, pattern_str); end

  def def_node_search(method_name, pattern_str); end

  def node_search(method_name, compiler, on_match, prelude, called_from); end

  def node_search_all(method_name, compiler, called_from); end

  def node_search_body(method_name, trailing_params, prelude, match_code, on_match); end

  def node_search_first(method_name, compiler, called_from); end
end

module RuboCop::NodePattern::Macros
end

class RuboCop::NodePattern
end

class RuboCop::OptionArgumentError
end

class RuboCop::OptionArgumentError
end

class RuboCop::Options
  def parse(command_line_args); end
  DEFAULT_MAXIMUM_EXCLUSION_ITEMS = ::T.let(nil, ::T.untyped)
  EXITING_OPTIONS = ::T.let(nil, ::T.untyped)
  E_STDIN_NO_PATH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Options
end

module RuboCop::OptionsHelp
  FORMATTER_OPTION_LIST = ::T.let(nil, ::T.untyped)
  MAX_EXCL = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
end

module RuboCop::OptionsHelp
end

class RuboCop::OptionsValidator
  def boolean_or_empty_cache?(); end

  def display_only_fail_level_offenses_with_autocorrect?(); end

  def except_syntax?(); end

  def incompatible_options(); end

  def initialize(options); end

  def only_includes_redundant_disable?(); end

  def validate_auto_correct(); end

  def validate_auto_gen_config(); end

  def validate_compatibility(); end

  def validate_cop_options(); end

  def validate_exclude_limit_option(); end

  def validate_parallel(); end

  def validate_parallel_with_combo_option(); end
end

class RuboCop::OptionsValidator
  def self.validate_cop_list(names); end
end

module RuboCop::PathUtil
end

module RuboCop::PathUtil
  def self.absolute?(path); end

  def self.chdir(dir, &block); end

  def self.hidden_dir?(path); end

  def self.hidden_file_in_not_hidden_dir?(pattern, path); end

  def self.match_path?(pattern, path); end

  def self.pwd(); end

  def self.relative_path(path, base_dir=T.unsafe(nil)); end

  def self.reset_pwd(); end

  def self.smart_path(path); end
end

module RuboCop::Platform
end

module RuboCop::Platform
  def self.windows?(); end
end

class RuboCop::ProcessedSource
  def [](*args); end

  def ast(); end

  def ast_with_comments(); end

  def blank?(); end

  def buffer(); end

  def checksum(); end

  def comment_config(); end

  def commented?(source_range); end

  def comments(); end

  def comments_before_line(line); end

  def current_line(token); end

  def diagnostics(); end

  def disabled_line_ranges(); end

  def each_comment(); end

  def each_token(); end

  def file_path(); end

  def find_comment(); end

  def find_token(); end

  def following_line(token); end

  def initialize(source, ruby_version, path=T.unsafe(nil)); end

  def line_indentation(line_number); end

  def lines(); end

  def parser_error(); end

  def path(); end

  def preceding_line(token); end

  def raw_source(); end

  def ruby_version(); end

  def start_with?(string); end

  def tokens(); end

  def valid_syntax?(); end
  STRING_SOURCE_NAME = ::T.let(nil, ::T.untyped)
end

class RuboCop::ProcessedSource
  def self.from_file(path, ruby_version); end
end

class RuboCop::RemoteConfig
  def file(); end

  def inherit_from_remote(file, path); end

  def initialize(url, base_dir); end

  def uri(); end
  CACHE_LIFETIME = ::T.let(nil, ::T.untyped)
end

class RuboCop::RemoteConfig
end

class RuboCop::ResultCache
  def initialize(file, team, options, config_store, cache_root=T.unsafe(nil)); end

  def load(); end

  def save(offenses); end

  def valid?(); end
  NON_CHANGING = ::T.let(nil, ::T.untyped)
end

class RuboCop::ResultCache
  def self.allow_symlinks_in_cache_location?(config_store); end

  def self.cache_root(config_store); end

  def self.cleanup(config_store, verbose, cache_root=T.unsafe(nil)); end

  def self.inhibit_cleanup(); end

  def self.inhibit_cleanup=(inhibit_cleanup); end

  def self.source_checksum(); end

  def self.source_checksum=(source_checksum); end
end

class RuboCop::Runner
  def aborting=(aborting); end

  def aborting?(); end

  def errors(); end

  def initialize(options, config_store); end

  def run(paths); end

  def warnings(); end
  MAX_ITERATIONS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Runner::InfiniteCorrectionLoop
  def initialize(path, offenses); end

  def offenses(); end
end

class RuboCop::Runner::InfiniteCorrectionLoop
end

class RuboCop::Runner
end

class RuboCop::StringInterpreter
  STRING_ESCAPES = ::T.let(nil, ::T.untyped)
  STRING_ESCAPE_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::StringInterpreter
  def self.interpret(string); end
end

module RuboCop::StringUtil
end

module RuboCop::StringUtil
  def self.similarity(string_a, string_b); end
end

class RuboCop::TargetFinder
  def all_cops_include(); end

  def configured_include?(file); end

  def debug?(); end

  def excluded_dirs(base_dir); end

  def fail_fast?(); end

  def find(args); end

  def find_files(base_dir, flags); end

  def force_exclusion?(); end

  def included_file?(file); end

  def initialize(config_store, options=T.unsafe(nil)); end

  def process_explicit_path(path); end

  def ruby_executable?(file); end

  def ruby_extension?(file); end

  def ruby_extensions(); end

  def ruby_file?(file); end

  def ruby_filename?(file); end

  def ruby_filenames(); end

  def ruby_interpreters(file); end

  def stdin?(); end

  def target_files_in_dir(base_dir=T.unsafe(nil)); end

  def to_inspect?(file, hidden_files, base_dir_config); end

  def toplevel_dirs(base_dir, flags); end
end

class RuboCop::TargetFinder
end

class RuboCop::TargetRuby
  def initialize(config); end

  def rubocop_version_with_support(); end

  def source(); end

  def supported?(); end

  def version(); end
  DEFAULT_VERSION = ::T.let(nil, ::T.untyped)
end

class RuboCop::TargetRuby::BundlerLockFile
end

class RuboCop::TargetRuby::BundlerLockFile
end

class RuboCop::TargetRuby::Default
end

class RuboCop::TargetRuby::Default
end

class RuboCop::TargetRuby::RuboCopConfig
end

class RuboCop::TargetRuby::RuboCopConfig
end

class RuboCop::TargetRuby::RubyVersionFile
  FILENAME = ::T.let(nil, ::T.untyped)
end

class RuboCop::TargetRuby::RubyVersionFile
end

class RuboCop::TargetRuby::Source
  def initialize(config); end

  def name(); end

  def version(); end
end

class RuboCop::TargetRuby::Source
end

class RuboCop::TargetRuby
  def self.supported_versions(); end
end

class RuboCop::Token
  def begin_pos(); end

  def column(); end

  def comma?(); end

  def comment?(); end

  def end?(); end

  def end_pos(); end

  def equal_sign?(); end

  def initialize(pos, type, text); end

  def left_array_bracket?(); end

  def left_brace?(); end

  def left_bracket?(); end

  def left_curly_brace?(); end

  def left_parens?(); end

  def left_ref_bracket?(); end

  def line(); end

  def pos(); end

  def rescue_modifier?(); end

  def right_bracket?(); end

  def right_curly_brace?(); end

  def right_parens?(); end

  def semicolon?(); end

  def space_after?(); end

  def space_before?(); end

  def text(); end

  def type(); end
end

class RuboCop::Token
  def self.from_parser_token(parser_token); end
end

class RuboCop::ValidationError
end

class RuboCop::ValidationError
end

module RuboCop::Version
  MSG = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
end

module RuboCop::Version
  def self.version(debug=T.unsafe(nil)); end
end

class RuboCop::Warning
end

class RuboCop::Warning
end

module RuboCop::YAMLDuplicationChecker
end

module RuboCop::YAMLDuplicationChecker
  def self.check(yaml_string, filename, &on_duplicated); end
end

module RuboCop
end

module RubyVM::AbstractSyntaxTree
end

class RubyVM::AbstractSyntaxTree::Node
  def children(); end

  def first_column(); end

  def first_lineno(); end

  def last_column(); end

  def last_lineno(); end

  def type(); end
end

class RubyVM::AbstractSyntaxTree::Node
end

module RubyVM::AbstractSyntaxTree
  def self.of(body); end

  def self.parse(string); end

  def self.parse_file(pathname); end
end

class RubyVM::InstructionSequence
  def absolute_path(); end

  def base_label(); end

  def disasm(); end

  def disassemble(); end

  def each_child(); end

  def eval(); end

  def first_lineno(); end

  def label(); end

  def path(); end

  def to_a(); end

  def to_binary(*_); end

  def trace_points(); end
end

class RubyVM::InstructionSequence
  def self.compile(*_); end

  def self.compile_file(*_); end

  def self.compile_option(); end

  def self.compile_option=(compile_option); end

  def self.disasm(_); end

  def self.disassemble(_); end

  def self.load_from_binary(_); end

  def self.load_from_binary_extra_data(_); end

  def self.of(_); end
end

module RubyVM::MJIT
end

module RubyVM::MJIT
  def self.enabled?(); end

  def self.pause(*_); end

  def self.resume(); end
end

class RubyVM
  def self.stat(*_); end
end

class Sanitize
  def clean(html); end

  def clean_document(html); end

  def clean_node!(node); end

  def config(); end

  def document(html); end

  def fragment(html); end

  def initialize(config=T.unsafe(nil)); end

  def node!(node); end
  REGEX_HTML_CONTROL_CHARACTERS = ::T.let(nil, ::T.untyped)
  REGEX_HTML_NON_CHARACTERS = ::T.let(nil, ::T.untyped)
  REGEX_PROTOCOL = ::T.let(nil, ::T.untyped)
  REGEX_UNSUITABLE_CHARS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sanitize::CSS
  def at_rule!(rule); end

  def config(); end

  def import_url_allowed?(rule); end

  def initialize(config=T.unsafe(nil)); end

  def properties(css); end

  def property!(prop); end

  def stylesheet(css); end

  def tree!(tree); end

  def valid_url?(node); end
end

class Sanitize::CSS
  def self.properties(css, config=T.unsafe(nil)); end

  def self.stylesheet(css, config=T.unsafe(nil)); end

  def self.tree!(tree, config=T.unsafe(nil)); end
end

module Sanitize::Config
  BASIC = ::T.let(nil, ::T.untyped)
  DEFAULT = ::T.let(nil, ::T.untyped)
  RELAXED = ::T.let(nil, ::T.untyped)
  RESTRICTED = ::T.let(nil, ::T.untyped)
end

module Sanitize::Config
  def self.freeze_config(config); end

  def self.merge(config, other_config=T.unsafe(nil)); end
end

class Sanitize::Error
end

class Sanitize::Error
end

module Sanitize::Transformers
  CleanCDATA = ::T.let(nil, ::T.untyped)
  CleanComment = ::T.let(nil, ::T.untyped)
  CleanDoctype = ::T.let(nil, ::T.untyped)
end

module Sanitize::Transformers::CSS
end

class Sanitize::Transformers::CSS::CleanAttribute
  def call(env); end

  def initialize(sanitizer_or_config); end
end

class Sanitize::Transformers::CSS::CleanAttribute
end

class Sanitize::Transformers::CSS::CleanElement
  def call(env); end

  def initialize(sanitizer_or_config); end
end

class Sanitize::Transformers::CSS::CleanElement
end

module Sanitize::Transformers::CSS
end

class Sanitize::Transformers::CleanElement
  def call(env); end

  def initialize(config); end
  REGEX_DATA_ATTR = ::T.let(nil, ::T.untyped)
  UNSAFE_LIBXML_ATTRS_A = ::T.let(nil, ::T.untyped)
  UNSAFE_LIBXML_ATTRS_GLOBAL = ::T.let(nil, ::T.untyped)
  UNSAFE_LIBXML_ESCAPE_CHARS = ::T.let(nil, ::T.untyped)
  UNSAFE_LIBXML_ESCAPE_REGEX = ::T.let(nil, ::T.untyped)
end

class Sanitize::Transformers::CleanElement
end

module Sanitize::Transformers
end

class Sanitize
  def self.clean(html, config=T.unsafe(nil)); end

  def self.clean_document(html, config=T.unsafe(nil)); end

  def self.clean_node!(node, config=T.unsafe(nil)); end

  def self.document(html, config=T.unsafe(nil)); end

  def self.fragment(html, config=T.unsafe(nil)); end

  def self.node!(node, config=T.unsafe(nil)); end
end

ScanError = StringScanner::Error

module SecureRandom
  def self.bytes(n); end
end

class Set
  def ==(other); end

  def ===(o); end

  def compare_by_identity(); end

  def compare_by_identity?(); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
end

module Shellwords
end

module Shellwords
  def self.escape(str); end

  def self.join(array); end

  def self.shellescape(str); end

  def self.shelljoin(array); end

  def self.shellsplit(line); end

  def self.shellwords(line); end

  def self.split(line); end
end

class SignalException
  def signm(); end

  def signo(); end
end

class SimpleDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module Sinatra
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sinatra::Application
end

class Sinatra::Application
  def self.rdoc(); end

  def self.rdoc=(val); end

  def self.rdoc?(); end

  def self.reloader(); end

  def self.reloader=(val); end

  def self.reloader?(); end
end

class Sinatra::BadRequest
  def http_status(); end
end

class Sinatra::BadRequest
end

class Sinatra::Base
  include ::Rack::Utils
  include ::Sinatra::Helpers
  include ::Sinatra::Templates
  def app(); end

  def app=(app); end

  def call(env); end

  def call!(env); end

  def env(); end

  def env=(env); end

  def forward(); end

  def halt(*response); end

  def initialize(app=T.unsafe(nil)); end

  def options(); end

  def params(); end

  def params=(params); end

  def pass(&block); end

  def request(); end

  def request=(request); end

  def response(); end

  def response=(response); end

  def settings(); end

  def template_cache(); end
  URI_INSTANCE = ::T.let(nil, ::T.untyped)
end

class Sinatra::Base
  def self.absolute_redirects(); end

  def self.absolute_redirects=(val); end

  def self.absolute_redirects?(); end

  def self.add_charset(); end

  def self.add_charset=(val); end

  def self.add_charset?(); end

  def self.add_filter(type, path=T.unsafe(nil), **options, &block); end

  def self.after(path=T.unsafe(nil), **options, &block); end

  def self.app_file(); end

  def self.app_file=(val); end

  def self.app_file?(); end

  def self.before(path=T.unsafe(nil), **options, &block); end

  def self.bind(); end

  def self.bind=(val); end

  def self.bind?(); end

  def self.build(app); end

  def self.call(env); end

  def self.caller_files(); end

  def self.caller_locations(); end

  def self.condition(name=T.unsafe(nil), &block); end

  def self.configure(*envs); end

  def self.default_encoding(); end

  def self.default_encoding=(val); end

  def self.default_encoding?(); end

  def self.delete(path, opts=T.unsafe(nil), &bk); end

  def self.development?(); end

  def self.disable(*opts); end

  def self.dump_errors(); end

  def self.dump_errors=(val); end

  def self.dump_errors?(); end

  def self.empty_path_info(); end

  def self.empty_path_info=(val); end

  def self.empty_path_info?(); end

  def self.enable(*opts); end

  def self.environment(); end

  def self.environment=(val); end

  def self.environment?(); end

  def self.error(*codes, &block); end

  def self.errors(); end

  def self.extensions(); end

  def self.filters(); end

  def self.force_encoding(data, encoding=T.unsafe(nil)); end

  def self.get(path, opts=T.unsafe(nil), &block); end

  def self.handler_name(); end

  def self.handler_name=(val); end

  def self.handler_name?(); end

  def self.head(path, opts=T.unsafe(nil), &bk); end

  def self.helpers(*extensions, &block); end

  def self.inline_templates=(file=T.unsafe(nil)); end

  def self.layout(name=T.unsafe(nil), &block); end

  def self.link(path, opts=T.unsafe(nil), &bk); end

  def self.lock(); end

  def self.lock=(val); end

  def self.lock?(); end

  def self.logging(); end

  def self.logging=(val); end

  def self.logging?(); end

  def self.method_override(); end

  def self.method_override=(val); end

  def self.method_override?(); end

  def self.methodoverride=(val); end

  def self.methodoverride?(); end

  def self.middleware(); end

  def self.mime_type(type, value=T.unsafe(nil)); end

  def self.mime_types(type); end

  def self.mustermann_opts(); end

  def self.mustermann_opts=(val); end

  def self.mustermann_opts?(); end

  def self.new(*args, &bk); end

  def self.new!(*_); end

  def self.not_found(&block); end

  def self.options(path, opts=T.unsafe(nil), &bk); end

  def self.patch(path, opts=T.unsafe(nil), &bk); end

  def self.port(); end

  def self.port=(val); end

  def self.port?(); end

  def self.post(path, opts=T.unsafe(nil), &bk); end

  def self.prefixed_redirects(); end

  def self.prefixed_redirects=(val); end

  def self.prefixed_redirects?(); end

  def self.production?(); end

  def self.protection(); end

  def self.protection=(val); end

  def self.protection?(); end

  def self.prototype(); end

  def self.public=(value); end

  def self.public_dir(); end

  def self.public_dir=(value); end

  def self.public_folder(); end

  def self.public_folder=(val); end

  def self.public_folder?(); end

  def self.put(path, opts=T.unsafe(nil), &bk); end

  def self.quiet(); end

  def self.quiet=(val); end

  def self.quiet?(); end

  def self.quit!(); end

  def self.raise_errors(); end

  def self.raise_errors=(val); end

  def self.raise_errors?(); end

  def self.register(*extensions, &block); end

  def self.reload_templates(); end

  def self.reload_templates=(val); end

  def self.reload_templates?(); end

  def self.reset!(); end

  def self.root(); end

  def self.root=(val); end

  def self.root?(); end

  def self.routes(); end

  def self.run(); end

  def self.run!(options=T.unsafe(nil), &block); end

  def self.run=(val); end

  def self.run?(); end

  def self.running?(); end

  def self.running_server(); end

  def self.running_server=(val); end

  def self.running_server?(); end

  def self.server(); end

  def self.server=(val); end

  def self.server?(); end

  def self.session_secret(); end

  def self.session_secret=(val); end

  def self.session_secret?(); end

  def self.session_store(); end

  def self.session_store=(val); end

  def self.session_store?(); end

  def self.sessions(); end

  def self.sessions=(val); end

  def self.sessions?(); end

  def self.set(option, value=T.unsafe(nil), ignore_setter=T.unsafe(nil), &block); end

  def self.settings(); end

  def self.show_exceptions(); end

  def self.show_exceptions=(val); end

  def self.show_exceptions?(); end

  def self.start!(options=T.unsafe(nil), &block); end

  def self.static(); end

  def self.static=(val); end

  def self.static?(); end

  def self.static_cache_control(); end

  def self.static_cache_control=(val); end

  def self.static_cache_control?(); end

  def self.stop!(); end

  def self.strict_paths(); end

  def self.strict_paths=(val); end

  def self.strict_paths?(); end

  def self.template(name, &block); end

  def self.templates(); end

  def self.test?(); end

  def self.threaded(); end

  def self.threaded=(val); end

  def self.threaded?(); end

  def self.traps(); end

  def self.traps=(val); end

  def self.traps?(); end

  def self.unlink(path, opts=T.unsafe(nil), &bk); end

  def self.use(middleware, *args, &block); end

  def self.use_code(); end

  def self.use_code=(val); end

  def self.use_code?(); end

  def self.views(); end

  def self.views=(val); end

  def self.views?(); end

  def self.x_cascade(); end

  def self.x_cascade=(val); end

  def self.x_cascade?(); end
end

class Sinatra::CommonLogger
end

class Sinatra::CommonLogger
end

module Sinatra::Delegator
end

module Sinatra::Delegator
  def self.delegate(*methods); end

  def self.target(); end

  def self.target=(target); end
end

class Sinatra::ExtendedRack
  def call(env); end
end

class Sinatra::ExtendedRack
end

module Sinatra::Helpers
  def attachment(filename=T.unsafe(nil), disposition=T.unsafe(nil)); end

  def back(); end

  def bad_request?(); end

  def body(value=T.unsafe(nil), &block); end

  def cache_control(*values); end

  def client_error?(); end

  def content_type(type=T.unsafe(nil), params=T.unsafe(nil)); end

  def error(code, body=T.unsafe(nil)); end

  def etag(value, options=T.unsafe(nil)); end

  def expires(amount, *values); end

  def headers(hash=T.unsafe(nil)); end

  def informational?(); end

  def last_modified(time); end

  def logger(); end

  def mime_type(type); end

  def not_found(body=T.unsafe(nil)); end

  def not_found?(); end

  def redirect(uri, *args); end

  def redirect?(); end

  def send_file(path, opts=T.unsafe(nil)); end

  def server_error?(); end

  def session(); end

  def status(value=T.unsafe(nil)); end

  def stream(keep_open=T.unsafe(nil)); end

  def success?(); end

  def time_for(value); end

  def to(addr=T.unsafe(nil), absolute=T.unsafe(nil), add_script_name=T.unsafe(nil)); end

  def uri(addr=T.unsafe(nil), absolute=T.unsafe(nil), add_script_name=T.unsafe(nil)); end

  def url(addr=T.unsafe(nil), absolute=T.unsafe(nil), add_script_name=T.unsafe(nil)); end
  ETAG_KINDS = ::T.let(nil, ::T.untyped)
end

class Sinatra::Helpers::Stream
  def <<(data); end

  def callback(&block); end

  def close(); end

  def closed?(); end

  def each(&front); end

  def errback(&block); end

  def initialize(scheduler=T.unsafe(nil), keep_open=T.unsafe(nil), &back); end
end

class Sinatra::Helpers::Stream
  def self.defer(*_); end

  def self.schedule(*_); end
end

module Sinatra::Helpers
end

class Sinatra::IndifferentHash
  def [](key); end

  def []=(key, value); end

  def assoc(key); end

  def default(*args); end

  def default=(value); end

  def delete(key); end

  def dig(key, *other_keys); end

  def fetch(key, *args); end

  def fetch_values(*keys); end

  def has_key?(key); end

  def has_value?(value); end

  def include?(key); end

  def initialize(*args); end

  def key(value); end

  def key?(key); end

  def member?(key); end

  def merge(*other_hashes, &block); end

  def merge!(*other_hashes); end

  def rassoc(value); end

  def replace(other_hash); end

  def slice(*keys); end

  def store(key, value); end

  def transform_keys(&block); end

  def transform_values(&block); end

  def update(*other_hashes); end

  def value?(value); end

  def values_at(*keys); end
end

class Sinatra::IndifferentHash
  def self.[](*args); end
end

class Sinatra::NotFound
  def http_status(); end
end

class Sinatra::NotFound
end

class Sinatra::Request
  def accept(); end

  def accept?(type); end

  def forwarded?(); end

  def idempotent?(); end

  def preferred_type(*types); end

  def safe?(); end

  def secure?(); end
  HEADER_PARAM = ::T.let(nil, ::T.untyped)
  HEADER_VALUE_WITH_PARAMS = ::T.let(nil, ::T.untyped)
end

class Sinatra::Request::AcceptEntry
  def entry(); end

  def initialize(entry); end

  def method_missing(*args, &block); end

  def params(); end

  def params=(params); end

  def priority(); end

  def respond_to?(*args); end

  def to_s(full=T.unsafe(nil)); end

  def to_str(); end
end

class Sinatra::Request::AcceptEntry
end

class Sinatra::Request
end

class Sinatra::Response
  def body=(value); end

  def each(&blk); end

  def finish(); end

  def initialize(*_); end
  DROP_BODY_RESPONSES = ::T.let(nil, ::T.untyped)
end

class Sinatra::Response
end

class Sinatra::ShowExceptions
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Sinatra::ShowExceptions
end

module Sinatra::Templates
  def asciidoc(template, options=T.unsafe(nil), locals=T.unsafe(nil)); end

  def builder(template=T.unsafe(nil), options=T.unsafe(nil), locals=T.unsafe(nil), &block); end

  def coffee(template, options=T.unsafe(nil), locals=T.unsafe(nil)); end

  def creole(template, options=T.unsafe(nil), locals=T.unsafe(nil)); end

  def erb(template, options=T.unsafe(nil), locals=T.unsafe(nil), &block); end

  def erubis(template, options=T.unsafe(nil), locals=T.unsafe(nil)); end

  def find_template(views, name, engine); end

  def haml(template, options=T.unsafe(nil), locals=T.unsafe(nil), &block); end

  def initialize(); end

  def less(template, options=T.unsafe(nil), locals=T.unsafe(nil)); end

  def liquid(template, options=T.unsafe(nil), locals=T.unsafe(nil), &block); end

  def markaby(template=T.unsafe(nil), options=T.unsafe(nil), locals=T.unsafe(nil), &block); end

  def markdown(template, options=T.unsafe(nil), locals=T.unsafe(nil)); end

  def mediawiki(template, options=T.unsafe(nil), locals=T.unsafe(nil)); end

  def nokogiri(template=T.unsafe(nil), options=T.unsafe(nil), locals=T.unsafe(nil), &block); end

  def rabl(template, options=T.unsafe(nil), locals=T.unsafe(nil)); end

  def radius(template, options=T.unsafe(nil), locals=T.unsafe(nil)); end

  def rdoc(template, options=T.unsafe(nil), locals=T.unsafe(nil)); end

  def sass(template, options=T.unsafe(nil), locals=T.unsafe(nil)); end

  def scss(template, options=T.unsafe(nil), locals=T.unsafe(nil)); end

  def slim(template, options=T.unsafe(nil), locals=T.unsafe(nil), &block); end

  def stylus(template, options=T.unsafe(nil), locals=T.unsafe(nil)); end

  def textile(template, options=T.unsafe(nil), locals=T.unsafe(nil)); end

  def wlang(template, options=T.unsafe(nil), locals=T.unsafe(nil), &block); end

  def yajl(template, options=T.unsafe(nil), locals=T.unsafe(nil)); end
end

module Sinatra::Templates::ContentTyped
  def content_type(); end

  def content_type=(content_type); end
end

module Sinatra::Templates::ContentTyped
end

module Sinatra::Templates
end

class Sinatra::Wrapper
  def call(env); end

  def helpers(); end

  def initialize(stack, instance); end

  def settings(); end
end

class Sinatra::Wrapper
end

module Sinatra
  def self.helpers(*extensions, &block); end

  def self.new(base=T.unsafe(nil), &block); end

  def self.register(*extensions, &block); end

  def self.use(*args, &block); end
end

module SingleForwardable
  def def_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_delegators(accessor, *methods); end

  def def_single_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_single_delegators(accessor, *methods); end

  def delegate(hash); end

  def single_delegate(hash); end
end

class Socket
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

module Socket::Constants
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::ConstantLookupCache
  def all_module_aliases(); end

  def all_module_names(); end

  def all_named_modules(); end

  def class_by_name(name); end

  def name_by_class(klass); end
  DEPRECATED_CONSTANTS = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::ConstantLookupCache::ConstantEntry
  def aliases(); end

  def aliases=(_); end

  def const(); end

  def const=(_); end

  def const_name(); end

  def const_name=(_); end

  def found_name(); end

  def found_name=(_); end

  def owner(); end

  def owner=(_); end

  def primary_name(); end

  def primary_name=(_); end
end

class Sorbet::Private::ConstantLookupCache::ConstantEntry
  def self.[](*_); end

  def self.members(); end
end

class Sorbet::Private::ConstantLookupCache
end

class Sorbet::Private::CreateConfig
  include ::Sorbet::Private::StepInterface
  SORBET_CONFIG_FILE = ::T.let(nil, ::T.untyped)
  SORBET_DIR = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::CreateConfig
  def self.main(); end

  def self.output_file(); end
end

class Sorbet::Private::FetchRBIs
  include ::Sorbet::Private::StepInterface
  HEADER = ::T.let(nil, ::T.untyped)
  RBI_CACHE_DIR = ::T.let(nil, ::T.untyped)
  SORBET_CONFIG_FILE = ::T.let(nil, ::T.untyped)
  SORBET_DIR = ::T.let(nil, ::T.untyped)
  SORBET_RBI_LIST = ::T.let(nil, ::T.untyped)
  SORBET_RBI_SORBET_TYPED = ::T.let(nil, ::T.untyped)
  SORBET_TYPED_REPO = ::T.let(nil, ::T.untyped)
  SORBET_TYPED_REVISION = ::T.let(nil, ::T.untyped)
  XDG_CACHE_HOME = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::FetchRBIs
  def self.fetch_sorbet_typed(); end

  def self.main(); end

  def self.matching_version_directories(root, version); end

  def self.output_file(); end

  def self.paths_for_gem_version(gemspec); end

  def self.paths_for_ruby_version(ruby_version); end

  def self.vendor_rbis_within_paths(vendor_paths); end
end

class Sorbet::Private::FindGemRBIs
  include ::Sorbet::Private::StepInterface
  GEM_DIR = ::T.let(nil, ::T.untyped)
  HEADER = ::T.let(nil, ::T.untyped)
  RBI_CACHE_DIR = ::T.let(nil, ::T.untyped)
  XDG_CACHE_HOME = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::FindGemRBIs
  def self.main(); end

  def self.output_file(); end

  def self.paths_within_gem_sources(gemspec); end
end

module Sorbet::Private::GemGeneratorTracepoint
  include ::Sorbet::Private::StepInterface
  OUTPUT = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::GemGeneratorTracepoint::ClassDefinition
  def defs(); end

  def defs=(_); end

  def id(); end

  def id=(_); end

  def klass(); end

  def klass=(_); end
end

class Sorbet::Private::GemGeneratorTracepoint::ClassDefinition
  def self.[](*_); end

  def self.members(); end
end

class Sorbet::Private::GemGeneratorTracepoint::TracepointSerializer
  def initialize(files:, delegate_classes:); end

  def serialize(output_dir); end
  BAD_METHODS = ::T.let(nil, ::T.untyped)
  HEADER = ::T.let(nil, ::T.untyped)
  SPECIAL_METHOD_NAMES = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::GemGeneratorTracepoint::TracepointSerializer
end

class Sorbet::Private::GemGeneratorTracepoint::Tracer
end

class Sorbet::Private::GemGeneratorTracepoint::Tracer
  def self.add_to_context(item); end

  def self.disable_tracepoints(); end

  def self.finish(); end

  def self.install_tracepoints(); end

  def self.on_method_added(mod, method, singleton); end

  def self.on_module_created(mod); end

  def self.on_module_extended(extended, extender); end

  def self.on_module_included(included, includer); end

  def self.pre_cache_module_methods(); end

  def self.register_delegate_class(klass, delegate); end

  def self.start(); end

  def self.trace(); end

  def self.trace_results(); end
end

module Sorbet::Private::GemGeneratorTracepoint
  def self.main(output_dir=T.unsafe(nil)); end

  def self.output_file(); end
end

class Sorbet::Private::GemLoader
  GEM_LOADER = ::T.let(nil, ::T.untyped)
  NO_GEM = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::GemLoader
  def self.my_require(gem); end

  def self.require_all_gems(); end

  def self.require_gem(gem); end
end

class Sorbet::Private::HiddenMethodFinder
  include ::Sorbet::Private::StepInterface
  def all_modules_and_aliases(); end

  def capture_stderr(); end

  def constant_cache(); end

  def gen_source_rbi(classes, aliases); end

  def looks_like_stub_name(name); end

  def main(); end

  def mk_dir(); end

  def read_constants(); end

  def real_name(mod); end

  def require_everything(); end

  def rm_dir(); end

  def serialize_alias(source_entry, rbi_entry, my_klass, source_symbols, rbi_symbols); end

  def serialize_class(source_entry, rbi_entry, klass, source_symbols, rbi_symbols, source_by_name); end

  def serialize_constants(source, rbi, klass, is_singleton, source_symbols, rbi_symbols); end

  def symbols_id_to_name(entry, prefix); end

  def write_constants(); end

  def write_diff(source, rbi); end
  BLACKLIST = ::T.let(nil, ::T.untyped)
  DIFF_RBI = ::T.let(nil, ::T.untyped)
  ERRORS_RBI = ::T.let(nil, ::T.untyped)
  HEADER = ::T.let(nil, ::T.untyped)
  HIDDEN_RBI = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  RBI_CONSTANTS = ::T.let(nil, ::T.untyped)
  RBI_CONSTANTS_ERR = ::T.let(nil, ::T.untyped)
  SOURCE_CONSTANTS = ::T.let(nil, ::T.untyped)
  SOURCE_CONSTANTS_ERR = ::T.let(nil, ::T.untyped)
  TMP_PATH = ::T.let(nil, ::T.untyped)
  TMP_RBI = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::HiddenMethodFinder
  def self.main(); end

  def self.output_file(); end
end

module Sorbet::Private::Main
end

module Sorbet::Private::Main
  def self.cyan(msg); end

  def self.emojify(emoji, msg); end

  def self.init(); end

  def self.main(argv); end

  def self.make_step(step); end

  def self.usage(); end

  def self.yellow(msg); end
end

module Sorbet::Private::RealStdlib
end

module Sorbet::Private::RealStdlib
  def self.real_ancestors(mod); end

  def self.real_autoload?(o, klass); end

  def self.real_const_get(obj, const, arg); end

  def self.real_constants(mod); end

  def self.real_eqeq(obj, other); end

  def self.real_hash(o); end

  def self.real_instance_methods(mod, arg); end

  def self.real_is_a?(o, klass); end

  def self.real_method(obj, sym); end

  def self.real_name(o); end

  def self.real_object_id(o); end

  def self.real_private_instance_methods(mod, arg); end

  def self.real_singleton_class(obj); end

  def self.real_singleton_methods(mod, arg); end

  def self.real_spaceship(obj, arg); end

  def self.real_superclass(o); end
end

class Sorbet::Private::RequireEverything
end

class Sorbet::Private::RequireEverything
  def self.excluded_rails_files(); end

  def self.load_bundler(); end

  def self.load_rails(); end

  def self.my_require(abs_path, numerator, denominator); end

  def self.patch_kernel(); end

  def self.rails?(); end

  def self.rails_load_paths(); end

  def self.rb_file_paths(); end

  def self.require_all_files(); end

  def self.require_everything(); end
end

class Sorbet::Private::Serialize
  def alias(base, other_name); end

  def ancestor_has_method(method, klass); end

  def blacklisted_method(method); end

  def class_or_module(class_name); end

  def comparable?(value); end

  def constant(const, value); end

  def from_method(method); end

  def initialize(constant_cache); end

  def serialize_method(method, static=T.unsafe(nil), with_sig: T.unsafe(nil)); end

  def serialize_sig(parameters); end

  def to_sig(kind, name); end

  def valid_class_name(name); end

  def valid_method_name(name); end
  BLACKLIST_CONSTANTS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  SPECIAL_METHOD_NAMES = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::Serialize
  def self.header(typed=T.unsafe(nil), subcommand=T.unsafe(nil)); end
end

module Sorbet::Private::Status
end

module Sorbet::Private::Status
  def self.done(); end

  def self.say(message, print_without_tty: T.unsafe(nil)); end
end

module Sorbet::Private::StepInterface
end

module Sorbet::Private::StepInterface
  def self.main(); end

  def self.output_file(); end
end

class Sorbet::Private::SuggestTyped
  include ::Sorbet::Private::StepInterface
end

class Sorbet::Private::SuggestTyped
  def self.main(); end

  def self.output_file(); end

  def self.suggest_typed(); end
end

class Sorbet::Private::TodoRBI
  include ::Sorbet::Private::StepInterface
  HEADER = ::T.let(nil, ::T.untyped)
  OUTPUT = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::TodoRBI
  def self.main(); end

  def self.output_file(); end
end

class SortedSet
  def initialize(*args, &block); end
end

class SortedSet
  def self.setup(); end
end

class StopIteration
  def result(); end
end

class String
  include ::JSON::Ext::Generator::GeneratorMethods::String
  def []=(*_); end

  def blank?(); end

  def casecmp?(_); end

  def each_grapheme_cluster(); end

  def encode!(*_); end

  def grapheme_clusters(); end

  def parse_csv(**options); end

  def reverse!(); end

  def shellescape(); end

  def shellsplit(); end

  def succ!(); end

  def undump(); end

  def unicode_normalize(*_); end

  def unicode_normalize!(*_); end

  def unicode_normalized?(*_); end

  def unpack1(fmt); end
end

class String
  extend ::JSON::Ext::Generator::GeneratorMethods::String::Extend
end

class StringIO
  def length(); end

  def set_encoding_by_bom(); end

  def truncate(_); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class StringScanner
  def <<(_); end

  def [](_); end

  def beginning_of_line?(); end

  def bol?(); end

  def captures(); end

  def charpos(); end

  def check(_); end

  def check_until(_); end

  def clear(); end

  def concat(_); end

  def empty?(); end

  def exist?(_); end

  def fixed_anchor?(); end

  def get_byte(); end

  def getbyte(); end

  def initialize(*_); end

  def match?(_); end

  def matched(); end

  def matched?(); end

  def matched_size(); end

  def peek(_); end

  def peep(_); end

  def pointer(); end

  def pointer=(pointer); end

  def pos(); end

  def pos=(pos); end

  def post_match(); end

  def pre_match(); end

  def reset(); end

  def rest(); end

  def rest?(); end

  def rest_size(); end

  def restsize(); end

  def scan_full(_, _1, _2); end

  def scan_until(_); end

  def search_full(_, _1, _2); end

  def size(); end

  def skip(_); end

  def skip_until(_); end

  def string(); end

  def string=(string); end

  def terminate(); end

  def unscan(); end

  def values_at(*_); end
  Id = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class StringScanner
  def self.must_C_version(); end
end

class Struct
  def [](_); end

  def []=(_, _1); end

  def deconstruct(); end

  def deconstruct_keys(_); end

  def dig(*_); end

  def each_pair(); end

  def filter(*_); end

  def length(); end

  def members(); end

  def select(*_); end

  def size(); end

  def to_a(); end

  def to_h(); end

  def values(); end

  def values_at(*_); end
end

Struct::Group = Etc::Group

class Struct::HTMLElementDescription
  def attrs_depr(); end

  def attrs_depr=(_); end

  def attrs_opt(); end

  def attrs_opt=(_); end

  def attrs_req(); end

  def attrs_req=(_); end

  def defaultsubelt(); end

  def defaultsubelt=(_); end

  def depr(); end

  def depr=(_); end

  def desc(); end

  def desc=(_); end

  def dtd(); end

  def dtd=(_); end

  def empty(); end

  def empty=(_); end

  def endTag(); end

  def endTag=(_); end

  def isinline(); end

  def isinline=(_); end

  def name(); end

  def name=(_); end

  def saveEndTag(); end

  def saveEndTag=(_); end

  def startTag(); end

  def startTag=(_); end

  def subelts(); end

  def subelts=(_); end
end

class Struct::HTMLElementDescription
  def self.[](*_); end

  def self.members(); end
end

Struct::Passwd = Etc::Passwd

Struct::Tms = Process::Tms

class SystemCallError
  def errno(); end
end

class SystemExit
  def status(); end

  def success?(); end
end

module TTY
end

module TTY::Exit
  def exit_code(name_or_code=T.unsafe(nil)); end

  def exit_codes(); end

  def exit_message(name_or_code=T.unsafe(nil)); end

  def exit_messages(); end

  def exit_reserved?(code); end

  def exit_success?(code); end

  def exit_valid?(code); end

  def exit_with(name_or_code=T.unsafe(nil), message=T.unsafe(nil), io: T.unsafe(nil)); end
  VERSION = ::T.let(nil, ::T.untyped)
end

module TTY::Exit::Code
  ABORT = ::T.let(nil, ::T.untyped)
  ALARM = ::T.let(nil, ::T.untyped)
  BASE = ::T.let(nil, ::T.untyped)
  BUS_ERROR = ::T.let(nil, ::T.untyped)
  CANNOT_EXECUTE = ::T.let(nil, ::T.untyped)
  CANT_CREATE = ::T.let(nil, ::T.untyped)
  COMMAND_NOT_FOUND = ::T.let(nil, ::T.untyped)
  CONFIG_ERROR = ::T.let(nil, ::T.untyped)
  DATA_ERROR = ::T.let(nil, ::T.untyped)
  ERROR = ::T.let(nil, ::T.untyped)
  HANGUP = ::T.let(nil, ::T.untyped)
  ILLEGAL_INSTRUCTION = ::T.let(nil, ::T.untyped)
  INTERRUPT = ::T.let(nil, ::T.untyped)
  INVALID_ARGUMENT = ::T.let(nil, ::T.untyped)
  IO_ERROR = ::T.let(nil, ::T.untyped)
  KILL = ::T.let(nil, ::T.untyped)
  MEMORY_ERROR = ::T.let(nil, ::T.untyped)
  NO_HOST = ::T.let(nil, ::T.untyped)
  NO_INPUT = ::T.let(nil, ::T.untyped)
  NO_PERM = ::T.let(nil, ::T.untyped)
  NO_USER = ::T.let(nil, ::T.untyped)
  PIPE = ::T.let(nil, ::T.untyped)
  PROTOCOL = ::T.let(nil, ::T.untyped)
  QUIT = ::T.let(nil, ::T.untyped)
  SERVICE_UNAVAILABLE = ::T.let(nil, ::T.untyped)
  SHELL_MISUSE = ::T.let(nil, ::T.untyped)
  SIGNAL_BASE = ::T.let(nil, ::T.untyped)
  SOFTWARE_ERROR = ::T.let(nil, ::T.untyped)
  SUCCESS = ::T.let(nil, ::T.untyped)
  SYSTEM_ERROR = ::T.let(nil, ::T.untyped)
  SYSTEM_FILE_MISSING = ::T.let(nil, ::T.untyped)
  TEMP_FAIL = ::T.let(nil, ::T.untyped)
  TRACE_TRAP = ::T.let(nil, ::T.untyped)
  USAGE_ERROR = ::T.let(nil, ::T.untyped)
  USER1 = ::T.let(nil, ::T.untyped)
  USER2 = ::T.let(nil, ::T.untyped)
end

module TTY::Exit::Code
end

class TTY::Exit::Error
end

class TTY::Exit::Error
end

module TTY::Exit::Registry
end

module TTY::Exit::Registry
  def self.exits(); end

  def self.register_exit(name, code, message); end
end

module TTY::Exit
  extend ::TTY::Exit
  def self.included(base); end
end

module TTY
end

class Tempfile
  def _close(); end

  def inspect(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Tempfile::Remover
  def call(*args); end

  def initialize(tmpfile); end
end

class Tempfile::Remover
end

module Tilt
  LOCK = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Tilt::CSVTemplate
  def precompiled(locals); end

  def precompiled_template(locals); end
end

class Tilt::CSVTemplate
  def self.engine(); end
end

class Tilt::Cache
  def clear(); end

  def fetch(*key); end
end

class Tilt::Cache
end

module Tilt::CompiledTemplates
end

module Tilt::CompiledTemplates
end

class Tilt::Dummy
end

class Tilt::Dummy
end

class Tilt::ERBTemplate
  def precompiled(locals); end

  def precompiled_postamble(locals); end

  def precompiled_preamble(locals); end

  def precompiled_template(locals); end
  SUPPORTS_KVARGS = ::T.let(nil, ::T.untyped)
end

class Tilt::ERBTemplate
  def self.default_output_variable(); end

  def self.default_output_variable=(name); end
end

class Tilt::EtanniTemplate
  def precompiled(locals); end

  def precompiled_template(locals); end
end

class Tilt::EtanniTemplate
end

class Tilt::Mapping
  def [](file); end

  def extensions_for(template_class); end

  def lazy_map(); end

  def new(file, line=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def register(template_class, *extensions); end

  def register_lazy(class_name, file, *extensions); end

  def registered?(ext); end

  def template_for(file); end

  def template_map(); end

  def templates_for(file); end
  AUTOLOAD_IS_BROKEN = ::T.let(nil, ::T.untyped)
  LOCK = ::T.let(nil, ::T.untyped)
end

class Tilt::Mapping
end

class Tilt::NokogiriTemplate
  def evaluate(scope, locals); end

  def precompiled_postamble(locals); end

  def precompiled_preamble(locals); end

  def precompiled_template(locals); end
  DOCUMENT_HEADER = ::T.let(nil, ::T.untyped)
end

class Tilt::NokogiriTemplate
end

class Tilt::PlainTemplate
end

class Tilt::PlainTemplate
end

class Tilt::RDocTemplate
  def allows_script?(); end

  def markup(); end
end

class Tilt::RDocTemplate
end

class Tilt::SigilTemplate
  def allows_script?(); end
end

class Tilt::SigilTemplate
end

class Tilt::StringTemplate
  def precompiled(locals); end

  def precompiled_template(locals); end
end

class Tilt::StringTemplate
end

Tilt::TOPOBJECT = Tilt::CompiledTemplates

class Tilt::Template
  def basename(suffix=T.unsafe(nil)); end

  def data(); end

  def default_encoding(); end

  def eval_file(); end

  def evaluate(scope, locals, &block); end

  def file(); end

  def initialize(file=T.unsafe(nil), line=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def line(); end

  def metadata(); end

  def name(); end

  def options(); end

  def precompiled(local_keys); end

  def precompiled_postamble(local_keys); end

  def precompiled_preamble(local_keys); end

  def precompiled_template(local_keys); end

  def prepare(); end

  def render(scope=T.unsafe(nil), locals=T.unsafe(nil), &block); end
end

class Tilt::Template
  def self.default_mime_type(); end

  def self.default_mime_type=(value); end

  def self.metadata(); end
end

module Tilt
  def self.[](file); end

  def self.current_template(); end

  def self.default_mapping(); end

  def self.lazy_map(); end

  def self.new(file, line=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def self.prefer(template_class, *extensions); end

  def self.register(template_class, *extensions); end

  def self.register_lazy(class_name, file, *extensions); end

  def self.registered?(ext); end

  def self.template_for(file); end

  def self.templates_for(file); end
end

class TracePoint
  def eval_script(); end

  def event(); end

  def instruction_sequence(); end

  def parameters(); end
end

class TracePoint
  def self.new(*events); end
end

class TrueClass
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass
end

module URI
  include ::URI::RFC2396_REGEXP
end

module URI::Escape
  def decode(*arg); end

  def encode(*arg); end

  def escape(*arg); end

  def unescape(*arg); end
end

class URI::FTP
  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
end

class URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class URI::File
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
end

URI::Parser = URI::RFC2396_Parser

URI::REGEXP = URI::RFC2396_REGEXP

class URI::RFC2396_Parser
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

module URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module URI
  extend ::URI::Escape
  def self.get_encoding(label); end

end

class UnboundMethod
  def bind_call(*_); end

  def clone(); end

  def original_name(); end
end

class UncaughtThrowError
  def tag(); end

  def value(); end
end

module Unicode
end

module Unicode::DisplayWidth
  DATA_DIRECTORY = ::T.let(nil, ::T.untyped)
  DEPTHS = ::T.let(nil, ::T.untyped)
  INDEX = ::T.let(nil, ::T.untyped)
  INDEX_FILENAME = ::T.let(nil, ::T.untyped)
  NO_STRING_EXT = ::T.let(nil, ::T.untyped)
  UNICODE_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Unicode::DisplayWidth
  def self.emoji_extra_width_of(string, ambiguous=T.unsafe(nil), overwrite=T.unsafe(nil), _=T.unsafe(nil)); end

  def self.of(string, ambiguous=T.unsafe(nil), overwrite=T.unsafe(nil), options=T.unsafe(nil)); end
end

module Unicode
end

module UnicodeNormalize
end

module UnicodeNormalize
end

Visitor = Psych::Visitors::Visitor

module Warning
  def warn(_); end
end

module Warning
  extend ::Warning
  def self.[](_); end

  def self.[]=(_, _1); end
end

YAML = Psych

YAMLTree = Psych::Visitors::YAMLTree

module Zlib
  ASCII = ::T.let(nil, ::T.untyped)
  BEST_COMPRESSION = ::T.let(nil, ::T.untyped)
  BEST_SPEED = ::T.let(nil, ::T.untyped)
  BINARY = ::T.let(nil, ::T.untyped)
  DEFAULT_COMPRESSION = ::T.let(nil, ::T.untyped)
  DEFAULT_STRATEGY = ::T.let(nil, ::T.untyped)
  DEF_MEM_LEVEL = ::T.let(nil, ::T.untyped)
  FILTERED = ::T.let(nil, ::T.untyped)
  FINISH = ::T.let(nil, ::T.untyped)
  FIXED = ::T.let(nil, ::T.untyped)
  FULL_FLUSH = ::T.let(nil, ::T.untyped)
  HUFFMAN_ONLY = ::T.let(nil, ::T.untyped)
  MAX_MEM_LEVEL = ::T.let(nil, ::T.untyped)
  MAX_WBITS = ::T.let(nil, ::T.untyped)
  NO_COMPRESSION = ::T.let(nil, ::T.untyped)
  NO_FLUSH = ::T.let(nil, ::T.untyped)
  OS_AMIGA = ::T.let(nil, ::T.untyped)
  OS_ATARI = ::T.let(nil, ::T.untyped)
  OS_CODE = ::T.let(nil, ::T.untyped)
  OS_CPM = ::T.let(nil, ::T.untyped)
  OS_MACOS = ::T.let(nil, ::T.untyped)
  OS_MSDOS = ::T.let(nil, ::T.untyped)
  OS_OS2 = ::T.let(nil, ::T.untyped)
  OS_QDOS = ::T.let(nil, ::T.untyped)
  OS_RISCOS = ::T.let(nil, ::T.untyped)
  OS_TOPS20 = ::T.let(nil, ::T.untyped)
  OS_UNIX = ::T.let(nil, ::T.untyped)
  OS_UNKNOWN = ::T.let(nil, ::T.untyped)
  OS_VMCMS = ::T.let(nil, ::T.untyped)
  OS_VMS = ::T.let(nil, ::T.untyped)
  OS_WIN32 = ::T.let(nil, ::T.untyped)
  OS_ZSYSTEM = ::T.let(nil, ::T.untyped)
  RLE = ::T.let(nil, ::T.untyped)
  SYNC_FLUSH = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  ZLIB_VERSION = ::T.let(nil, ::T.untyped)
end

class Zlib::BufError
end

class Zlib::BufError
end

class Zlib::DataError
end

class Zlib::DataError
end

class Zlib::Deflate
  def <<(_); end

  def deflate(*_); end

  def flush(*_); end

  def initialize(*_); end

  def params(_, _1); end

  def set_dictionary(_); end
end

class Zlib::Deflate
  def self.deflate(*_); end
end

class Zlib::Error
end

class Zlib::Error
end

class Zlib::GzipFile
  def close(); end

  def closed?(); end

  def comment(); end

  def crc(); end

  def finish(); end

  def level(); end

  def mtime(); end

  def orig_name(); end

  def os_code(); end

  def sync(); end

  def sync=(sync); end

  def to_io(); end
end

class Zlib::GzipFile::CRCError
end

class Zlib::GzipFile::CRCError
end

class Zlib::GzipFile::Error
  def input(); end
end

class Zlib::GzipFile::Error
end

class Zlib::GzipFile::LengthError
end

class Zlib::GzipFile::LengthError
end

class Zlib::GzipFile::NoFooter
end

class Zlib::GzipFile::NoFooter
end

class Zlib::GzipFile
  def self.wrap(*_); end
end

class Zlib::GzipReader
  include ::Enumerable
  def bytes(); end

  def each(*_, &blk); end

  def each_byte(); end

  def each_char(); end

  def each_line(*_); end

  def eof(); end

  def eof?(); end

  def external_encoding(); end

  def getbyte(); end

  def getc(); end

  def initialize(*_); end

  def lineno(); end

  def lineno=(lineno); end

  def lines(*_); end

  def pos(); end

  def read(*_); end

  def readbyte(); end

  def readchar(); end

  def readpartial(*_); end

  def rewind(); end

  def tell(); end

  def ungetbyte(_); end

  def ungetc(_); end

  def unused(); end
end

class Zlib::GzipReader
end

class Zlib::GzipWriter
  def <<(_); end

  def comment=(comment); end

  def flush(*_); end

  def initialize(*_); end

  def mtime=(mtime); end

  def orig_name=(orig_name); end

  def pos(); end

  def tell(); end

  def write(*_); end
end

class Zlib::GzipWriter
end

class Zlib::Inflate
  def <<(_); end

  def add_dictionary(_); end

  def inflate(_); end

  def initialize(*_); end

  def set_dictionary(_); end

  def sync(_); end

  def sync_point?(); end
end

class Zlib::Inflate
  def self.inflate(_); end
end

class Zlib::MemError
end

class Zlib::MemError
end

class Zlib::NeedDict
end

class Zlib::NeedDict
end

class Zlib::StreamEnd
end

class Zlib::StreamEnd
end

class Zlib::StreamError
end

class Zlib::StreamError
end

class Zlib::VersionError
end

class Zlib::VersionError
end

class Zlib::ZStream
  def adler(); end

  def avail_in(); end

  def avail_out(); end

  def avail_out=(avail_out); end

  def close(); end

  def closed?(); end

  def data_type(); end

  def end(); end

  def ended?(); end

  def finish(); end

  def finished?(); end

  def flush_next_in(); end

  def flush_next_out(); end

  def reset(); end

  def stream_end?(); end

  def total_in(); end

  def total_out(); end
end

class Zlib::ZStream
end

module Zlib
  def self.adler32(*_); end

  def self.adler32_combine(_, _1, _2); end

  def self.crc32(*_); end

  def self.crc32_combine(_, _1, _2); end

  def self.crc_table(); end

  def self.deflate(*_); end

  def self.gunzip(_); end

  def self.gzip(*_); end

  def self.inflate(_); end

  def self.zlib_version(); end
end
